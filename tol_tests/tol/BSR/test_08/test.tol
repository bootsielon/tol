//////////////////////////////////////////////////////////////////////////////
//FILE: test.tol
//AUTHOR: vdebuen@tol-project.org
//CREATION: 2008-12-06
//PURPOSE: Chequea Bsr::OneNode::EstimProbit
//////////////////////////////////////////////////////////////////////////////

Text email_ = "vdebuen@tol-project.org"; 
Text link_ = "";
Text summary_ = "Chequea Bsr::OneNode::EstimProbit" ;

Real numErr0 = Copy(NError);

//Random seed setting
Real PutRandomSeed(0);
Real rndSeed = GetRandomSeed(0);
WriteLn("Current Random Seed = "<<rndSeed);

//////////////////////////////////////////////////////////////////////////////
//Randomly generated probit model to allow contrast with model estimations
//These information is unknown in real world problems
//////////////////////////////////////////////////////////////////////////////
//Original supplied data 
Matrix X1 = Rand(1000, 5, -.3, .3);
//Deived inputs
Matrix X2 = SubCol(X1,[[1]]) $* SubCol(X1,[[2]]);
//Constant input
Matrix X3 = Rand(Rows(X1),1,1,1);
//Full input matrix
Matrix X  = X1|X2|X3;
//Real parameters of linear block
Matrix b  = {Col(
  Param_1=Rand(-2,0),
  Param_2=Rand(-2,0),
  Param_3=Rand(-2,0),
  Param_4=Rand( 0,1),
  Param_5=Rand(Param_4,2),
  Param_6=Rand(Param_5,3),
  Param_7=Rand(-2,2))};
//Real standard normal independent residuals
Matrix e  = Gaussian(Rows(X),1,0,1);
//Real filter matrix
Matrix F = X*b;
//Real linear output
Matrix Z  = F+e;
//Real output probabilities
Matrix Yp = F01(Z);
//Real binary output is true when probability is great than a cutting value
Real CuttingValue = 0.50;
Matrix Y  = GE(Yp,Yp*0+CuttingValue);

//////////////////////////////////////////////////////////////////////////////
//These is the only information that will be known in real world problems
//////////////////////////////////////////////////////////////////////////////
//Data matrix containing full output and input
Matrix data.mat = Y|X1;
//Set of names of columns in data.mat
Set data.name = [["Output"]]<<For(1,Columns(X1),Text(Real j)
{ "Input_"+IntText(j)} );


//////////////////////////////////////////////////////////////////////////////
//Model definition for BSR one node API
  NameBlock bsr.oneNode.data =
//////////////////////////////////////////////////////////////////////////////
[[
  //##Documentation about the model
  Set  _.docInfo = BSR.DocInfo (
    Text Model.Name = 
      "OneNodeProbit",
    Text Model.Description = 
      "Randomly generated probit model";
    Text Session.Name = "SES_"+Model.Name+"_"<<rndSeed;
    Text Session.Description = 
      "Random seed "<<rndSeed;
    Text Session.Authors = 
      "vdebuen@tol-project.org;";
    Date Session.Creation = Copy(Now);
    Text Path = Ois.DefRoot+"BSR/" );
  //##Observational node name
  Text _.segmentName = "Obs";

  //Tool function to reduce registers length in _.linearParamInfo
  Code LPI = BysMcmc::Bsr::OneNode::LPI;
  //#Original data storer by columns with names 
  Set _.data.orig = For(1, Card(data.name), Matrix(Real j)
  {
    Matrix aux = SubCol(data.mat,[[j]]);
    Eval(data.name[j]+"=aux")
  });

  //Checks unique names and indexes them
  Real _check_data.orig = SetIndexByName(_.data.orig);

  Set _.data.handler = _.data.orig <<
  {[[
    Matrix Input_Prod_1_2 = _.data.orig::Input_1 $* _.data.orig::Input_2;
    Matrix Constant = Rand(Rows(_.data.orig[1]),1,1,1)
  ]]};

  Real _check_data.handler = SetIndexByName(_.data.handler);

  //Output vector
  Matrix _.Y = _.data.handler::Output;
  //Normal standarized transformation of frequency of ones in output should be
  //a good average prior for constant parameter 
  Real _.cteAvg = DistNormalInv(MatAvr(_.Y));

  //Linear block definition with domain and prior restrictions
  Set _.linearParamInfo = [[
    //   Variable      initVal   min    max     priAvg   priSig  priSigWeight
    LPI("Input_1",           0, -1/0,     0,         ?,       ?,          ?),
    LPI("Input_2",           0, -1/0,     0,         ?,       ?,          ?),
    LPI("Input_3",           0, -1/0,     0,         ?,       ?,          ?),
    LPI("Input_4",           0,    0,  +1/0,         ?,       ?,          ?),
    LPI("Input_5",           0,    0,  +1/0,         ?,       ?,          ?),
    LPI("Input_Prod_1_2",    0,    0,  +1/0,         ?,       ?,          ?),
    LPI("Constant" ,  _.cteAvg, -1/0,  +1/0,  _.cteAvg,    0.25,       0.90) 
  ]];
  //Input matrix
  Matrix _.X = Group("ConcatColumns",
  EvalSet(_.linearParamInfo, Matrix(Bsr.OneNode.LinearParamInfo lpi)
  {
    _.data.handler[lpi->Name]
  }));
  //A BSR probit model must have sigma=1
  Real _.sigma = 1;
  //Non mandatory members
  //Order relations between linear parameters. This member can be Empty or 
  //simply not exist if there are no known order relation
  Set _.orderRelation = [[
    //                      lower        <=  upper  
    Bsr.OrderRelation.Info("Input_4",       "Input_5"),
    Bsr.OrderRelation.Info("Input_5",       "Input_Prod_1_2")
  ]];

  // This is usefull to check range of values of each input column
  Set _.frequencyAnalysis = For(1,Card(_.linearParamInfo),Matrix(Real k)
  {
    Matrix x = SubCol(_.X,[[k]]);
    Real min = MatMin(x);
    Real max = MatMax(x);
    Set distinct = Classify(MatSet(Tra(x))[1],Real(Real a, Real b)
    {
      Compare(a,b)
    });
    Real parts = Min(Card(distinct),100); 
    Matrix frq = Frequency(x,parts,min-2/parts,max);
    Eval("Frq."+_.linearParamInfo[k]->Name+"=frq")
  })
]];
  
/* */
//////////////////////////////////////////////////////////////////////////////
//BSR generic configuration parameters
BysMcmc::Config bsr.config = [[
//////////////////////////////////////////////////////////////////////////////
//MCMC dimensions
  Real mcmc.burnin        =  1000; 
  Real mcmc.sampleLength  =  4400;
  Real mcmc.thinning      =     2; //Probit mcmc have high alternance
  Real mcmc.cacheLength   =   100;
  Code bsr.scalarSampler.nonLinBlock=BysMcmc::Options::Scalar.Sampler::Slice;

    //Try order for given by user solution to start MCMC
    Real bsr.iniVal.try.givenByUser = 3;
    //Try order for zero solution to start MCMC
    Real bsr.iniVal.try.zero = 2;
    //Try order for constrained minimum norm solution to start MCMC
    Real bsr.iniVal.try.cnstrMinNorm = 4;
    //Try order for constrained max likelihood solution to start MCMC
    Real bsr.iniVal.try.cnstrMLE = 1;
//Generic flags
  Real do.resume          =  0;
  Real do.report          =  True;
  Real do.eval            =  False; //Has no sense for probit models
  Real do.linear.effects  =  False  //Has no sense for probit models
]];

//Estimates the BSR one-node probit model
NameBlock bsr.oneNode.probit = BysMcmc::Bsr::OneNode::EstimProbit
(bsr.oneNode.data, bsr.config);

Matrix b_full = bsr.oneNode.probit::_.param;
Matrix b_ = Sub(b_full,1,1,Rows(b),1);
Matrix X_ = bsr.oneNode.data::_.X | 
            Rand(Rows(bsr.oneNode.data::_.X),
                 Rows(b_full)-Columns(bsr.oneNode.data::_.X),0,0);

//Output probabilities for given input matrix integrated over all simulated 
//vectors of parameters (Bayesian inference by exact method)
Matrix outProbExcBys = bsr.oneNode.probit::GetProb(X_);
//Output probabilities for given input matrix and average vector of 
//simulated parameters (Bayesian inference by aproximation method)
Matrix outProbAprBys = bsr.oneNode.probit::GetProbAvg(X_);

Matrix CompareBeta = b | b_;
Matrix CompareProb = Y|Yp|outProbExcBys|outProbAprBys;
Matrix residuals = InvF01(Yp)-InvF01(outProbExcBys);
Matrix CompareResiduals = residuals | e;

//Success table for Bayesian inference by exact method
Set STExcBys = Diagnostics::BinaryModel::SuccessTable(
  Diagnostics::BinaryModel::CutValRng(outProbExcBys,.01),
  bsr.oneNode.data::_.Y,
  outProbExcBys);
//Success table for Bayesian inference by aproximation method
Set STAprBys = Diagnostics::BinaryModel::SuccessTable(
  Diagnostics::BinaryModel::CutValRng(outProbAprBys,.01),
  bsr.oneNode.data::_.Y,
  outProbAprBys);

Real numErr1 = Copy(NError);

Real quality = Min(1,MatStDs(e)/MatStDs(residuals));
//Extented information about test behaviour
Set partialResults_ = 
[[
  numErr0, numErr1
]];

//This is a messure of the success of the test 
Real quality_ = And(numErr0 == numErr1)*quality;


//Return the results 
Set resultStr_ = strTestStatus(summary_, link_, quality_,
                  "Partial results = "<<partialResults_,
                  "NO DBServerType", "NO DBServerHost", "NO DBAlias",
                  email_);
WriteLn(""<<resultStr_);
resultStr_

/* */  
