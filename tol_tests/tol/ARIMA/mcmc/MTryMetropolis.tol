//////////////////////////////////////////////////////////////////////////////
Class @MTryMetropolis
//////////////////////////////////////////////////////////////////////////////
{
  Real _.n = 0;
  Real _.k = 0;
  VMatrix _.x = Rand(0,0,0,0);
  Real _.pi_logDens_x = ?;
  Real _.r = ?;
  Real _.s = 1;
  Real _.sFactor = 1.001;
  Real _.accept = ?;
  Real _.acceptRatio = ?;
  Real _.acceptRatioTarget = ?;
  Real _.constrainedDomain = False;
  Real _.simetricQ = True;
  Real _.maxDomainSearchIter = 100;
  Real _.num_draw = 0;
  Real _.num_accept = 0;
  Real _.num_Q_draw_pre = 0;
  Real _.num_Q_draw = 0;
  Real _.num_logWeight = 0;

  ////////////////////////////////////////////////////////////////////////////
  Real pi_matchesDomain(VMatrix x);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Real pi_logDens(VMatrix x);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Real Q_logDens(VMatrix x, VMatrix y) { 1 };
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  VMatrix Q_draw_pre(VMatrix x);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  VMatrix Q_draw(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE Q_draw 1 ");
    Real _.num_Q_draw := _.num_Q_draw + 1;
    Q_draw_pre(x)
/*
    VMatrix x_ = If(!_.constrainedDomain, 
    {
    //WriteLn("TRACE Q_draw 2.1 ");
      Real _.num_Q_draw_pre := _.num_Q_draw_pre + 1;
      Q_draw_pre(x)
    },
    {
    //WriteLn("TRACE Q_draw 2.2 ");
      VMatrix y = Rand(0,0,0,0);
      Real ok = False;
      Real iter = 1;
      While(And(!ok, iter<=_.maxDomainSearchIter),
      {
        VMatrix y := Q_draw_pre(x);
        Real ok := pi_matchesDomain(y);
        Real _.num_Q_draw_pre := _.num_Q_draw_pre + 1;
        Real iter := iter +1
      });
    //WriteLn("TRACE Q_draw 2.3 iter="<<iter+ " ok="<<ok);
      If(ok,y,
      {
        WriteLn("Cannot find a valid draw after "<<iter+" iterations","W");
        x
      })
    });
  //WriteLn("TRACE Q_draw 3 x_=\n"<<Matrix Tra(VMat2Mat(x_)));
    x_
*/
  };

  ////////////////////////////////////////////////////////////////////////////
  Real logWeight(VMatrix x, VMatrix y);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Real doAfterDraw(Real void);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Real accept_reject(VMatrix y)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.accept := GE(_.r,Rand(0,1));
  //WriteLn("TRACE accept_reject _.accept=\n"<<_.accept);
    Real If(_.accept, 
    {
      VMatrix _.x := Copy(y);
      Real _.num_accept := _.num_accept +1
    });
    Real _.acceptRatio := _.num_accept / _.num_draw; 
    Real Case(
    _.acceptRatio<0.50,
    {
      If(_.k<_.n,    _.k := _.k+1);
      If(_.s>1.E-3,  _.s := _.s/_.sFactor)
    },
    _.acceptRatio>0.75,
    {
      If(_.k>1,     Real _.k := _.k-1);
      If(_.s<1.E+3, Real _.s := _.s*_.sFactor)
    });

/*
    Real Case(
    _.k>1, { False },
    _.acceptRatio<_.acceptRatioTarget/1.01,
    {
      Real _.s := _.s/_.sFactor
    },
    _.acceptRatio>_.acceptRatioTarget*1.01,
    {
      Real _.s := _.s*_.sFactor
    });
*/
  //Real If(_.accept, { Real doAfterDraw(0) });
    Real doAfterDraw(0);
    _.accept
  };


  ////////////////////////////////////////////////////////////////////////////
  VMatrix draw_single_try(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.num_draw := _.num_draw + 1;
    VMatrix y = Q_draw(_.x);
    Real pi_logDens_y = pi_logDens(y);
    Real _.pi_logDens_x := pi_logDens(_.x);
    Real _.r := Min(1, If(_.simetricQ,
    {
      Exp(pi_logDens_y-_.pi_logDens_x)
    },
    {
      Exp((  pi_logDens_y + Q_logDens(  y, _.x)) -
          (_.pi_logDens_x + Q_logDens(_.x,   y)) )
    }));
    Real accept_reject(y);
    _.x
  };

    VMatrix lwYjx = Rand(0,0,0,0);
    VMatrix gYjx = Rand(0,0,0,0);
    Real lwYjx_max = ?;
    Real gYjx_sum  = ?;
    VMatrix lwXjy = Rand(0,0,0,0);
    Real lwXjy_max = ?;
    Real gXjy_sum = ?;

  ////////////////////////////////////////////////////////////////////////////
  VMatrix draw_multiple_try(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.k==1, draw_single_try(void), {
    Real _.num_draw := _.num_draw + 1;
    VMatrix J = DifEq(1/(1-B),Constant(_.k,1,1)); 
    Set Y = For(1,_.k, VMatrix Y_Q_draw(Real j) { Q_draw(_.x) });
    Real calc_numerator_Yjx(Real void)
    {
      VMatrix lwYjx := Mat2VMat(SetCol(For(1,_.k, Real(Real j)
      {
        Real _.num_logWeight := _.num_logWeight+1;
        logWeight(Y[j],_.x)
      })));
    //WriteLn("TRACE draw lwYjx=\n"<<Matrix Tra(VMat2Mat(lwYjx)));
      Real lwYjx_max := VMatMax(lwYjx);
    //WriteLn("TRACE draw lwYjx_max=\n"<<lwYjx_max);
      VMatrix gYjx := Exp(lwYjx-lwYjx_max);
    //WriteLn("TRACE draw gYjx=\n"<<Matrix Tra(VMat2Mat(gYjx)));
      Real gYjx_sum := VMatSum(gYjx);
    //WriteLn("TRACE draw gYjx_sum=\n"<<gYjx_sum);
      True
    };
    Real calc_numerator_Yjx(0);

    VMatrix draw_y(Real void)
    {
      Matrix fYjx = VMat2Mat(gYjx / gYjx_sum);
    //WriteLn("TRACE draw fYjx=\n"<<Matrix Tra(fYjx));
      Matrix perm = Sort(VMat2Mat(lwYjx),[[1]]);
    //WriteLn("TRACE draw perm=\n"<<Matrix Tra(perm));
      Matrix fxYp = PivotByRows(fYjx,perm);
    //WriteLn("TRACE draw fxYp=\n"<<Matrix Tra(fxYp));
      Matrix FxYp = DifEq(1/(1-B),fxYp);
    //WriteLn("TRACE draw FxYp=\n"<<Matrix Tra(FxYp));
      Real u = Rand(0,1);
    //WriteLn("TRACE draw Constant(_.k,1,u)=\n"<<Matrix Tra(Constant(_.k,1,u)));
      Matrix FLTu = LT(FxYp,Constant(_.k,1,u));
    //WriteLn("TRACE draw FLTu=\n"<<Matrix Tra(FLTu));
      Real sFLTu = MatSum(FLTu);
      Real h = Min(_.k,1+sFLTu);
      Real j = MatDat(perm,h,1);
    //WriteLn("TRACE draw u="<<u+" sFLTu="<<sFLTu+" h="<<h+" j="<<j);
      Y[j]
    };
    VMatrix y = If(_.k==1,Y[1],draw_y(0));
  //WriteLn("TRACE draw pi_matchesDomain(y)="<<pi_matchesDomain(y));
    Set X = For(1,_.k-1, VMatrix X_Q_draw(Real j) { Q_draw(y) }) << [[_.x]];
    Real calc_denominator_Xjy(Real void)
    {
      VMatrix lwXjy := Mat2VMat(SetCol(For(1,_.k, Real(Real j)
      {
        Real _.num_logWeight := _.num_logWeight+1;
        logWeight(X[j],y)
      })));
    //WriteLn("TRACE draw lwXjy=\n"<<Matrix Tra(VMat2Mat(lwXjy)));
      Real lwXjy_max := VMatMax(lwXjy);
    //WriteLn("TRACE draw lwXjy_max=\n"<<lwXjy_max);
      VMatrix gXjy = Exp(lwXjy-lwXjy_max);
      Real gXjy_sum := VMatSum(gXjy);
    //WriteLn("TRACE draw gXjy_sum=\n"<<gXjy_sum);
      True
    };
    Real calc_denominator_Xjy(0);

    Real _.r := Min(1,Exp(lwYjx_max-lwXjy_max)*(gYjx_sum/gXjy_sum));
  //WriteLn("TRACE draw _.r=\n"<<_.r);
    Real accept_reject(y);
    _.x
  }) }
};

//////////////////////////////////////////////////////////////////////////////
Class @MTryMetropolisGeneric : @MTryMetropolis
//////////////////////////////////////////////////////////////////////////////
{

  ////////////////////////////////////////////////////////////////////////////
  Real logLambda(VMatrix x, VMatrix y);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Real logWeight(VMatrix x, VMatrix y)
  ////////////////////////////////////////////////////////////////////////////
  {
    pi_logDens(x)+Q_logDens(x,y)+logLambda(x,y)
  }
};

//////////////////////////////////////////////////////////////////////////////
Class @MTryMetropolisSymmetric : @MTryMetropolis
//////////////////////////////////////////////////////////////////////////////
{
  Real _.simetricQ = True;
  Real _.constrainedDomain = False;

  ////////////////////////////////////////////////////////////////////////////
  Real logWeight(VMatrix x, VMatrix y)
  ////////////////////////////////////////////////////////////////////////////
  {
    pi_logDens(x)
  }
};

//////////////////////////////////////////////////////////////////////////////
Class @MTryMetropolisSymmetricNormal : @MTryMetropolisSymmetric
//////////////////////////////////////////////////////////////////////////////
{
  VMatrix _.L;  // Cov = L*L´

  ////////////////////////////////////////////////////////////////////////////
  Real pi_matchesDomain(VMatrix x) { True };
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  VMatrix Q_draw_pre(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix e = Gaussian(_.n,1,0,1);
    x + _.L*e*_.s
  }
};

//////////////////////////////////////////////////////////////////////////////
Class @MTryMetropolisTruncNormal : @MTryMetropolis
//////////////////////////////////////////////////////////////////////////////
{
  Real _.simetricQ = False;
  Real _.constrainedDomain = True;
  VMatrix _.nu = Rand(0,0,0,0);
  VMatrix _.L = Rand(0,0,0,0);  // Cov = L*L´
  VMatrix _.Li = Rand(0,0,0,0); // L*Li = I
  Real _.do_cum = False;
  Real _.pi_logScale = ?;
  Real _.iter_cum = 0;
  Real _.pi_cum = 0;
  VMatrix _.nu_cum = Rand(0,0,0,0);
  VMatrix _.var_cum = Rand(0,0,0,0);

  ////////////////////////////////////////////////////////////////////////////
  VMatrix Q_draw_pre(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix e = Gaussian(_.n,1,0,1);
     _.nu + _.L*e*_.s
  };
  ////////////////////////////////////////////////////////////////////////////
  Real Q_logDens(VMatrix x, VMatrix y)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix e = _.Li*(y-_.nu);
    -0.5*VMatDat(MtMSqr(e),1,1)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real cumulate(VMatrix x, Real x_pi_logDens, Real forze)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real Case(
    !_.do_cum, 
    { 
    //WriteLn("TRACE @MTryMetropolisTruncNormal::cumulate 2.1");
      False  
    },
    VMatMax(Abs(_.x-_.nu))==0, 
    { 
    //WriteLn("TRACE @MTryMetropolisTruncNormal::cumulate 2.2");
      False  
    },
    x_pi_logDens <= -TheMaxAbsValue, 
    { 
    //WriteLn("TRACE @MTryMetropolisTruncNormal::cumulate 2.3");
      False  
    },
    IsUnknown(_.pi_logScale),
    {
    //WriteLn("TRACE @MTryMetropolisTruncNormal::cumulate 2.4");
      Real _.iter_cum := _.iter_cum +1;
      Real _.pi_logScale := x_pi_logDens;
      Real _.pi_cum := 1;
      VMatrix _.nu_cum := x;
      VMatrix _.var_cum := (x-_.nu)^2;
    //WriteLn("TRACE @MTryMetropolisTruncNormal::cumulate 2.4 _.var_cum=\n"<<Tra(VMat2Mat(_.var_cum)));
      True
    },
    x_pi_logDens < _.pi_logScale,
    {
    //WriteLn("TRACE @MTryMetropolisTruncNormal::cumulate 2.5");
      Real _.iter_cum := _.iter_cum +1;
      Real x_pi = Exp(x_pi_logDens-_.pi_logScale);
      Real _.pi_cum := _.pi_cum + x_pi;
      VMatrix _.nu_cum := _.nu_cum + x*x_pi;
      VMatrix _.var_cum := _.var_cum + ((x-_.nu)^2)*x_pi;
    //WriteLn("TRACE @MTryMetropolisTruncNormal::cumulate 2.5 _.var_cum=\n"<<Tra(VMat2Mat(_.var_cum)));
      True
    },
    x_pi_logDens > _.pi_logScale,
    {
    //WriteLn("TRACE @MTryMetropolisTruncNormal::cumulate 2.6");
      Real _.iter_cum := _.iter_cum +1;
      Real coef = Exp(_.pi_logScale-x_pi_logDens);
      Real _.pi_logScale := x_pi_logDens;
      Real _.pi_cum := _.pi_cum*coef + 1;
      VMatrix _.nu_cum := _.nu_cum*coef + x;
      VMatrix _.var_cum := _.var_cum*coef + ((x-_.nu)^2);
    //WriteLn("TRACE @MTryMetropolisTruncNormal::cumulate 2.6 _.var_cum=\n"<<Tra(VMat2Mat(_.var_cum)));
      True
    },
    1==1,
    {
    //WriteLn("TRACE @MTryMetropolisTruncNormal::cumulate 2.7");
      False
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real logWeight(VMatrix x, VMatrix y)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real y_Q_logDens = Q_logDens(x,y);
    Real x_Q_logDens = Q_logDens(y,x);
    Real x_pi_logDens = pi_logDens(x);
    Real cumulate(x,x_pi_logDens,False);
    x_pi_logDens + 0.5*(y_Q_logDens-x_Q_logDens)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize_Q(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.pi_logDens_x := pi_logDens(_.x);
    VMatrix _.nu := _.x;
    VMatrix _.L  := Eye(_.n);
    VMatrix _.Li := Eye(_.n);
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize_cum(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.do_cum := True;
    Real _.pi_cum := 0;
    VMatrix _.nu_cum := Rand(_.n,1,0,0);
    VMatrix _.var_cum := Rand(_.n,1,0,0);
    Real cumulate(_.x, pi_logDens(_.x), True);
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real doAfterDraw_cum(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Case(
    Or(!_.do_cum, !_.iter_cum),
    {
      VMatrix _.nu := _.x;
      False  
    },
    _.pi_logDens_x > _.pi_logScale,
    {
      VMatrix _.nu := _.x;
      VMatrix var = _.var_cum /_.pi_cum;
      VMatrix _.L  := Eye(_.n,_.n,0,RPow(var,+1/2));
      VMatrix _.Li := Eye(_.n,_.n,0,RPow(var,-1/2));
      True
    },
    1==1,
    {
      VMatrix _.nu := _.nu_cum /_.pi_cum;
      VMatrix var = _.var_cum /_.pi_cum;
      VMatrix _.L  := Eye(_.n,_.n,0,RPow(var,+1/2));
      VMatrix _.Li := Eye(_.n,_.n,0,RPow(var,-1/2));
      True
    })
  }
};


//////////////////////////////////////////////////////////////////////////////
Class @MTryMetropolis_ARIMA : @MTryMetropolisTruncNormal
//////////////////////////////////////////////////////////////////////////////
{
  VMatrix _.z;
  Real _.sigma;
  Set _.arima = Copy(Empty);
  Set _.arma = Copy(Empty);
  Polyn  _.ar = 1;
  Polyn  _.ma = 1;
  NameBlock _.almagro = [[ Real void=? ]];
  VMatrix _.u0 = Rand(0,0,0,0);
  VMatrix _.z0 = Rand(0,0,0,0);
  VMatrix _.a0 = Rand(0,0,0,0);
  
  ////////////////////////////////////////////////////////////////////////////
  VMatrix arima2col(Set arima)
  ////////////////////////////////////////////////////////////////////////////
  {
  //Mat2VMat(SetCol(ARIMAToParam(arima)))
    Set arma = EvalSet(arima, Set(ARIMAStruct f)
    {
      SetOfPolyn(1-f->AR, 1-f->MA)
    });
    Mat2VMat(Tra(GetNumeric(arma)))
  };
  
  ////////////////////////////////////////////////////////////////////////////
  Set col2arima(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
//  ParamToARIMA(_.arima, MatSet(Tra(VMat2Mat(x)))[1])
    Set arma = DeepCopy(_.arma, VMat2Mat(x));
    Set arima =  DeepCopy(_.arima); 
    Set For(1,Card(_.arima), Real(Real k)
    {
      Polyn arima[k]->AR := 1-arma[k][1];
      Polyn arima[k]->MA := 1-arma[k][2];
      True
    });
    arima
  };

  ////////////////////////////////////////////////////////////////////////////
  Real setArima(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real If(_.accept,
    {
      Polyn  _.ar := ARIMAGetAR(_.arima);
      Polyn  _.ma := ARIMAGetMA(_.arima);
      NameBlock _.almagro := ARMAProcess::Eval.Almagro(_.ar,_.ma,_.z,_.sigma);
      True
    });
    VMatrix _.u0 := _.almagro::Draw.U_cond_Z(0);
    VMatrix _.z0 := _.almagro::Get.Z0(_.u0);
    VMatrix _.a0 := _.almagro::Get.A0(_.u0);
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Set arima, Real doCum)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set _.arima := DeepCopy(arima);
    Set _.arma := EvalSet(_.arima, Set(ARIMAStruct f)
    {
      SetOfPolyn(1-f->AR, 1-f->MA)
    });
    VMatrix _.x := arima2col(_.arima);
    Real _.accept := True;
    Real ok = setArima(0);
    Real _.n := VRows(_.x);
    Real _.acceptRatioTarget := 0.234  + (0.5-0.234)*Exp(1-_.n);
    Real _.k := Ceil(Sqrt(_.n));
    Real initialize_Q(0);
    Real If(doCum, initialize_cum(0));
    ok
  };
  
  ////////////////////////////////////////////////////////////////////////////
  //Inicialización de la cadena
  Static @MTryMetropolis_ARIMA New(
     VMatrix z, 
     Real sigma, 
     Set arima, 
     Real doCum)
  ////////////////////////////////////////////////////////////////////////////
  {
    @MTryMetropolis_ARIMA new = 
    [[
      VMatrix _.z = z;
      Real _.sigma = sigma
    ]];
    Real new::initialize(arima, doCum);
    new
  };
  
  ////////////////////////////////////////////////////////////////////////////
  Real doAfterDraw(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set If(_.accept, _.arima := col2arima(_.x));
    Real setArima(void)
//  Real doAfterDraw_cum(void)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real pi_matchesDomain(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set arima = col2arima(x);
    Polyn ar = ARIMAGetAR(arima);
    Polyn ma = ARIMAGetMA(arima);
    And(IsStationary(ar), IsStationary(ma))
  };

  ////////////////////////////////////////////////////////////////////////////
  Real pi_logDens_(Set arima)
  ////////////////////////////////////////////////////////////////////////////
  {
    Polyn ar = ARIMAGetAR(arima);
    Polyn ma = ARIMAGetMA(arima);
    If(Or(!IsStationary(ar), !IsStationary(ma)), -TheMaxAbsValue,
      _.almagro::LogLH.Z_cond_U(ar,ma,_.z0,_.a0) )
  };
  
  ////////////////////////////////////////////////////////////////////////////
  Real pi_logDens(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    pi_logDens_(col2arima(x))
  };

  Real _.simetricQ = True;
  ////////////////////////////////////////////////////////////////////////////
  VMatrix Q_draw(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix e = Gaussian(_.n,1,0,1);
    y = x + _.L*e*_.s;
  //WriteLn("TRACE Q_draw y=\n"<<Matrix Tra(VMat2Mat(y)));
    y
  };
  ////////////////////////////////////////////////////////////////////////////
  Real logWeight(VMatrix x, VMatrix y)
  ////////////////////////////////////////////////////////////////////////////
  {
    pi_logDens(x)
  };

  ////////////////////////////////////////////////////////////////////////////
  Matrix move_to_average(Real maxIter)
  ////////////////////////////////////////////////////////////////////////////
  {
/* * /
    Real pi_logDens_x = _.pi_logDens_x;
    VMatrix x = _.x;
    Matrix Y = Group("ConcatRows", For(1,maxIter,Matrix(Real iter)
    {
      VMatrix y = arima2col(RandCopyARIMA(_.arima));
      Real pi_logDens_y = pi_logDens(y);
      Real pi_logDens_y_dif = pi_logDens_y - pi_logDens_x;
      Real If(pi_logDens_y_dif>0,
      {
        Real coef = Exp(-pi_logDens_y_dif);
        VMatrix x := (x*coef + y)/(coef+1);
        Real pi_logDens_x := pi_logDens(x)
      },
      {
        Real coef = Exp(pi_logDens_y_dif);
        VMatrix x := (x + y*coef)/(coef+1);
        Real pi_logDens_x := pi_logDens(x)
      });
      Copy(VMat2Mat(Tra(x)))
    }));
/* */
    Matrix pi_logDens_y = Rand(1,maxIter,0,0);
    Matrix Y = Group("ConcatRows", For(1,maxIter,Matrix(Real iter)
    {
      VMatrix y = arima2col(RandCopyARIMA(_.arima));
      Real PutMatDat(pi_logDens_y, 1, iter, pi_logDens(y));
      Copy(VMat2Mat(Tra(y)))
    }));
    Real pi_logDens_max = MatMax(pi_logDens_y);
    Matrix w = Exp(pi_logDens_y - pi_logDens_max);
    Matrix g = w * (1/MatSum(w));
    VMatrix _.x := Mat2VMat(Tra(g*Y));
    Real _.pi_logDens_x := pi_logDens(_.x);
    Real doAfterDraw(0);
/* */
    Y
  }

};

