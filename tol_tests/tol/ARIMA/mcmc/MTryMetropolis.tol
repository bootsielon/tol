//////////////////////////////////////////////////////////////////////////////
Class @MTryMetropolis
//////////////////////////////////////////////////////////////////////////////
{
  Real useOnlySingleTry = False;
  Real _.n = 0;
  Real _.k = 0;
  VMatrix _.x = Rand(0,0,0,0);
  Real _.r = ?;
  Real _.s = 1;
  Real _.sFactor = 1.001;
  Real _.accept = ?;
  Real _.acceptRatio = ?;
  Real _.acceptRatioTarget = ?;
  Real _.constrainedDomain = False;
  Real _.simetricQ = True;
  Real _.maxDomainSearchIter = 100;
  Real _.num_draw = 0;
  Real _.num_accept = 0;
  Real _.num_logWeight = 0;

  VMatrix _.nu = Rand(0,0,0,0);
  VMatrix _.L = Rand(0,0,0,0);  // Cov = L*L´
  VMatrix _.Li = Rand(0,0,0,0); // L*Li = I

  ////////////////////////////////////////////////////////////////////////////
  VMatrix Q_draw(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix e = Gaussian(_.n,1,0,1);
     _.nu + _.L*e*_.s
  };

  ////////////////////////////////////////////////////////////////////////////
  Real Q_logDens(VMatrix x, VMatrix y)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix e = _.Li*(y-x);
    -0.5*VMatDat(MtMSqr(e),1,1)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real pi_logDens_aprox(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix e = _.Li*(x-_.nu);
    -0.5*VMatDat(MtMSqr(e),1,1)    
  };

  ////////////////////////////////////////////////////////////////////////////
  Real pi_matchesDomain(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real pi_logDens(VMatrix x);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Real logLambda(VMatrix x, VMatrix y)
  ////////////////////////////////////////////////////////////////////////////
  {
    -Q_logDens(x,y)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real logWeight(VMatrix x, VMatrix y)
  ////////////////////////////////////////////////////////////////////////////
  {
    pi_logDens(x)
  }

  ////////////////////////////////////////////////////////////////////////////
  Real doAfterDraw(Real void);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Real accept_reject(VMatrix y)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.accept := GE(_.r,Rand(0,1));
  //WriteLn("TRACE accept_reject _.accept=\n"<<_.accept);
    Real If(_.accept, 
    {
      VMatrix _.x := Copy(y);
      Real _.num_accept := _.num_accept +1
    });
    Real _.acceptRatio := _.num_accept / _.num_draw; 
    Real If(useOnlySingleTry, Case(
    _.k>1, { False },
    _.acceptRatio<_.acceptRatioTarget/1.01,
    {
      Real _.s := _.s/_.sFactor
    },
    _.acceptRatio>_.acceptRatioTarget*1.01,
    {
      Real _.s := _.s*_.sFactor
    }),
    Case(
    _.acceptRatio<0.50,
    {
      If(_.k<_.n,    _.k := _.k+1);
      If(_.s>1.E-3,  _.s := _.s/_.sFactor)
    },
    _.acceptRatio>0.75,
    {
      If(_.k>1,     Real _.k := _.k-1);
      If(_.s<1.E+3, Real _.s := _.s*_.sFactor)
    }));
    Real doAfterDraw(0);
    _.accept
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix draw_single_try(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.num_draw := _.num_draw + 1;
    VMatrix y = Q_draw(_.x);
    Real pi_logDens_y = pi_logDens(y);
    Real pi_logDens_x = pi_logDens(_.x);
    Real _.r := Min(1, If(_.simetricQ,
    {
      Exp(pi_logDens_y-pi_logDens_x)
    },
    {
      Exp((pi_logDens_y + Q_logDens(  y, _.x)) -
          (pi_logDens_x + Q_logDens(_.x,   y)) )
    }));
    Real accept_reject(y);
    _.x
  };


  ////////////////////////////////////////////////////////////////////////////
  VMatrix draw_multiple_try(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.k==1, draw_single_try(void), {
    VMatrix lwYjx = Rand(0,0,0,0);
    VMatrix gYjx = Rand(0,0,0,0);
    Real lwYjx_max = ?;
    Real gYjx_sum  = ?;
    VMatrix lwXjy = Rand(0,0,0,0);
    Real lwXjy_max = ?;
    Real gXjy_sum = ?;
    Real _.num_draw := _.num_draw + 1;
    VMatrix J = DifEq(1/(1-B),Constant(_.k,1,1)); 
    Set Y = For(1,_.k, VMatrix Y_Q_draw(Real j) { Q_draw(_.x) });
    Real calc_numerator_Yjx(Real void)
    {
      VMatrix lwYjx := Mat2VMat(SetCol(For(1,_.k, Real(Real j)
      {
        Real _.num_logWeight := _.num_logWeight+1;
        logWeight(Y[j],_.x)
      })));
    //WriteLn("TRACE draw lwYjx=\n"<<Matrix Tra(VMat2Mat(lwYjx)));
      Real lwYjx_max := VMatMax(lwYjx);
    //WriteLn("TRACE draw lwYjx_max=\n"<<lwYjx_max);
      VMatrix gYjx := Exp(lwYjx-lwYjx_max);
    //WriteLn("TRACE draw gYjx=\n"<<Matrix Tra(VMat2Mat(gYjx)));
      Real gYjx_sum := VMatSum(gYjx);
    //WriteLn("TRACE draw gYjx_sum=\n"<<gYjx_sum);
      True
    };
    Real calc_numerator_Yjx(0);

    VMatrix draw_y(Real void)
    {
      Matrix fYjx = VMat2Mat(gYjx / gYjx_sum);
    //WriteLn("TRACE draw fYjx=\n"<<Matrix Tra(fYjx));
      Matrix perm = Sort(VMat2Mat(lwYjx),[[1]]);
    //WriteLn("TRACE draw perm=\n"<<Matrix Tra(perm));
      Matrix fxYp = PivotByRows(fYjx,perm);
    //WriteLn("TRACE draw fxYp=\n"<<Matrix Tra(fxYp));
      Matrix FxYp = DifEq(1/(1-B),fxYp);
    //WriteLn("TRACE draw FxYp=\n"<<Matrix Tra(FxYp));
      Real u = Rand(0,1);
    //WriteLn("TRACE draw Constant(_.k,1,u)=\n"<<Matrix Tra(Constant(_.k,1,u)));
      Matrix FLTu = LT(FxYp,Constant(_.k,1,u));
    //WriteLn("TRACE draw FLTu=\n"<<Matrix Tra(FLTu));
      Real sFLTu = MatSum(FLTu);
      Real h = Min(_.k,1+sFLTu);
      Real j = MatDat(perm,h,1);
    //WriteLn("TRACE draw u="<<u+" sFLTu="<<sFLTu+" h="<<h+" j="<<j);
      Y[j]
    };
    VMatrix y = If(_.k==1,Y[1],draw_y(0));
  //WriteLn("TRACE draw pi_matchesDomain(y)="<<pi_matchesDomain(y));
    Set X = For(1,_.k-1, VMatrix X_Q_draw(Real j) { Q_draw(y) }) << [[_.x]];
    Real calc_denominator_Xjy(Real void)
    {
      VMatrix lwXjy := Mat2VMat(SetCol(For(1,_.k, Real(Real j)
      {
        Real _.num_logWeight := _.num_logWeight+1;
        logWeight(X[j],y)
      })));
    //WriteLn("TRACE draw lwXjy=\n"<<Matrix Tra(VMat2Mat(lwXjy)));
      Real lwXjy_max := VMatMax(lwXjy);
    //WriteLn("TRACE draw lwXjy_max=\n"<<lwXjy_max);
      VMatrix gXjy = Exp(lwXjy-lwXjy_max);
      Real gXjy_sum := VMatSum(gXjy);
    //WriteLn("TRACE draw gXjy_sum=\n"<<gXjy_sum);
      True
    };
    Real calc_denominator_Xjy(0);

    Real _.r := Min(1,Exp(lwYjx_max-lwXjy_max)*(gYjx_sum/gXjy_sum));
  //WriteLn("TRACE draw _.r=\n"<<_.r);
    Real accept_reject(y);
    _.x
  }) }

};



//////////////////////////////////////////////////////////////////////////////
Class @MTryMetropolis_ARIMA : @MTryMetropolis
//////////////////////////////////////////////////////////////////////////////
{
  VMatrix _.z;
  Real _.sigma;
  Set _.arima = Copy(Empty);
  Set _.arma = Copy(Empty);
  Polyn  _.ar = 1;
  Polyn  _.ma = 1;
  NameBlock _.almagro = [[ Real void=? ]];
  VMatrix _.u0 = Rand(0,0,0,0);
  VMatrix _.z0 = Rand(0,0,0,0);
  VMatrix _.a0 = Rand(0,0,0,0);
  
  ////////////////////////////////////////////////////////////////////////////
  VMatrix arima2col(Set arima)
  ////////////////////////////////////////////////////////////////////////////
  {
  //Mat2VMat(SetCol(ARIMAToParam(arima)))
    Set arma = EvalSet(arima, Set(ARIMAStruct f)
    {
      SetOfPolyn(1-f->AR, 1-f->MA)
    });
    Mat2VMat(Tra(GetNumeric(arma)))
  };
  
  ////////////////////////////////////////////////////////////////////////////
  Set col2arima(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
//  ParamToARIMA(_.arima, MatSet(Tra(VMat2Mat(x)))[1])
    Set arma = DeepCopy(_.arma, VMat2Mat(x));
    Set arima =  DeepCopy(_.arima); 
    Set For(1,Card(_.arima), Real(Real k)
    {
      Polyn arima[k]->AR := 1-arma[k][1];
      Polyn arima[k]->MA := 1-arma[k][2];
      True
    });
    arima
  };

  ////////////////////////////////////////////////////////////////////////////
  Real setArima(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real If(_.accept,
    {
      Polyn  _.ar := ARIMAGetAR(_.arima);
      Polyn  _.ma := ARIMAGetMA(_.arima);
      NameBlock _.almagro := ARMAProcess::Eval.Almagro(_.ar,_.ma,_.z,_.sigma);
      True
    });
    VMatrix _.u0 := _.almagro::Draw.U_cond_Z(0);
    VMatrix _.z0 := _.almagro::Get.Z0(_.u0);
    VMatrix _.a0 := _.almagro::Get.A0(_.u0);
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Set arima)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set _.arima := DeepCopy(arima);
    Set _.arma := EvalSet(_.arima, Set(ARIMAStruct f)
    {
      SetOfPolyn(1-f->AR, 1-f->MA)
    });
    VMatrix _.x := arima2col(_.arima);
    Real _.accept := True;
    Real ok = setArima(0);
    Real _.n := VRows(_.x);
    Real _.acceptRatioTarget := 0.234  + (0.5-0.234)*Exp(1-_.n);
    Real _.k := Ceil(Sqrt(_.n));
    ok
  };
  
  ////////////////////////////////////////////////////////////////////////////
  //Inicialización de la cadena
  Static @MTryMetropolis_ARIMA New(
     VMatrix z, 
     Real sigma, 
     Set arima)
  ////////////////////////////////////////////////////////////////////////////
  {
    @MTryMetropolis_ARIMA new = 
    [[
      VMatrix _.z = z;
      Real _.sigma = sigma
    ]];
    Real new::initialize(arima);
    new
  };
  
  ////////////////////////////////////////////////////////////////////////////
  Real doAfterDraw(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set If(_.accept, _.arima := col2arima(_.x));
    Real setArima(void)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real pi_matchesDomain(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set arima = col2arima(x);
    Polyn ar = ARIMAGetAR(arima);
    Polyn ma = ARIMAGetMA(arima);
    And(IsStationary(ar), IsStationary(ma))
  };

  ////////////////////////////////////////////////////////////////////////////
  Real pi_logDens_(Set arima)
  ////////////////////////////////////////////////////////////////////////////
  {
    Polyn ar = ARIMAGetAR(arima);
    Polyn ma = ARIMAGetMA(arima);
    If(Or(!IsStationary(ar), !IsStationary(ma)), -TheMaxAbsValue,
      _.almagro::LogLH.Z_cond_U(ar,ma,_.z0,_.a0) )
  };
  
  ////////////////////////////////////////////////////////////////////////////
  Real pi_logDens(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    pi_logDens_(col2arima(x))
  };


  ////////////////////////////////////////////////////////////////////////////
  Matrix move_to_average(Real maxIter)
  ////////////////////////////////////////////////////////////////////////////
  {
/* * /
    Real pi_logDens_x = _.pi_logDens_x;
    VMatrix x = _.x;
    Matrix Y = Group("ConcatRows", For(1,maxIter,Matrix(Real iter)
    {
      VMatrix y = arima2col(RandCopyARIMA(_.arima));
      Real pi_logDens_y = pi_logDens(y);
      Real pi_logDens_y_dif = pi_logDens_y - pi_logDens_x;
      Real If(pi_logDens_y_dif>0,
      {
        Real coef = Exp(-pi_logDens_y_dif);
        VMatrix x := (x*coef + y)/(coef+1);
        Real pi_logDens_x := pi_logDens(x)
      },
      {
        Real coef = Exp(pi_logDens_y_dif);
        VMatrix x := (x + y*coef)/(coef+1);
        Real pi_logDens_x := pi_logDens(x)
      });
      Copy(VMat2Mat(Tra(x)))
    }));
/* */
    Matrix pi_logDens_y = Rand(1,maxIter,0,0);
    Matrix Y = Group("ConcatRows", For(1,maxIter,Matrix(Real iter)
    {
      VMatrix y = arima2col(RandCopyARIMA(_.arima));
      Real PutMatDat(pi_logDens_y, 1, iter, pi_logDens(y));
      Copy(VMat2Mat(Tra(y)))
    }));
    Real pi_logDens_max = MatMax(pi_logDens_y);
    Matrix w = Exp(pi_logDens_y - pi_logDens_max);
    Matrix g = w * (1/MatSum(w));
    VMatrix _.x := Mat2VMat(Tra(g*Y));
    Real _.pi_logDens_x := pi_logDens(_.x);
    Real doAfterDraw(0);
/* */
    Y
  }

};

