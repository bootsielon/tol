/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : client.tol
// PURPOSE: TolPackage client tools
//////////////////////////////////////////////////////////////////////////////

Text _.autodoc.member.Client= 
"Sistema cliente de gestión de paquetes TOL";

//////////////////////////////////////////////////////////////////////////////
NameBlock Client = [[
//////////////////////////////////////////////////////////////////////////////

Text _.localRoot = TolPackage::_.localRoot +"Client/";

Set _.versSyncInfo = Copy(Empty);
//Listado de todos los paquetes disponibles
Set _.packSyncInfo = Copy(Empty);
//Paquetes para los que la versión remota es más moderna
Set _.packForUpdate = Copy(Empty);
//Paquetes para los que hay versiones remotas ulteriores
Set _.packForUpgrade = Copy(Empty);
//Paquetes no instalados
Set _.packForInstall = Copy(Empty);
//Paquetes ya instalados
Set _.packInstalled = Copy(Empty);

Text _common_php_arguments = "";

Real  trace_max_level = 0;

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member._trace = 
"Muestra la traza especificada";
Real _trace(Text method, Text message, Real level)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("[TolPackage::Client::_trace] ("+method+","+message+" "<<level+") trace_max_level="<<trace_max_level);
  If(level > trace_max_level, 0, 
  {
    WriteLn("[TolPackage::Client::"+method+"] "+message);
    1
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Initialize = 
"Inicializa el cliente del servicio de paquetes TOL";
Real Initialize(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("Initialize", "Begin", 1);
  Real TolPackage::Initialize(void);
  Text _common_php_arguments := 
    "tol_package_version="<<TolPackage::_.version+
    "&tol_version="+Replace(TolPackage::_.currentTolVersion," ","%20");
  Real OSDirMake(_.localRoot);
  Real _trace("Initialize", "End", 1);
  True
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.AddRepository = 
"Añade un repositorio a la lista de configuración del usuario:\n"
"  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories\n";
Real AddRepository(Text url)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("AddRepository", "Begin", 1);
  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories :=
    Unique(TolConfigManager::Config::Upgrading::TolPackage::Repositories <<
           [[url]]);
  Real TolConfigManager::SaveConfig(TolConfigManager::Config);
  Real _trace("AddRepository", "End", 1);
  True
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetRequirements= 
"Crea un texto con los #Require para una lista de paquetes";
Text GetRequirements(Set packages)
//////////////////////////////////////////////////////////////////////////////
{
  SetSum(EvalSet(packages,Text(Text required)
  {
    "#Require "+required+";\n"
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.DoRequirements= 
"Llama a #Require para una lista de paquetes";
Real DoRequirements(Set packages)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("DoRequirements", "Begin", 1);
  Set EvalSet(packages,Real(Text required)
  {
    Set IncludeText("#Require "+required+";\nReal True;");
    True
  });
  Real _trace("DoRequirements", "End", 1);
  True
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalLastCompatible = 
"Devuelve la última versión de un paquete disponible localmente que es "
"compatible con la versión actual de TOL.";
Text LocalLastCompatible(Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("LocalLastCompatible", "Begin", 1);
  Set pkgLst = GetDir(TolPackage::Client::_.localRoot)[2];
  Text vsi.path = _.localRoot+"/VersSyncInfo.oza";
  Real If(!FileExist(vsi.path), RemoteUpdateVersSyncInfo(false));
  Set vsi = If(!FileExist(vsi.path), Copy(Empty), { Include(vsi.path) });
  Set pkgSel = Select(pkgLst,Real(Text pkgNamVer)
  {
  //WriteLn("_trace LocalLastCompatible 2 checking version ="<<pkgNamVer);
    Real ok1 = TextBeginWith(pkgNamVer, package+".");
    If(!ok1, False,
    {
      Real idx = FindIndexByName(vsi, pkgNamVer);
      If(idx<=0, True,
      {
        Real ok2 = And(
         Compare.VersionString(vsi[idx]->te_min_tol_version,TolPackage::_.currentTolVersion)<=0,
         Compare.VersionString(vsi[idx]->te_max_tol_version,TolPackage::_.currentTolVersion)>=0;
      //WriteLn("_trace LocalLastCompatible 3 min="<<vsi[idx]->te_min_tol_version);
      //WriteLn("_trace LocalLastCompatible 4 cur="<<TolPackage::_.currentTolVersion);
      //WriteLn("_trace LocalLastCompatible 5 max="<<vsi[idx]->te_max_tol_version);
      //WriteLn("_trace LocalLastCompatible 6 ok2="<<ok2);
        ok2
      }) 
    })
  });
  Text last = If(!Card(pkgSel),"",
  {
    Set pkgSort = Sort(pkgSel, Real(Text a, Text b) { 
      Compare.VersionString(b, a) });
    pkgSort[1]
  });
  Real _trace("LocalLastCompatible", "End", 1);
  last
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalPath = 
"Devuelve el path completo del fichero local correspondiente a un paquete "
"comprimido.";
Text LocalPath(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  TolPackage::Client::_.localRoot+package.version+"/"+package.version+".zip"
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalOza = 
"Devuelve el path completo del fichero local OIS correspondiente a un "
"paquete.";
Text LocalOza(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  TolPackage::Client::_.localRoot+package.version+"/"+package.version+".oza"
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalResourcePath = 
"Devuelve el path completo del directorio local de un recurso ajeno a TOL "
"necesario para el paquete especificado.";
Text LocalResourcePath(Text package.version, Text resource)
//////////////////////////////////////////////////////////////////////////////
{
  TolPackage::Client::_.localRoot+package.version+"/"+resource
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalInstallPackage = 
"Instala un paquete desde el archivo local comprimido dado por el "
"argumento:\n"
"  Text pkg.path.zip = \"<directory>/<name>.<high>.<low>.zip\"\n";
Real LocalInstallPackage(Text pkg.path.zip)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("LocalInstallPackage", "Begin", 1);
  Real OSFilCopy(pkg.path.zip, _.localRoot);
  Text pkg.name.zip = GetFileName(pkg.path.zip);
  Text pkg.name = Replace(pkg.name.zip,".zip","");
  Real PackArchive::UnpackFull("ZipArchive",_.localRoot+pkg.name,True);
  Real _trace("LocalInstallPackage", "End", 1);
  FileExist(_.localRoot+pkg.name+"/"+pkg.name+".oza")
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalClean = 
"Elimina un paquete local concreto.\n"
"Si no se especifica número de versión se borrarán todas las versiones "
"locales de dicho paquete.";
Real LocalClean(Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("LocalClean", "Begin", 1);
  Real ok = If(TextFind(package,"."),
  {
    Real OSDirRemove(_.localRoot+package)
  },
  {
    Set dir = GetDir(_.localRoot)[2];
    Set sel = Select(dir,Real(Text sub)
    {
      TextBeginWith(sub,package)
    });
    SetMin(EvalSet(sel,Real(Text pkg)
    {
      OSDirRemove(_.localRoot+pkg)
    }))
  });
  Real _trace("LocalClean", "End", 1);
  ok
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalClean.All = 
"Elimina todos los paquetes disponibles localmente.";
Real LocalCleanAll(Text unused)
//////////////////////////////////////////////////////////////////////////////
{
  Real OSDirRemove(_.localRoot);
  Real OSDirMake(_.localRoot)
};

//////////////////////////////////////////////////////////////////////////////
  Set GetRepositoryInfo(Text url)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("GetRepositoryInfo", "Begin", 1);
  Text pkgInfo = GetUrlContents(url);
  Real old.show = Show(False,"ALL");
  Set pkgLst = IncludeText(pkgInfo);
  Real Show(old.show,"ALL");
  Real _trace("GetRepositoryInfo", "End", 1);
  pkgLst
};


/////////////////////////////////////////////////////////////////// ///////////
  Real CheckRepositoryPing(Text url)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("CheckRepositoryPing", "Begin", 1);
  Real ok = If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, False, 
  {
    Real key = IntRand(111111111,999999999);
    Set info = GetRepositoryInfo(url+"?"+_common_php_arguments+
      "&action=ping&key="<<key);
    Real ok = Case(
      !Card(info),False, 
      Grammar(info[1])!="Real",False,
      1==1, info[1]==key);
  //WriteLn("_trace [CheckRepositoryPing] url="<<url+" info="<<info+" ok="<<ok);
    ok
  });
  Real _trace("CheckRepositoryPing", "End", 1);
  ok
};

//////////////////////////////////////////////////////////////////////////////
  Real ChecktolProjectPing(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  CheckRepositoryPing(TolPackage::_.official)
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetMinTolVersionForPackage = 
"Devuelve la versión de TOL mínima que requiere un paquete dado"
"Si no se encuentra el paquete se devuelve la cadena vacía.";
Text GetMinTolVersionForPackage(Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("GetMinTolVersionForPackage", "Begin", 1);
//WriteLn("_trace [GetMinTolVersionForPackage] 1 package='"<<package+"'");
  Text found = If(!ChecktolProjectPing(?), "", 
  {
  //WriteLn("_trace [GetMinTolVersionForPackage] 2");
    Set repositories = 
      TolConfigManager::Config::Upgrading::TolPackage::Repositories;
    Real K = Card(repositories); 
    Real k = 1;
    Text found = "";
  //WriteLn("_trace [GetMinTolVersionForPackage] 3 K="<<K);
    While(And(found=="", k<=K),
    {
    //WriteLn("_trace [GetMinTolVersionForPackage] 4 repositories["<<k+"]="<<repositories[k]);
      Set pkgLst = GetRepositoryInfo(repositories[k]+"?"+_common_php_arguments+
        "&action=versions&limit=1&package="+package);
    //WriteLn("_trace [GetMinTolVersionForPackage] 5 pkgInfo="<<pkgInfo);
    //WriteLn("_trace [GetMinTolVersionForPackage] 6 pkgLst="<<pkgLst);
    //WriteLn("_trace [GetMinTolVersionForPackage] 7 Card(pkgLst)="<<Card(pkgLst));
      Text If(Card(pkgLst)>0, found := pkgLst[1]->te_min_tol_version);
      Real k := k+1
    });
    found
  });
  Real _trace("GetMinTolVersionForPackage", "End", 1);
  found
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetMaxTolVersionForPackage = 
"Devuelve la versión de TOL máxima que requiere un paquete dado"
"Si no se encuentra el paquete se devuelve la cadena vacía.";
Text GetMaxTolVersionForPackage(Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("GetMaxTolVersionForPackage", "Begin", 1);
//WriteLn("_trace [GetMaxTolVersionForPackage] 1 package='"<<package+"'");
  Text found = If(!ChecktolProjectPing(?), "", 
  {
  //WriteLn("_trace [GetMaxTolVersionForPackage] 2");
    Set repositories = 
      TolConfigManager::Config::Upgrading::TolPackage::Repositories;
    Real K = Card(repositories); 
    Real k = 1;
    Text found = "";
  //WriteLn("_trace [GetMaxTolVersionForPackage] 3 K="<<K);
    While(And(found=="", k<=K),
    {
    //WriteLn("_trace [GetMaxTolVersionForPackage] 4 repositories["<<k+"]="<<repositories[k]);
      Set pkgLst = GetRepositoryInfo(repositories[k]+"?"+_common_php_arguments+
        "&action=versions&limit=1&package="+package);
    //WriteLn("_trace [GetMaxTolVersionForPackage] 5 pkgInfo="<<pkgInfo);
    //WriteLn("_trace [GetMaxTolVersionForPackage] 6 pkgLst="<<pkgLst);
    //WriteLn("_trace [GetMaxTolVersionForPackage] 7 Card(pkgLst)="<<Card(pkgLst));
      Text If(Card(pkgLst)>0, found := pkgLst[1]->te_max_tol_version);
      Real k := k+1
    });
    found
  });
  Real _trace("GetMaxTolVersionForPackage", "End", 1);
  found
};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteFindRepository = 
"Devuelve el repositorio al que pertenece un paquete dado de entre aquellos "
"repositorios dados de alta en : \n"
"  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories\n"
"Si no se encuentra el paquete en ninguno de ellos se devuelve la cadena "
"vacía.";
Text RemoteFindRepository(Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("RemoteFindRepository", "Begin", 1);
//WriteLn("_trace [RemoteFindRepository] 1 package='"<<package+"'");
  Text found = If(!ChecktolProjectPing(?), "", 
  {
  //WriteLn("_trace [RemoteFindRepository] 2");
    Set repositories = 
      TolConfigManager::Config::Upgrading::TolPackage::Repositories;
    Real K = Card(repositories); 
    Real k = 1;
    Text found = "";
  //WriteLn("_trace [RemoteFindRepository] 3 K="<<K);
    While(And(found=="", k<=K),
    {
    //WriteLn("_trace [RemoteFindRepository] 4 repositories["<<k+"]="<<repositories[k]);
      Set pkgLst = GetRepositoryInfo(repositories[k]+"?"+_common_php_arguments+
        "&action=versions&limit=1&package="+package);
    //WriteLn("_trace [RemoteFindRepository] 6 pkgLst="<<pkgLst);
    //WriteLn("_trace [RemoteFindRepository] 7 Card(pkgLst)="<<Card(pkgLst));
      Text If(Card(pkgLst)>0, found := repositories[k]);
      Real k := k+1
    });
    found 
  });
  Real _trace("RemoteFindRepository", "Begin", 1);
  found
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteReleaseDate = 
"Devuelve la fecha de la última actualización compatible con la versión "
"actual de TOL de un paquete en un repositorio dado. "
"Si no se especifica ningún repositorio se buscará en todos los "
"repositorios dados de alta en \n"
"  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories\n"
"Si no se encuentra el paquete se devuelve la fecha desconocida.";
Date RemoteReleaseDate(Text repository, Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("RemoteReleaseDate", "Begin", 1);
  Date dte =If(!ChecktolProjectPing(?), UnknownDate, 
  {
    Text rep = If(repository=="",repository,RemoteFindRepository(package));
    If(rep=="", UnknownDate,
    {
      Set pkgLst = GetRepositoryInfo(rep+"?"+_common_php_arguments+
        "&action=versions&limit=1&package="+package);
      If(!Card(pkgLst), TheEnd,
        pkgLst[1]->dh_release_date_remote)
    })
  });
  Real _trace("RemoteReleaseDate", "End", 1);
  dte
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.DownloadPackage = 
"Descarga desde el repositorio remoto al path indicado, un paquete "
"determinado\n";
Real DownloadPackage(
  Text repository, Text package, Real showError, Text localRoot)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("DownloadPackage", "Begin", 1);
  Real ok = If(!ChecktolProjectPing(?), 0, 
  {
    Real OSDirMake(localRoot);
  //WriteLn("_trace [DownloadPackage] 1 repository='"<<repository+"'");
    Real ok = True;
    Text package.orig = package;
    Set pkg.tok = Tokenizer(package,".");
    Real pkg.tok.num = Card(pkg.tok );
    Text package := pkg.tok[1];
    Text package.version = Case(
      pkg.tok.num==3, pkg.tok[1]+"."+pkg.tok[2]+"."+pkg.tok[3], 
      pkg.tok.num==2, pkg.tok[1]+"."+pkg.tok[2], 
      pkg.tok.num==1, pkg.tok[1]); 
    Set pkgLst = GetRepositoryInfo(repository+"?"+_common_php_arguments+
      "&action=versions&limit=1&package="+package.version);
    Real ok := Card(pkgLst);
    Text If(ok,
    {
      Text package.version := pkgLst[1]->co_name_version
    });
    If(!ok, 0, {
  //WriteLn("_trace [DownloadPackage] 2.1 package.orig='"<<package.orig+"'");
  //WriteLn("_trace [DownloadPackage] 2.2 package='"<<package+"'");
  //WriteLn("_trace [DownloadPackage] 2.3 package.version='"<<package.version+"'");

    Text pack = package.version+".zip";
    Text oza = package.version+"/"+package.version+".oza";
    Text localPack = localRoot+"/"+pack;
    Text localOza = localRoot+"/"+oza;
    Text localDir = localRoot+"/"+package.version;

    Text encoded = GetUrlContents(repository+"?"+_common_php_arguments+
      "&action=download"+
      "&format=base64"+
      "&package="+package.version);
  //WriteLn("_trace [DownloadPackage] 3 encoded='"<<encoded+"'");
    Real DecodeBase64ToFile(localPack, encoded);
    If(!FileExist(localPack), False,
    {
    //WriteLn("_trace DownloadPackage 4 UnpackFull("<<localDir+")");
      Real PackArchive::UnpackFull("ZipArchive", localDir, True);
      True
    });
    If(!FileExist(localOza), False,
    {
    //WriteLn("_trace DownloadPackage 5");
      Real RemoteUpdateVersSyncInfo(?);
      True
    })
  })});
  Real _trace("DownloadPackage", "End", 1);
  ok
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteInstallPackage = 
"Instala desde el repositorio remoto al local un paquete determinado "
"para que esté disponible llamando a #Require. \n"
"En un mismo repositorio local puede haber distintas veriones de un mismo "
"paquete que se distinguirán unas de otras por el texto posterior al "
"primer punto. Antes del punto el nombre del paquete suele de seguir la "
"nomenclatura tipo WIKI AaaBbb \n"
"Si no se especifica ninguna versión se instalará la última disponible."
"Si ya existía una copia en el repositorio local será substituida sin "
"mayores contemplaciones por lo que el usuario debe saber lo que pide. \n"
"Sólo es necesario instalar una vez un paquete y todas las sesiones TOL "
"que se lancen desde ese momento podrán usarlos.";
//////////////////////////////////////////////////////////////////////////////
Real RemoteInstallPackage(Text repository, Text package, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
  DownloadPackage( 
    repository, package, showError,
    TolPackage::Client::_.localRoot)
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteInstallFullRepository = 
"Instala la última versión compatible con la versión actual de TOL de todos "
"los paquetes disponibles en un repositorio remoto.\n";
//////////////////////////////////////////////////////////////////////////////
Real RemoteInstallFullRepository(Text repository, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("RemoteInstallFullRepository", "Begin", 1);
  Real ok = If(!ChecktolProjectPing(?), 0, 
  {
    Set pkgLst = GetRepositoryInfo(repository+"?"+_common_php_arguments+
      "&action=versions");
    If(!Card(pkgLst), False,
    SetMin(EvalSet(pkgLst, Real(Set pkg)
    {
      RemoteInstallPackage(repository, pkg->co_name_version, showError)
    })))
  });
  Real _trace("RemoteInstallFullRepository", "End", 1);
  ok
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteInstall = 
"Instala desde el repositorio remoto al local un paquete determinado "
"para que esté disponible llamando a #Require. \n"
"En un mismo repositorio local puede haber distintas veriones de un mismo "
"paquete que se distinguirán unas de otras por el texto posterior al "
"primer punto. Antes del punto el nombre del paquete suele de seguir la "
"nomenclatura tipo WIKI AaaBbb \n"
"Si no se especifica ninguna versión se instalará la última disponible."
"Si no se especifica ningún paquete se instalará la última versión de "
"todos los disponibles en el repositorio.\n"
"Si no se especifica ningún repositorio se buscará en todos los "
"repositorios dados de alta en \n"
"  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories\n"
"Si ya existía una copia en el repositorio local será substituida sin "
"mayores contemplaciones por lo que el usuario debe saber lo que pide. \n"
"Sólo es necesario instalar una vez un paquete y todas las sesiones TOL "
"que se lancen desde ese momento podrán usarlos.";
//////////////////////////////////////////////////////////////////////////////
Real RemoteInstall(Text repository, Text package, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("RemoteInstall", "Begin", 1);
//WriteLn("_trace [RemoteInstall] 1 repository='"<<repository+"'");
//WriteLn("_trace [RemoteInstall] 2 package='"<<package+"'");
  Real ok = If(!ChecktolProjectPing(?), 0, 
  {
    Case(
    And(repository!="",package!=""),
    {
    //WriteLn("_trace [RemoteInstall] 3.1");
      RemoteInstallPackage(repository, package, showError)
    },
    And(repository=="",package!=""),
    {
    //WriteLn("_trace [RemoteInstall] 3.2");
      Text rep = If(repository!="",repository,RemoteFindRepository(package));
    //WriteLn("_trace [RemoteInstall] 3.2.1 rep ="<<rep);
      If(rep=="", 
      {
        If(showError,
        {
          Text minTolVersion = GetMinTolVersionForPackage(package);
          If(minTolVersion=="", 
          Error(I2(
            "Cannot find package "+package+" in any repository for any TOL "
            "version.",
            "No se encuentra el paquete "+package+" en ningún repositorio "
            "para ninguna versión de TOL.")),
          Error(I2(
            "Cannot find package "+package+" in any repository for current "
            "TOL version ",
            "No se encuentra el paquete "+package+" en ningún repositorio "
            "para la versión de TOL en curso ")+TolPackage::_.currentTolVersion+
            ".\n"+I2("You needs to use ", "Es necesario usar ")+minTolVersion))
        })
      },
      {
      //WriteLn("_trace [RemoteInstall] 3.2.2 ");
        RemoteInstallPackage(rep, package, showError)
      })
    },
    And(repository!="",package==""),
    {
    //WriteLn("_trace [RemoteInstall] 3.3");
      RemoteInstallFullRepository(repository, showError)
    },
    And(repository=="",package==""),
    {
    //WriteLn("_trace [RemoteInstall] 3.4");
      Set repositories = 
        TolConfigManager::Config::Upgrading::TolPackage::Repositories;
      SetMin(EvalSet(repositories, Real(Text rep)
      {
        RemoteInstallFullRepository(rep, showError)
      }))
    })
  });
  Real _trace("RemoteInstall", "End", 1);
  ok
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteUpdateVersSyncInfo = 
"Actualiza la información necesaria para la sincronización de versiones de "
"paquetes locales con el repositorio remoto para aquellos que son "
"compatibles con la versión actual de TOL.\n"
"Devuelve el número de versiones de paquetes compatibles disponibles de "
"forma remota.";
Real RemoteUpdateVersSyncInfo(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("RemoteUpdateVersSyncInfo", "Begin", 1);
  Real ok = If(!ChecktolProjectPing(?), 0, 
  {
    Set repositories = 
      TolConfigManager::Config::Upgrading::TolPackage::Repositories;
    Set _.versSyncInfo := SetConcat(EvalSet(repositories,Set(Text rep)
    {
      GetRepositoryInfo(rep+"?"+_common_php_arguments+"&action=versions")
    }));
    Real SetIndexByName(_.versSyncInfo);
    Set pkgLst = GetDir(TolPackage::Client::_.localRoot)[2];
    Set EvalSet(pkgLst, Real(Text pkg)
    {
      Real found = FindIndexByName(_.versSyncInfo, pkg);
      Date If(!found, WriteLn("[RemoteUpdateVersSyncInfo] "+I2(
        "Cannot find remote image of local package "+pkg+
        " in any repository." ,
        "No se encuentra la imagen remota del paquete local "+pkg+
        " en ningún repositorio"),"W"),
      {
        Date gmt = Copy(NowGmt);
        Date loc = Copy(Now);
        Real lag = Round(DateDif(S(0),loc,gmt)/10)*10;
        Text oza = TolPackage::Client::_.localRoot+pkg+"/"+pkg+".oza";
        Date release.loc = FileTime(oza);
        Date release.gmt = Succ(release.loc,S(0),lag);
        _.versSyncInfo[found]->dh_release_date_local := release.gmt
      });
      True
    });
    Real Ois.Store(_.versSyncInfo,_.localRoot+"/VersSyncInfo.oza");
    Card(_.versSyncInfo)
  });
  Real _trace("RemoteUpdateVersSyncInfo", "End", 1);
  ok
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteUpdatePackSyncInfo = 
"Actualiza la información necesaria para la sincronización de paquetes "
"locales con el repositorio remoto para aquellos que son "
"compatibles con la versión actual de TOL.\n"
"Devuelve el número de paquetes compatibles disponibles de forma remota.";
Real RemoteUpdatePackSyncInfo(Real showWarnings)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("RemoteUpdateVersSyncInfo", "Begin", 1);
  Text _MID = "[RemoteUpdatePackSyncInfo] ";
  Real ok = If(!ChecktolProjectPing(?), 0, 
  {
    Set repositories = 
      TolConfigManager::Config::Upgrading::TolPackage::Repositories;
    Set _.packSyncInfo := SetConcat(EvalSet(repositories,Set ev.rep(Text rep)
    {
      GetRepositoryInfo(rep+"?"+_common_php_arguments+"&action=packages")
    }));
    Real SetIndexByName(_.packSyncInfo);
    Set verLst = GetDir(TolPackage::Client::_.localRoot)[2];
    Set verCls = Classify(verLst,Real ev.class(Text a, Text b)
    {
      Compare(Tokenizer(a,".")[1], Tokenizer(b,".")[1])
    });
    Set EvalSet(verCls, Real ev.check(Set cls)
    {
      Text pkg = Tokenizer(cls[1],".")[1];
      Real found = FindIndexByName(_.packSyncInfo, pkg);
      Real If(!found, 
      {
        If(showWarnings,
          WriteLn(_MID+I2(
          "Cannot find remote image of local package "+pkg+
          " in any repository." ,
          "No se encuentra la imagen remota del paquete local "+pkg+
          " en ningún repositorio"),"W"));
        False
      },
      {
        Set ord = Sort(cls,Real ev.sort(Text a, Text b) { 
          Compare.VersionString(b, a) });
        Text ver = ord[1];
        Date gmt = Copy(NowGmt);
        Date loc = Copy(Now);
        Real lag = Round(DateDif(S(0),loc,gmt)/10)*10;
        Text oza = TolPackage::Client::_.localRoot+ver+"/"+ver+".oza";
        Date release.loc = FileTime(oza);
        Date release.gmt = Succ(release.loc,S(0),lag);
        Date _.packSyncInfo[found]->co_last_version_local := ver;
        Date _.packSyncInfo[found]->dh_release_date_local := release.gmt;
        True
      });
      True
    });
    Set _.packForUpdate := Select(_.packSyncInfo, Real(TolPackage::@PackageSynchro pkg)
    {
      Real need = And(pkg->co_last_version_local != "",
          pkg->co_last_version_local == pkg->co_last_version_remote,  
          pkg->dh_release_date_local <  pkg->dh_release_date_remote);
      If(And(showWarnings,need),
      {
        WriteLn("  Local package "<<pkg->co_last_version_local+
                " created at "<<pkg->dh_release_date_local+
                " could be updated to newer remote patch since "<<pkg->dh_release_date_remote)
      });
      need
    });
    If(And(showWarnings,Card(_.packForUpdate)),
    {
      WriteLn(_MID+"There are "<<Card(_.packForUpdate)+" packages that you could update "
              "from remote repositories to new patches of the same version.\n"
              "You can view them at:\n "
              "  Set TolPackage::Client::_.packForUpdate\n"
              "You could update all them running this TOL sentence: \n"
              "  Real TolPackage::Client::RemoteUpdateAll(0)\n",
              "W")
    });
    Set _.packForUpgrade := Select(_.packSyncInfo, Real(TolPackage::@PackageSynchro pkg)
    {
      Real need = And(pkg->co_last_version_local != "",
          Compare.VersionString(pkg->co_last_version_local,pkg->co_last_version_remote)<0);
      If(And(showWarnings,need),
      {
        WriteLn("  Local package "<<pkg->co_last_version_local+
                " could be upgraded to "<<pkg->co_last_version_remote)
      });
      need
    });
    If(And(showWarnings,Card(_.packForUpgrade)),
    {
      WriteLn(_MID+"There are "<<Card(_.packForUpgrade)+" packages that you could upgrade "
              "from remote repositories to new versions.\n"
              "You can view them at:\n "
              "  Set TolPackage::Client::_.packForUpgrade\n"
              "You can upgrade all them running this TOL sentence: \n"
              "  Real TolPackage::Client::RemoteUpgradeAll(0)\n",
              "W")
    });
    Set _.packForInstall := Select(_.packSyncInfo, Real(TolPackage::@PackageSynchro pkg)
    {
      pkg->co_last_version_local == ""  
    });
    Set _.packInstalled := Select(_.packSyncInfo, Real(TolPackage::@PackageSynchro pkg)
    {
      pkg->co_last_version_local != ""  
    });
    Real Ois.Store(_.packSyncInfo,_.localRoot+"/PackSyncInfo.oza");
    Card(_.packSyncInfo)
  });
  Real _trace("RemoteUpdateVersSyncInfo", "End", 1);
  ok
};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteUpdateAll = 
"Actualiza automáticamente todos los paquetes disponibles desde los "
"repositorios remotos para los que la copia local haya caducado.\n";
Real RemoteUpdateAll(Real updateSyncInfo)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("RemoteUpdateAll", "Begin", 1);
  Real If(Or(updateSyncInfo,!Card(_.packSyncInfo)), 
    RemoteUpdatePackSyncInfo(False));
  Real ok = If(!Card(_.packForUpdate), 0,
  SetSum(EvalSet(_.packForUpdate, Real(TolPackage::@PackageSynchro pkg)
  {
    RemoteInstallPackage(pkg->te_url, pkg->co_last_version_local, True)
  })));
  Real _trace("RemoteUpdateAll", "End", 1);
  ok
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteUpgradeAll = 
"Actualiza automáticamente todos los paquetes disponibles desde los "
"repositorios remotos para los que exista una versión más moderna.\n";
Real RemoteUpgradeAll(Real updateSyncInfo)
//////////////////////////////////////////////////////////////////////////////
{
  Real _trace("RemoteUpgradeAll", "Begin", 1);
  Real If(Or(updateSyncInfo,!Card(_.packSyncInfo)), 
    RemoteUpdatePackSyncInfo(False));
  Real ok = If(!Card(_.packForUpgrade), 0,
  SetSum(EvalSet(_.packForUpgrade, Real(TolPackage::@PackageSynchro pkg)
  {
    RemoteInstallPackage(pkg->te_url, pkg->co_last_version_remote, True)
  })));
  Real _trace("RemoteUpgradeAll", "End", 1);
  ok
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetCompatibleVersion.one = 
"Gets the latest version of a package that is compatible with a tol version.";
Text GetCompatibleVersion.one(Text tol_version, Text package)
////////////////////////////////////////////////////////////////////////////////
{
  Real _trace("GetCompatibleVersion.one", "Begin", 1);
  Real If(!Card(_.versSyncInfo), 
   TolPackage::Client::RemoteUpdateVersSyncInfo(True));
  
  Set sel_compatible = Select(_.versSyncInfo, 
  Real(TolPackage::@VersionSynchro reg)
  {
    And(TextBeginWith(reg->co_name_version,package), 
        tol_version>=reg->te_min_tol_version, 
        tol_version<=reg->te_max_tol_version)
  });
  If(!Card(sel_compatible),
  {
    WriteLn("[GetCompatibleVersion.one] Cannot find a version of package "<<
    package+" compatible with TOL "+tol_version,"E");
    Real Stop;
    ""
  },
  {
    Set last_compatible = Sort(sel_compatible, 
    Real(TolPackage::@VersionSynchro a, TolPackage::@VersionSynchro b)
    {
      Compare.VersionString(b->co_name_version,a->co_name_version)
    })[1];
    Real _trace("GetCompatibleVersion.one", "End", 1);
    last_compatible->co_name_version
  })
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetCompatibleVersion.all = 
"Gets the latest versions of a set of packages that are compatible with a tol "
"version.";
Set GetCompatibleVersion.all(Text tol_version, Set package.list)
////////////////////////////////////////////////////////////////////////////////
{
  EvalSet(package.list, Text (Text pv) 
  {
    GetCompatibleVersion.one(tol_version, pv)
  })
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetDeepDependencies.one = 
"Gets the list of deep depencies of a given version of a package";
Set GetDeepDependencies.one(Text package.version)
////////////////////////////////////////////////////////////////////////////////
{
  Real _trace("GetDeepDependencies.one("+package.version+")", "Begin", 1);
  Real If(!Card(_.versSyncInfo), 
   TolPackage::Client::RemoteUpdateVersSyncInfo(True));
  Set sel = Select(_.versSyncInfo, Real(TolPackage::@VersionSynchro reg)
  {
    reg->co_name_version == package.version
  });
  Set s = If(!Card(sel), sel,
  {
    Text depExpr = sel[1]->te_dependencies;
    Set dep = If(depExpr=="",Copy(Empty),
    {
      Tokenizer(depExpr,",")
    });
    Unique(SetConcat(EvalSet(dep,GetDeepDependencies.one))<<[[ sel[1]->co_name_version ]])
  });
  Real _trace("GetDeepDependencies.one", "End", 1);
  s
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetDeepDependencies.all = 
"Gets the list of deep depencies of a list of versions of packages";
Set GetDeepDependencies.all(Set package.version.list)
////////////////////////////////////////////////////////////////////////////////
{
  Real _trace("GetDeepDependencies.all", "Begin", 1);
  Set tab = EvalSet(package.version.list, GetDeepDependencies.one);
  Set uni = Unique(SetConcat(tab));
  Real _trace("GetDeepDependencies.all", "End", 1);
  uni
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetVersionInfo = 
"Gets the TolPackage::@VersionSynchro related to a version of a package";
Set GetVersionInfo(Set package.version.list)
////////////////////////////////////////////////////////////////////////////////
{
  Real _trace("GetVersionInfo", "Begin", 1);
  Real If(!Card(_.versSyncInfo), 
   TolPackage::Client::RemoteUpdateVersSyncInfo(True));
  Set s = EvalSet(package.version.list, TolPackage::@VersionSynchro(Text pv)
  {
    _.versSyncInfo[pv]
  });
  Real _trace("GetVersionInfo", "End", 1);
  s
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetCompatibleDeepDependencies = 
"Gets the TolPackage::@VersionSynchro related to all deep dependencies of a "
"list of packages for the last version that is compatible with a tol version";
Set GetCompatibleDeepDependencies(Text tol_version, Set package.list)
////////////////////////////////////////////////////////////////////////////////
{
  Real _trace("GetCompatibleDeepDependencies", "Begin", 1);
  Set package.version.list = GetCompatibleVersion.all(tol_version, package.list);
  Set dep = GetVersionInfo(GetDeepDependencies.all(package.version.list));
  Real _trace("GetCompatibleDeepDependencies", "End", 2);
  dep
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.DownloadCompatibleDeepDependencies = 
"Downloads to a local directory all deep dependencies of a list of packages "
"for the last version that is compatible with a tol version.\n"
"Arguments : \n"
"  Text localRoot      : Local directory where packages will be downloaded\n"
"  Real cleanLocalRoot : If true, local directory will be cleaned before to download\n"
"  Text tol_version    : Version of TOL comaptible with all packages\n"
"  Set package.list    : List of packages without explicit version\n"
"Returns true if all packages are found and downloaded.";
Real DownloadCompatibleDeepDependencies(
  Text localRoot,
  Real cleanLocalRoot,    
  Text tol_version,  
  Set package.list)
////////////////////////////////////////////////////////////////////////////////
{
  Real _trace("DownloadCompatibleDeepDependencies", "Begin", 1);
  If(Compare.VersionString(tol_version,TolPackage::_.currentTolVersion)>0,
  {
    WriteLn("[DownloadCompatibleDeepDependencies] Cannot download packages for "
    "TOL "+tol_version+" using TOL "+TolPackage::_.currentTolVersion,"E");
    False
  },
  {
    Real If(cleanLocalRoot, OSDirRemove(localRoot));
    Set dep = GetCompatibleDeepDependencies(tol_version, package.list);
    Real ok = SetMin(EvalSet(dep, Real(TolPackage::@VersionSynchro vsi)
    {
      DownloadPackage(vsi->te_url,vsi->co_name_version,True,localRoot)
    }));
    Real _trace("DownloadCompatibleDeepDependencies", "End", 1);
    ok
  })
};

////////////////////////////////////////////////////////////////////////////////
  Text CppTools.Path(NameBlock package)
////////////////////////////////////////////////////////////////////////////////
{
  Text packageName = package::_.autodoc.name;
  Text dllPath.rel = GetAbsolutePath("CppTools/"+ GetHardSoftPlattform(0));
  Text dllPath.deb = dllPath.rel+"_dbg";
  Text dllFile.rel = dllPath.rel+"/"+packageName+"."+GetSharedLibExt(0);
  Text dllFile.deb = dllPath.deb+"/"+packageName+"."+GetSharedLibExt(0);
  If(!TextEndAt(Version,"{DEBUG}"),dllFile.rel,
  {
    If(OSDirExist(dllFile.deb),dllFile.deb,
    {
      WriteLn("Cannot find debug library "+dllFile.deb+
              ".\n Trying to load "+dllFile.rel,"W");
      dllFile.rel
    })
  })
};

////////////////////////////////////////////////////////////////////////////////
  Real CppTools.Check(NameBlock package, Text dllFile, Text chechMethod)
////////////////////////////////////////////////////////////////////////////////
{
  Text packageName = package::_.autodoc.name;
  Real ok = ObjectExist("Code","package::CppTools::"+chechMethod);
  WriteLn("["+packageName+"] Loading library "+dllFile+
          " -> "<<If(ok,"OK","FAIL"),If(ok,"S","E"));
  ok
}


]];



