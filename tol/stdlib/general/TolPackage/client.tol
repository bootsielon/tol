/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : client.tol
// PURPOSE: TolPackage client tools
//////////////////////////////////////////////////////////////////////////////

Text _.autodoc.member.Client= 
"Sistema cliente de gestión de paquetes TOL";

//////////////////////////////////////////////////////////////////////////////
NameBlock Client = [[
//////////////////////////////////////////////////////////////////////////////

Text _.localRoot = 
  Replace(TolAppDataPath+"TolPackage/Client/","\\","/");

Set _.versSyncInfo = Copy(Empty);
//Listado de todos los paquetes disponibles
Set _.packSyncInfo = Copy(Empty);
//Paquetes para los que la versión remota es más moderna
Set _.packForUpdate = Copy(Empty);
//Paquetes para los que hay versiones remotas ulteriores
Set _.packForUpgrade = Copy(Empty);
//Paquetes no instalados
Set _.packForInstall = Copy(Empty);
//Paquetes ya instalados
Set _.packInstalled = Copy(Empty);

Text min_tol_version_cond = 
  "min_tol_version="+Replace(TolPackage::_.currentTolVersion," ","%20");

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Initialize = 
"Inicializa el cliente del servicio de paquetes TOL";
Real Initialize(Real void)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE [TolPackage::Client::Initialize] ");
  Real OSDirMake(_.localRoot);
  True
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.AddRepository = 
"Añade un repositorio a la lista de configuración del usuario:\n"
"  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories\n";
Real AddRepository(Text url)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE [TolPackage::Client::Initialize] ");
  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories :=
    Unique(TolConfigManager::Config::Upgrading::TolPackage::Repositories <<
           [[url]]);
  Real TolConfigManager::SaveConfig(TolConfigManager::Config);
  True
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetRequirements= 
"Crea un texto con los #Require para una lista de paquetes";
Text GetRequirements(Set packages)
//////////////////////////////////////////////////////////////////////////////
{
  SetSum(EvalSet(packages,Text(Text required)
  {
    "#Require "+required+";\n"
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.DoRequirements= 
"Llama a #Require para una lista de paquetes";
Real DoRequirements(Set packages)
//////////////////////////////////////////////////////////////////////////////
{
  Set EvalSet(packages,Real(Text required)
  {
    Set IncludeText("#Require "+required+";\nReal True;");
    True
  });
  True
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalLastCompatible = 
"Devuelve la última versión de un paquete disponible localmente que es "
"compatible con la versión actual de TOL.";
Text LocalLastCompatible(Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Set pkgLst = GetDir(TolPackage::Client::_.localRoot)[2];
  Set pkgSel = Select(pkgLst,Real(Text pkgNamVer)
  {
    TextBeginWith( pkgNamVer, package+".")
  });
  Text If(!Card(pkgSel),"",
  {
    Set pkgSort = Sort(pkgSel, Real(Text a, Text b) { Compare(b, a) });
    pkgSort[1]
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalPath = 
"Devuelve el path completo del fichero local correspondiente a un paquete "
"comprimido.";
Text LocalPath(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  TolPackage::Client::_.localRoot+package.version+"/"+package.version+".zip"
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalOza = 
"Devuelve el path completo del fichero local OIS correspondiente a un "
"paquete.";
Text LocalOza(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  TolPackage::Client::_.localRoot+package.version+"/"+package.version+".oza"
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalResourcePath = 
"Devuelve el path completo del directorio local de un recurso ajeno a TOL "
"necesario para el paquete especificado.";
Text LocalResourcePath(Text package.version, Text resource)
//////////////////////////////////////////////////////////////////////////////
{
  TolPackage::Client::_.localRoot+package.version+"/"+resource
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalInstallPackage = 
"Instala un paquete desde el archivo local comprimido dado por el "
"argumento:\n"
"  Text pkg.path.zip = \"<directory>/<name>.<high>.<low>.zip\"\n";
Real LocalInstallPackage(Text pkg.path.zip)
//////////////////////////////////////////////////////////////////////////////
{
  Real OSFilCopy(pkg.path.zip, _.localRoot);
  Text pkg.name.zip = GetFileName(pkg.path.zip);
  Text pkg.name = Replace(pkg.name.zip,".zip","");
  Real PackArchive::UnpackFull("ZipArchive",_.localRoot+pkg.name);
  Real OSFilRemove(_.localRoot+pkg.name.zip);
  FileExist(_.localRoot+pkg.name+"/"+pkg.name+".oza")
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalClean = 
"Elimina un paquete local concreto.\n"
"Si no se especifica número de versión se borrarán todas las versiones "
"locales de dicho paquete.";
Real LocalClean(Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Real If(TextFind(package,"."),
  {
    Real OSDirRemove(_.localRoot+package)
  },
  {
    Set dir = GetDir(_.localRoot)[2];
    Set sel = Select(dir,Real(Text sub)
    {
      TextBeginWith(sub,package)
    });
    SetMin(EvalSet(sel,Real(Text pkg)
    {
      OSDirRemove(_.localRoot+pkg)
    }))
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalClean.All = 
"Elimina todos los paquetes disponibles localmente.";
Real LocalCleanAll(Text repository)
//////////////////////////////////////////////////////////////////////////////
{
  Real OSDirRemove(_.localRoot);
  Real OSDirMake(_.localRoot)
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteFindRepository = 
"Devuelve el repositorio al que pertenece un paquete dado de entre aquellos "
"repositorios dados de alta en : \n"
"  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories\n"
"Si no se encuentra el paquete en ninguno de ellos se devuelve la cadena "
"vacía.";
Text RemoteFindRepository(Text package)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE [RemoteFindRepository] 1 package='"<<package+"'");
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, "", {
//WriteLn("TRACE [RemoteFindRepository] 2");
  Set repositories = 
    TolConfigManager::Config::Upgrading::TolPackage::Repositories;
  Real K = Card(repositories); 
  Real k = 1;
  Text found = "";
//WriteLn("TRACE [RemoteFindRepository] 3 K="<<K);
  While(And(found=="", k<=K),
  {
  //WriteLn("TRACE [RemoteFindRepository] 4 repositories["<<k+"]="<<repositories[k]);
    Text pkgInfo = GetUrlContents(repositories[k]+"?"
      "action=versions&limit=1&"+
      "package="+package+"&"+
      min_tol_version_cond);
    Set pkgLst = IncludeText(pkgInfo);
  //WriteLn("TRACE [RemoteFindRepository] 5 pkgInfo="<<pkgInfo);
  //WriteLn("TRACE [RemoteFindRepository] 6 pkgLst="<<pkgLst);
  //WriteLn("TRACE [RemoteFindRepository] 7 Card(pkgLst)="<<Card(pkgLst));
    Text If(Card(pkgLst)>0, found := repositories[k]);
    Real k := k+1
  });
  found
})};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteReleaseDate = 
"Devuelve la fecha de la última actualización compatible con la versión "
"actual de TOL de un paquete en un repositorio dado. "
"Si no se especifica ningún repositorio se buscará en todos los "
"repositorios dados de alta en \n"
"  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories\n"
"Si no se encuentra el paquete se devuelve la fecha desconocida.";
Date RemoteReleaseDate(Text repository, Text package)
//////////////////////////////////////////////////////////////////////////////
{
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, UnknownDate, {
  Text rep = If(repository=="",repository,RemoteFindRepository(package));
  If(rep=="", UnknownDate,
  {
    Text pkgInfo = GetUrlContents(rep+"?"
      "action=versions&limit=1&"+
      "package="+package+"&"+
      min_tol_version_cond);
    Set pkgLst = IncludeText(pkgInfo);
    pkgLst[1]->dh_release_date_remote
  })
})};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteInstallPackage = 
"Instala desde el repositorio remoto al local un paquete determinado "
"para que esté disponible llamando a #Require. \n"
"En un mismo repositorio local puede haber distintas veriones de un mismo "
"paquete que se distinguirán unas de otras por el texto posterior al "
"primer punto. Antes del punto el nombre del paquete suele de seguir la "
"nomenclatura tipo WIKI AaaBbb \n"
"Si no se especifica ninguna versión se instalará la última disponible."
"Si ya existía una copia en el repositorio local será substituida sin "
"mayores contemplaciones por lo que el usuario debe saber lo que pide. \n"
"Sólo es necesario instalar una vez un paquete y todas las sesiones TOL "
"que se lancen desde ese momento podrán usarlos.";
//////////////////////////////////////////////////////////////////////////////
Real RemoteInstallPackage(Text repository, Text package, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, 0, {
//WriteLn("TRACE [RemoteInstallPackage] 1 repository='"<<repository+"'");
  Text package.version = package;
  Text If(TextFind(package,"."),
  {
    Text package := Tokenizer(package.version,".")[1]
  },
  {
    Text pkgInfo = GetUrlContents(repository+"?"
      "action=versions&limit=1&"+
      "package="+package+"&"+
      min_tol_version_cond);
    Set pkgLst = IncludeText(pkgInfo);
    Text package.version := pkgLst[1]->co_name_version
  });

//WriteLn("TRACE [RemoteInstallPackage] 2 package='"<<package+"'");
//WriteLn("TRACE [RemoteInstallPackage] 3 package.version='"<<package.version+"'");

  Text pack = package.version+".zip";
  Text oza = package.version+"/"+package.version+".oza";
  Text localPack = TolPackage::Client::_.localRoot+pack;
  Text localOza = TolPackage::Client::_.localRoot+oza;
  Text localDir = TolPackage::Client::_.localRoot+package.version;

  Text encoded = GetUrlContents(repository+"?"
    "action=download&"+
    "format=base64&"+
    "package="+package.version);
//WriteLn("TRACE [RemoteInstallPackage] 4 encoded='"<<encoded+"'");
  Real DecodeBase64ToFile(localPack, encoded);
  If(!FileExist(localPack), False,
  {
  //WriteLn("TRACE DownloadPackage 4 UnpackFull("<<localDir+")");
    Real PackArchive::UnpackFull("ZipArchive", localDir);
    Real OSFilRemove(localPack);
    True
  });
//WriteLn("TRACE DownloadPackage 5");
  FileExist(localOza)  
})};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteInstallFullRepository = 
"Instala la última versión compatible con la versión actual de TOL de todos "
"los paquetes disponibles en un repositorio remoto.\n";
//////////////////////////////////////////////////////////////////////////////
Real RemoteInstallFullRepository(Text repository, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, 0, {
  Text pkgInfo = GetUrlContents(repository+"?"
    "action=versions&"+
    min_tol_version_cond);
  Set pkgLst = IncludeText(pkgInfo);
  SetMin(EvalSet(pkgLst, Real(Set pkg)
  {
    RemoteInstallPackage(repository, pkg->co_name_version, showError)
  }))
})};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteInstall = 
"Instala desde el repositorio remoto al local un paquete determinado "
"para que esté disponible llamando a #Require. \n"
"En un mismo repositorio local puede haber distintas veriones de un mismo "
"paquete que se distinguirán unas de otras por el texto posterior al "
"primer punto. Antes del punto el nombre del paquete suele de seguir la "
"nomenclatura tipo WIKI AaaBbb \n"
"Si no se especifica ninguna versión se instalará la última disponible."
"Si no se especifica ningún paquete se instalará la última versión de "
"todos los disponibles en el repositorio.\n"
"Si no se especifica ningún repositorio se buscará en todos los "
"repositorios dados de alta en \n"
"  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories\n"
"Si ya existía una copia en el repositorio local será substituida sin "
"mayores contemplaciones por lo que el usuario debe saber lo que pide. \n"
"Sólo es necesario instalar una vez un paquete y todas las sesiones TOL "
"que se lancen desde ese momento podrán usarlos.";
//////////////////////////////////////////////////////////////////////////////
Real RemoteInstall(Text repository, Text package, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE [RemoteInstall] 1 repository='"<<repository+"'");
//WriteLn("TRACE [RemoteInstall] 2 package='"<<package+"'");
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, 0, {
  Case(
  And(repository!="",package!=""),
  {
  //WriteLn("TRACE [RemoteInstall] 3.1");
    RemoteInstallPackage(repository, package, showError)
  },
  And(repository=="",package!=""),
  {
  //WriteLn("TRACE [RemoteInstall] 3.2");
    Text rep = If(repository!="",repository,RemoteFindRepository(package));
  //WriteLn("TRACE [RemoteInstall] 3.2.1 rep ="<<rep);
    If(rep=="", 
    {
      If(showError,Error(I2(
       "Cannot find package "+package+" in any repository",
       "No se encuentra el paquete "+package+" en ningún repositorio")))
    },
    {
    //WriteLn("TRACE [RemoteInstall] 3.2.2 ");
      RemoteInstallPackage(rep, package, showError)
    })
  },
  And(repository!="",package==""),
  {
  //WriteLn("TRACE [RemoteInstall] 3.3");
    RemoteInstallFullRepository(repository, showError)
  },
  And(repository=="",package==""),
  {
  //WriteLn("TRACE [RemoteInstall] 3.4");
    Set repositories = 
      TolConfigManager::Config::Upgrading::TolPackage::Repositories;
    SetMin(EvalSet(repositories, Real(Text rep)
    {
      RemoteInstallFullRepository(rep, showError)
    }))
  })
})};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteUpdateVersSyncInfo = 
"Actualiza la información necesaria para la sincronización de versiones de "
"paquetes locales con el repositorio remoto para aquellos que son "
"compatibles con la versión actual de TOL.\n"
"Devuelve el número de versiones de paquetes compatibles disponibles de "
"forma remota.";
Real RemoteUpdateVersSyncInfo(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, 0, {
  Set repositories = 
    TolConfigManager::Config::Upgrading::TolPackage::Repositories;
  Set _.versSyncInfo := SetConcat(EvalSet(repositories,Set(Text rep)
  {
    Text pkgInfo = GetUrlContents(rep+"?"
      "action=versions&"+
      min_tol_version_cond);
    IncludeText(pkgInfo)
  }));
  Real SetIndexByName(_.versSyncInfo);
  Set pkgLst = GetDir(TolPackage::Client::_.localRoot)[2];
  Set EvalSet(pkgLst, Real(Text pkg)
  {
    Real found = FindIndexByName(_.versSyncInfo, pkg);
    Date If(!found, WriteLn("[RemoteUpdateVersSyncInfo] "+I2(
      "Cannot find remote image of local package "+pkg+
      " in any repository." ,
      "No se encuentra la imagen remota del paquete local "+pkg+
      " en ningún repositorio"),"W"),
    {
      Date gmt = Copy(NowGmt);
      Date loc = Copy(Now);
      Real lag = Round(DateDif(S(0),loc,gmt)/10)*10;
      Text oza = TolPackage::Client::_.localRoot+pkg+"/"+pkg+".oza";
      Date release.loc = FileTime(oza);
      Date release.gmt = Succ(release.loc,S(0),lag);
      _.versSyncInfo[found]->dh_release_date_local := release.gmt
    });
    True
  });
  Card(_.versSyncInfo)
})};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteUpdatePackSyncInfo = 
"Actualiza la información necesaria para la sincronización de paquetes "
"locales con el repositorio remoto para aquellos que son "
"compatibles con la versión actual de TOL.\n"
"Devuelve el número de paquetes compatibles disponibles de forma remota.";
Real RemoteUpdatePackSyncInfo(Real showWarnings)
//////////////////////////////////////////////////////////////////////////////
{
  Text _MID = "TolPackage::Client::[RemoteUpdatePackSyncInfo] ";
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, 0, {
  Set repositories = 
    TolConfigManager::Config::Upgrading::TolPackage::Repositories;
  Set _.packSyncInfo := SetConcat(EvalSet(repositories,Set ev.rep(Text rep)
  {
    Text pkgInfo = GetUrlContents(rep+"?"
      "action=packages&"+
      min_tol_version_cond);
    IncludeText(pkgInfo)
  }));
  Real SetIndexByName(_.packSyncInfo);
  Set verLst = GetDir(TolPackage::Client::_.localRoot)[2];
  Set verCls = Classify(verLst,Real ev.class(Text a, Text b)
  {
    Compare(Tokenizer(a,".")[1], Tokenizer(b,".")[1])
  });
  Set EvalSet(verCls, Real ev.check(Set cls)
  {
    Text pkg = Tokenizer(cls[1],".")[1];
    Real found = FindIndexByName(_.packSyncInfo, pkg);
    Real If(!found, 
    {
      If(showWarnings,
        WriteLn(_MID+I2(
        "Cannot find remote image of local package "+pkg+
        " in any repository." ,
        "No se encuentra la imagen remota del paquete local "+pkg+
        " en ningún repositorio"),"W"));
      False
    },
    {
      Set ord = Sort(cls,Real ev.sort(Text a, Text b) { Compare(b, a) });
      Text ver = ord[1];
      Date gmt = Copy(NowGmt);
      Date loc = Copy(Now);
      Real lag = Round(DateDif(S(0),loc,gmt)/10)*10;
      Text oza = TolPackage::Client::_.localRoot+ver+"/"+ver+".oza";
      Date release.loc = FileTime(oza);
      Date release.gmt = Succ(release.loc,S(0),lag);
      Date _.packSyncInfo[found]->co_last_version_local := ver;
      Date _.packSyncInfo[found]->dh_release_date_local := release.gmt;
      True
    });
    True
  });
  Set _.packForUpdate := Select(_.packSyncInfo, Real(TolPackage::@PackageSynchro pkg)
  {
    Real need = And(pkg->co_last_version_local != "",
        pkg->co_last_version_local == pkg->co_last_version_remote,  
        pkg->dh_release_date_local <  pkg->dh_release_date_remote);
    If(And(showWarnings,need),
    {
      WriteLn("  Local package "<<pkg->co_last_version_local+
              " created at "<<pkg->dh_release_date_local+
              " could be updated to newer remote patch since "<<pkg->dh_release_date_remote)
    });
    need
  });
  If(And(showWarnings,Card(_.packForUpdate)),
  {
    WriteLn(_MID+"There are "<<Card(_.packForUpdate)+" packages that you could update "
            "from remote repositories to new patches of the same version.\n"
            "You can view them at:\n "
            "  Set TolPackage::Client::_.packForUpdate\n"
            "You could update all them running this TOL sentence: \n"
            "  Set TolPackage::Client::RemoteUpdateAll(0)\n",
            "W")
  });
  Set _.packForUpgrade := Select(_.packSyncInfo, Real(TolPackage::@PackageSynchro pkg)
  {
    Real need = And(pkg->co_last_version_local != "",
        pkg->co_last_version_local < pkg->co_last_version_remote);
    If(And(showWarnings,need),
    {
      WriteLn("  Local package "<<pkg->co_last_version_local+
              " could be upgraded to "<<pkg->co_last_version_remote)
    });
    need
  });
  If(And(showWarnings,Card(_.packForUpgrade)),
  {
    WriteLn(_MID+"There are "<<Card(_.packForUpgrade)+" packages that you could upgrade "
            "from remote repositories to new versions.\n"
            "You can view them at:\n "
            "  Set TolPackage::Client::_.packForUpgrade\n"
            "You can upgrade all them running this TOL sentence: \n"
            "  Set TolPackage::Client::RemoteUpgradeAll(0)\n",
            "W")
  });
  Set _.packForInstall := Select(_.packSyncInfo, Real(TolPackage::@PackageSynchro pkg)
  {
    pkg->co_last_version_local == ""  
  });
  Set _.packInstalled := Select(_.packSyncInfo, Real(TolPackage::@PackageSynchro pkg)
  {
    pkg->co_last_version_local != ""  
  });
  Card(_.packSyncInfo)
})};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteUpdateAll = 
"Actualiza automáticamente todos los paquetes disponibles desde los "
"repositorios remotos para los que la copia local haya caducado.\n";
Real RemoteUpdateAll(Real updateSyncInfo)
//////////////////////////////////////////////////////////////////////////////
{
  Real If(Or(updateSyncInfo,Card(_.packSyncInfo)), 
    RemoteUpdatePackSyncInfo(False));
  If(!Card(_.packForUpdate), 0,
  SetSum(EvalSet(_.packForUpdate, Real(TolPackage::@PackageSynchro pkg)
  {
    RemoteInstallPackage(pkg->te_url, pkg->co_last_version_remote, True)
  })))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteUpgradeAll = 
"Actualiza automáticamente todos los paquetes disponibles desde los "
"repositorios remotos para los que exista una versión más moderna.\n";
Real RemoteUpgradeAll(Real updateSyncInfo)
//////////////////////////////////////////////////////////////////////////////
{
  Real If(Or(updateSyncInfo,Card(_.packSyncInfo)), 
    RemoteUpdatePackSyncInfo(False));
  If(!Card(_.packForUpgrade), 0,
  SetSum(EvalSet(_.packForUpgrade, Real(TolPackage::@PackageSynchro pkg)
  {
    RemoteInstallPackage(pkg->te_url, pkg->co_last_version_remote, True)
  })))
}

]];


