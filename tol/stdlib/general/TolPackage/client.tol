/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : client.tol
// PURPOSE: TolPackage client tools
//////////////////////////////////////////////////////////////////////////////

Text _.autodoc.member.Client= 
"Sistema cliente de gestión de paquetes TOL";

//////////////////////////////////////////////////////////////////////////////
NameBlock Client = [[
//////////////////////////////////////////////////////////////////////////////

Text _.localRoot = 
  Replace(TolAppDataPath+"TolPackage/Client/","\\","/");

Set _.versSyncInfo = Copy(Empty);
//Listado de todos los paquetes disponibles
Set _.packSyncInfo = Copy(Empty);
//Paquetes para los que la versión remota es más moderna
Set _.packForUpdate = Copy(Empty);
//Paquetes para los que hay versiones remotas ulteriores
Set _.packForUpgrade = Copy(Empty);
//Paquetes no instalados
Set _.packForInstall = Copy(Empty);
//Paquetes ya instalados
Set _.packInstalled = Copy(Empty);

Text min_tol_version_cond = "";

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Initialize = 
"Inicializa el cliente del servicio de paquetes TOL";
Real Initialize(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  Real TolPackage::Initialize(void);
  Text min_tol_version_cond := 
    "min_tol_version="+Replace(TolPackage::_.currentTolVersion," ","%20");
  Real OSDirMake(_.localRoot);
  True
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.AddRepository = 
"Añade un repositorio a la lista de configuración del usuario:\n"
"  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories\n";
Real AddRepository(Text url)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE [TolPackage::Client::Initialize] ");
  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories :=
    Unique(TolConfigManager::Config::Upgrading::TolPackage::Repositories <<
           [[url]]);
  Real TolConfigManager::SaveConfig(TolConfigManager::Config);
  True
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetRequirements= 
"Crea un texto con los #Require para una lista de paquetes";
Text GetRequirements(Set packages)
//////////////////////////////////////////////////////////////////////////////
{
  SetSum(EvalSet(packages,Text(Text required)
  {
    "#Require "+required+";\n"
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.DoRequirements= 
"Llama a #Require para una lista de paquetes";
Real DoRequirements(Set packages)
//////////////////////////////////////////////////////////////////////////////
{
  Set EvalSet(packages,Real(Text required)
  {
    Set IncludeText("#Require "+required+";\nReal True;");
    True
  });
  True
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalLastCompatible = 
"Devuelve la última versión de un paquete disponible localmente que es "
"compatible con la versión actual de TOL.";
Text LocalLastCompatible(Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Set pkgLst = GetDir(TolPackage::Client::_.localRoot)[2];
  Set pkgSel = Select(pkgLst,Real(Text pkgNamVer)
  {
    TextBeginWith( pkgNamVer, package+".")
  });
  Text If(!Card(pkgSel),"",
  {
    Set pkgSort = Sort(pkgSel, Real(Text a, Text b) { Compare(b, a) });
    pkgSort[1]
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalPath = 
"Devuelve el path completo del fichero local correspondiente a un paquete "
"comprimido.";
Text LocalPath(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  TolPackage::Client::_.localRoot+package.version+"/"+package.version+".zip"
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalOza = 
"Devuelve el path completo del fichero local OIS correspondiente a un "
"paquete.";
Text LocalOza(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  TolPackage::Client::_.localRoot+package.version+"/"+package.version+".oza"
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalResourcePath = 
"Devuelve el path completo del directorio local de un recurso ajeno a TOL "
"necesario para el paquete especificado.";
Text LocalResourcePath(Text package.version, Text resource)
//////////////////////////////////////////////////////////////////////////////
{
  TolPackage::Client::_.localRoot+package.version+"/"+resource
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalInstallPackage = 
"Instala un paquete desde el archivo local comprimido dado por el "
"argumento:\n"
"  Text pkg.path.zip = \"<directory>/<name>.<high>.<low>.zip\"\n";
Real LocalInstallPackage(Text pkg.path.zip)
//////////////////////////////////////////////////////////////////////////////
{
  Real OSFilCopy(pkg.path.zip, _.localRoot);
  Text pkg.name.zip = GetFileName(pkg.path.zip);
  Text pkg.name = Replace(pkg.name.zip,".zip","");
  Real PackArchive::UnpackFull("ZipArchive",_.localRoot+pkg.name);
  Real OSFilRemove(_.localRoot+pkg.name.zip);
  FileExist(_.localRoot+pkg.name+"/"+pkg.name+".oza")
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalClean = 
"Elimina un paquete local concreto.\n"
"Si no se especifica número de versión se borrarán todas las versiones "
"locales de dicho paquete.";
Real LocalClean(Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Real If(TextFind(package,"."),
  {
    Real OSDirRemove(_.localRoot+package)
  },
  {
    Set dir = GetDir(_.localRoot)[2];
    Set sel = Select(dir,Real(Text sub)
    {
      TextBeginWith(sub,package)
    });
    SetMin(EvalSet(sel,Real(Text pkg)
    {
      OSDirRemove(_.localRoot+pkg)
    }))
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LocalClean.All = 
"Elimina todos los paquetes disponibles localmente.";
Real LocalCleanAll(Text unused)
//////////////////////////////////////////////////////////////////////////////
{
  Real OSDirRemove(_.localRoot);
  Real OSDirMake(_.localRoot)
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetMinTolVersionForPackage = 
"Devuelve la versión de TOL mínima que requiere un paquete dado"
"Si no se encuentra el paquete se devuelve la cadena vacía.";
Text GetMinTolVersionForPackage(Text package)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE [RemoteFindRepository] 1 package='"<<package+"'");
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, "", {
//WriteLn("TRACE [RemoteFindRepository] 2");
  Set repositories = 
    TolConfigManager::Config::Upgrading::TolPackage::Repositories;
  Real K = Card(repositories); 
  Real k = 1;
  Text found = "";
//WriteLn("TRACE [RemoteFindRepository] 3 K="<<K);
  While(And(found=="", k<=K),
  {
  //WriteLn("TRACE [RemoteFindRepository] 4 repositories["<<k+"]="<<repositories[k]);
    Text pkgInfo = GetUrlContents(repositories[k]+"?"
      "action=versions&limit=1&"+
      "package="+package);
    Set pkgLst = IncludeText(pkgInfo);
  //WriteLn("TRACE [RemoteFindRepository] 5 pkgInfo="<<pkgInfo);
  //WriteLn("TRACE [RemoteFindRepository] 6 pkgLst="<<pkgLst);
  //WriteLn("TRACE [RemoteFindRepository] 7 Card(pkgLst)="<<Card(pkgLst));
    Text If(Card(pkgLst)>0, found := pkgLst[1]->te_min_tol_version);
    Real k := k+1
  });
  found
})};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteFindRepository = 
"Devuelve el repositorio al que pertenece un paquete dado de entre aquellos "
"repositorios dados de alta en : \n"
"  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories\n"
"Si no se encuentra el paquete en ninguno de ellos se devuelve la cadena "
"vacía.";
Text RemoteFindRepository(Text package)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE [RemoteFindRepository] 1 package='"<<package+"'");
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, "", {
//WriteLn("TRACE [RemoteFindRepository] 2");
  Set repositories = 
    TolConfigManager::Config::Upgrading::TolPackage::Repositories;
  Real K = Card(repositories); 
  Real k = 1;
  Text found = "";
//WriteLn("TRACE [RemoteFindRepository] 3 K="<<K);
  While(And(found=="", k<=K),
  {
  //WriteLn("TRACE [RemoteFindRepository] 4 repositories["<<k+"]="<<repositories[k]);
    Text pkgInfo = GetUrlContents(repositories[k]+"?"
      "action=versions&limit=1&"+
      "package="+package+"&"+
      min_tol_version_cond);
    Set pkgLst = IncludeText(pkgInfo);
  //WriteLn("TRACE [RemoteFindRepository] 5 pkgInfo="<<pkgInfo);
  //WriteLn("TRACE [RemoteFindRepository] 6 pkgLst="<<pkgLst);
  //WriteLn("TRACE [RemoteFindRepository] 7 Card(pkgLst)="<<Card(pkgLst));
    Text If(Card(pkgLst)>0, found := repositories[k]);
    Real k := k+1
  });
  found
})};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteReleaseDate = 
"Devuelve la fecha de la última actualización compatible con la versión "
"actual de TOL de un paquete en un repositorio dado. "
"Si no se especifica ningún repositorio se buscará en todos los "
"repositorios dados de alta en \n"
"  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories\n"
"Si no se encuentra el paquete se devuelve la fecha desconocida.";
Date RemoteReleaseDate(Text repository, Text package)
//////////////////////////////////////////////////////////////////////////////
{
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, UnknownDate, {
  Text rep = If(repository=="",repository,RemoteFindRepository(package));
  If(rep=="", UnknownDate,
  {
    Text pkgInfo = GetUrlContents(rep+"?"
      "action=versions&limit=1&"+
      "package="+package+"&"+
      min_tol_version_cond);
    Set pkgLst = IncludeText(pkgInfo);
    pkgLst[1]->dh_release_date_remote
  })
})};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.DownloadPackage = 
"Descarga desde el repositorio remoto al path indicado, un paquete "
"determinado\n";
Real DownloadPackage(
  Text repository, Text package, Real showError, Text localRoot)
//////////////////////////////////////////////////////////////////////////////
{
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, 0, {
  Real OSDirMake(localRoot);
//WriteLn("TRACE [RemoteInstallPackage] 1 repository='"<<repository+"'");
  Text package.version = package;
  Text If(TextFind(package,"."),
  {
    Text package := Tokenizer(package.version,".")[1]
  },
  {
    Text pkgInfo = GetUrlContents(repository+"?"
      "action=versions&limit=1&"+
      "package="+package+"&"+
      min_tol_version_cond);
    Set pkgLst = IncludeText(pkgInfo);
    Text package.version := pkgLst[1]->co_name_version
  });

//WriteLn("TRACE [RemoteInstallPackage] 2 package='"<<package+"'");
//WriteLn("TRACE [RemoteInstallPackage] 3 package.version='"<<package.version+"'");

  Text pack = package.version+".zip";
  Text oza = package.version+"/"+package.version+".oza";
  Text localPack = localRoot+"/"+pack;
  Text localOza = localRoot+"/"+oza;
  Text localDir = localRoot+"/"+package.version;

  Text encoded = GetUrlContents(repository+"?"
    "action=download&"+
    "format=base64&"+
    "package="+package.version);
//WriteLn("TRACE [RemoteInstallPackage] 4 encoded='"<<encoded+"'");
  Real DecodeBase64ToFile(localPack, encoded);
  If(!FileExist(localPack), False,
  {
  //WriteLn("TRACE DownloadPackage 4 UnpackFull("<<localDir+")");
    Real PackArchive::UnpackFull("ZipArchive", localDir);
    Real OSFilRemove(localPack);
    True
  });
//WriteLn("TRACE DownloadPackage 5");
  FileExist(localOza)  
})};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteInstallPackage = 
"Instala desde el repositorio remoto al local un paquete determinado "
"para que esté disponible llamando a #Require. \n"
"En un mismo repositorio local puede haber distintas veriones de un mismo "
"paquete que se distinguirán unas de otras por el texto posterior al "
"primer punto. Antes del punto el nombre del paquete suele de seguir la "
"nomenclatura tipo WIKI AaaBbb \n"
"Si no se especifica ninguna versión se instalará la última disponible."
"Si ya existía una copia en el repositorio local será substituida sin "
"mayores contemplaciones por lo que el usuario debe saber lo que pide. \n"
"Sólo es necesario instalar una vez un paquete y todas las sesiones TOL "
"que se lancen desde ese momento podrán usarlos.";
//////////////////////////////////////////////////////////////////////////////
Real RemoteInstallPackage(Text repository, Text package, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
  DownloadPackage( 
    repository, package, showError,
    TolPackage::Client::_.localRoot)
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteInstallFullRepository = 
"Instala la última versión compatible con la versión actual de TOL de todos "
"los paquetes disponibles en un repositorio remoto.\n";
//////////////////////////////////////////////////////////////////////////////
Real RemoteInstallFullRepository(Text repository, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, 0, {
  Text pkgInfo = GetUrlContents(repository+"?"
    "action=versions&"+
    min_tol_version_cond);
  Set pkgLst = IncludeText(pkgInfo);
  SetMin(EvalSet(pkgLst, Real(Set pkg)
  {
    RemoteInstallPackage(repository, pkg->co_name_version, showError)
  }))
})};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteInstall = 
"Instala desde el repositorio remoto al local un paquete determinado "
"para que esté disponible llamando a #Require. \n"
"En un mismo repositorio local puede haber distintas veriones de un mismo "
"paquete que se distinguirán unas de otras por el texto posterior al "
"primer punto. Antes del punto el nombre del paquete suele de seguir la "
"nomenclatura tipo WIKI AaaBbb \n"
"Si no se especifica ninguna versión se instalará la última disponible."
"Si no se especifica ningún paquete se instalará la última versión de "
"todos los disponibles en el repositorio.\n"
"Si no se especifica ningún repositorio se buscará en todos los "
"repositorios dados de alta en \n"
"  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories\n"
"Si ya existía una copia en el repositorio local será substituida sin "
"mayores contemplaciones por lo que el usuario debe saber lo que pide. \n"
"Sólo es necesario instalar una vez un paquete y todas las sesiones TOL "
"que se lancen desde ese momento podrán usarlos.";
//////////////////////////////////////////////////////////////////////////////
Real RemoteInstall(Text repository, Text package, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE [RemoteInstall] 1 repository='"<<repository+"'");
//WriteLn("TRACE [RemoteInstall] 2 package='"<<package+"'");
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, 0, {
  Case(
  And(repository!="",package!=""),
  {
  //WriteLn("TRACE [RemoteInstall] 3.1");
    RemoteInstallPackage(repository, package, showError)
  },
  And(repository=="",package!=""),
  {
  //WriteLn("TRACE [RemoteInstall] 3.2");
    Text rep = If(repository!="",repository,RemoteFindRepository(package));
  //WriteLn("TRACE [RemoteInstall] 3.2.1 rep ="<<rep);
    If(rep=="", 
    {
      If(showError,
      {
        Text minTolVersion = GetMinTolVersionForPackage(package);
        If(minTolVersion=="", 
        Error(I2(
          "Cannot find package "+package+" in any repository for any TOL "
          "version.",
          "No se encuentra el paquete "+package+" en ningún repositorio "
          "para ninguna versión de TOL.")),
        Error(I2(
          "Cannot find package "+package+" in any repository for current "
          "TOL version ",
          "No se encuentra el paquete "+package+" en ningún repositorio "
          "para la versión de TOL en curso ")+TolPackage::_.currentTolVersion+
          ".\n"+I2("You needs to use ", "Es necesario usar ")+minTolVersion))
      })
    },
    {
    //WriteLn("TRACE [RemoteInstall] 3.2.2 ");
      RemoteInstallPackage(rep, package, showError)
    })
  },
  And(repository!="",package==""),
  {
  //WriteLn("TRACE [RemoteInstall] 3.3");
    RemoteInstallFullRepository(repository, showError)
  },
  And(repository=="",package==""),
  {
  //WriteLn("TRACE [RemoteInstall] 3.4");
    Set repositories = 
      TolConfigManager::Config::Upgrading::TolPackage::Repositories;
    SetMin(EvalSet(repositories, Real(Text rep)
    {
      RemoteInstallFullRepository(rep, showError)
    }))
  })
})};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteUpdateVersSyncInfo = 
"Actualiza la información necesaria para la sincronización de versiones de "
"paquetes locales con el repositorio remoto para aquellos que son "
"compatibles con la versión actual de TOL.\n"
"Devuelve el número de versiones de paquetes compatibles disponibles de "
"forma remota.";
Real RemoteUpdateVersSyncInfo(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, 0, {
  Set repositories = 
    TolConfigManager::Config::Upgrading::TolPackage::Repositories;
  Set _.versSyncInfo := SetConcat(EvalSet(repositories,Set(Text rep)
  {
    Text pkgInfo = GetUrlContents(rep+"?"
      "action=versions&"+
      min_tol_version_cond);
    IncludeText(pkgInfo)
  }));
  Real SetIndexByName(_.versSyncInfo);
  Set pkgLst = GetDir(TolPackage::Client::_.localRoot)[2];
  Set EvalSet(pkgLst, Real(Text pkg)
  {
    Real found = FindIndexByName(_.versSyncInfo, pkg);
    Date If(!found, WriteLn("[RemoteUpdateVersSyncInfo] "+I2(
      "Cannot find remote image of local package "+pkg+
      " in any repository." ,
      "No se encuentra la imagen remota del paquete local "+pkg+
      " en ningún repositorio"),"W"),
    {
      Date gmt = Copy(NowGmt);
      Date loc = Copy(Now);
      Real lag = Round(DateDif(S(0),loc,gmt)/10)*10;
      Text oza = TolPackage::Client::_.localRoot+pkg+"/"+pkg+".oza";
      Date release.loc = FileTime(oza);
      Date release.gmt = Succ(release.loc,S(0),lag);
      _.versSyncInfo[found]->dh_release_date_local := release.gmt
    });
    True
  });
  Card(_.versSyncInfo)
})};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteUpdatePackSyncInfo = 
"Actualiza la información necesaria para la sincronización de paquetes "
"locales con el repositorio remoto para aquellos que son "
"compatibles con la versión actual de TOL.\n"
"Devuelve el número de paquetes compatibles disponibles de forma remota.";
Real RemoteUpdatePackSyncInfo(Real showWarnings)
//////////////////////////////////////////////////////////////////////////////
{
  Text _MID = "TolPackage::Client::[RemoteUpdatePackSyncInfo] ";
  If(TolConfigManager::Config::Upgrading::TolPackage::LocalOnly, 0, {
  Set repositories = 
    TolConfigManager::Config::Upgrading::TolPackage::Repositories;
  Set _.packSyncInfo := SetConcat(EvalSet(repositories,Set ev.rep(Text rep)
  {
    Text pkgInfo = GetUrlContents(rep+"?"
      "action=packages&"+
      min_tol_version_cond);
    IncludeText(pkgInfo)
  }));
  Real SetIndexByName(_.packSyncInfo);
  Set verLst = GetDir(TolPackage::Client::_.localRoot)[2];
  Set verCls = Classify(verLst,Real ev.class(Text a, Text b)
  {
    Compare(Tokenizer(a,".")[1], Tokenizer(b,".")[1])
  });
  Set EvalSet(verCls, Real ev.check(Set cls)
  {
    Text pkg = Tokenizer(cls[1],".")[1];
    Real found = FindIndexByName(_.packSyncInfo, pkg);
    Real If(!found, 
    {
      If(showWarnings,
        WriteLn(_MID+I2(
        "Cannot find remote image of local package "+pkg+
        " in any repository." ,
        "No se encuentra la imagen remota del paquete local "+pkg+
        " en ningún repositorio"),"W"));
      False
    },
    {
      Set ord = Sort(cls,Real ev.sort(Text a, Text b) { Compare(b, a) });
      Text ver = ord[1];
      Date gmt = Copy(NowGmt);
      Date loc = Copy(Now);
      Real lag = Round(DateDif(S(0),loc,gmt)/10)*10;
      Text oza = TolPackage::Client::_.localRoot+ver+"/"+ver+".oza";
      Date release.loc = FileTime(oza);
      Date release.gmt = Succ(release.loc,S(0),lag);
      Date _.packSyncInfo[found]->co_last_version_local := ver;
      Date _.packSyncInfo[found]->dh_release_date_local := release.gmt;
      True
    });
    True
  });
  Set _.packForUpdate := Select(_.packSyncInfo, Real(TolPackage::@PackageSynchro pkg)
  {
    Real need = And(pkg->co_last_version_local != "",
        pkg->co_last_version_local == pkg->co_last_version_remote,  
        pkg->dh_release_date_local <  pkg->dh_release_date_remote);
    If(And(showWarnings,need),
    {
      WriteLn("  Local package "<<pkg->co_last_version_local+
              " created at "<<pkg->dh_release_date_local+
              " could be updated to newer remote patch since "<<pkg->dh_release_date_remote)
    });
    need
  });
  If(And(showWarnings,Card(_.packForUpdate)),
  {
    WriteLn(_MID+"There are "<<Card(_.packForUpdate)+" packages that you could update "
            "from remote repositories to new patches of the same version.\n"
            "You can view them at:\n "
            "  Set TolPackage::Client::_.packForUpdate\n"
            "You could update all them running this TOL sentence: \n"
            "  Real TolPackage::Client::RemoteUpdateAll(0)\n",
            "W")
  });
  Set _.packForUpgrade := Select(_.packSyncInfo, Real(TolPackage::@PackageSynchro pkg)
  {
    Real need = And(pkg->co_last_version_local != "",
        pkg->co_last_version_local < pkg->co_last_version_remote);
    If(And(showWarnings,need),
    {
      WriteLn("  Local package "<<pkg->co_last_version_local+
              " could be upgraded to "<<pkg->co_last_version_remote)
    });
    need
  });
  If(And(showWarnings,Card(_.packForUpgrade)),
  {
    WriteLn(_MID+"There are "<<Card(_.packForUpgrade)+" packages that you could upgrade "
            "from remote repositories to new versions.\n"
            "You can view them at:\n "
            "  Set TolPackage::Client::_.packForUpgrade\n"
            "You can upgrade all them running this TOL sentence: \n"
            "  Real TolPackage::Client::RemoteUpgradeAll(0)\n",
            "W")
  });
  Set _.packForInstall := Select(_.packSyncInfo, Real(TolPackage::@PackageSynchro pkg)
  {
    pkg->co_last_version_local == ""  
  });
  Set _.packInstalled := Select(_.packSyncInfo, Real(TolPackage::@PackageSynchro pkg)
  {
    pkg->co_last_version_local != ""  
  });
  Card(_.packSyncInfo)
})};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteUpdateAll = 
"Actualiza automáticamente todos los paquetes disponibles desde los "
"repositorios remotos para los que la copia local haya caducado.\n";
Real RemoteUpdateAll(Real updateSyncInfo)
//////////////////////////////////////////////////////////////////////////////
{
  Real If(Or(updateSyncInfo,!Card(_.packSyncInfo)), 
    RemoteUpdatePackSyncInfo(False));
  If(!Card(_.packForUpdate), 0,
  SetSum(EvalSet(_.packForUpdate, Real(TolPackage::@PackageSynchro pkg)
  {
    RemoteInstallPackage(pkg->te_url, pkg->co_last_version_remote, True)
  })))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemoteUpgradeAll = 
"Actualiza automáticamente todos los paquetes disponibles desde los "
"repositorios remotos para los que exista una versión más moderna.\n";
Real RemoteUpgradeAll(Real updateSyncInfo)
//////////////////////////////////////////////////////////////////////////////
{
  Real If(Or(updateSyncInfo,!Card(_.packSyncInfo)), 
    RemoteUpdatePackSyncInfo(False));
  If(!Card(_.packForUpgrade), 0,
  SetSum(EvalSet(_.packForUpgrade, Real(TolPackage::@PackageSynchro pkg)
  {
    RemoteInstallPackage(pkg->te_url, pkg->co_last_version_remote, True)
  })))
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetCompatibleVersion.one = 
"Gets the latest version of a package that is compatible with a tol version.";
Text GetCompatibleVersion.one(Text tol_version, Text package)
////////////////////////////////////////////////////////////////////////////////
{
  Real If(!Card(_.versSyncInfo), 
   TolPackage::Client::RemoteUpdateVersSyncInfo(True));

  Set sel_compatible = Select(_.versSyncInfo, Real(TolPackage::@VersionSynchro reg)
  {
    And(reg->co_name==package, tol_version>=reg->te_min_tol_version)
  });

  Set last_compatible = Sort(sel_compatible, Real(TolPackage::@VersionSynchro a, TolPackage::@VersionSynchro b)
  {
    Compare(b->co_name_version,a->co_name_version)
  })[1];
  last_compatible->co_name_version
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetCompatibleVersion.all = 
"Gets the latest versions of a set of packages that are compatible with a tol "
"version.";
Set GetCompatibleVersion.all(Text tol_version, Set package.list)
////////////////////////////////////////////////////////////////////////////////
{
  EvalSet(package.list, Text (Text pv) 
  {
    GetCompatibleVersion.one(tol_version, pv)
  })
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetDeepDependencies.one = 
"Gets the list of deep depencies of a given version of a package";
Set GetDeepDependencies.one(Text package.version)
////////////////////////////////////////////////////////////////////////////////
{
  Real If(!Card(_.versSyncInfo), 
   TolPackage::Client::RemoteUpdateVersSyncInfo(True));
  Set sel = Select(_.versSyncInfo, Real(TolPackage::@VersionSynchro reg)
  {
    reg->co_name_version == package.version
  });
  If(!Card(sel), sel,
  {
    Text depExpr = sel[1]->te_dependencies;
    Set dep = If(depExpr=="",Copy(Empty),
    {
      Tokenizer(depExpr,",")
    });
    Unique(SetConcat(EvalSet(dep,GetDeepDependencies.one))<<[[ sel[1]->co_name_version ]])
  })
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetDeepDependencies.all = 
"Gets the list of deep depencies of a list of versions of packages";
Set GetDeepDependencies.all(Set package.version.list)
////////////////////////////////////////////////////////////////////////////////
{
  Unique(SetConcat(EvalSet(package.version.list, GetDeepDependencies.one)))
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetVersionInfo = 
"Gets the TolPackage::@VersionSynchro related to a version of a package";
Set GetVersionInfo(Set package.version.list)
////////////////////////////////////////////////////////////////////////////////
{
  Real If(!Card(_.versSyncInfo), 
   TolPackage::Client::RemoteUpdateVersSyncInfo(True));
  EvalSet(package.version.list, TolPackage::@VersionSynchro(Text pv)
  {
    _.versSyncInfo[pv]
  })
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.GetCompatibleDeepDependencies = 
"Gets the TolPackage::@VersionSynchro related to all deep dependencies of a "
"list of packages for the last version that is compatible with a tol version";
Set GetCompatibleDeepDependencies(Text tol_version, Set package.list)
////////////////////////////////////////////////////////////////////////////////
{
  Set package.version.list = GetCompatibleVersion.all(tol_version, package.list);
  GetVersionInfo(GetDeepDependencies.all(package.version.list))
};

////////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.DownloadCompatibleDeepDependencies = 
"Downloads to a local directory all deep dependencies of a list of packages "
"for the last version that is compatible with a tol version.\n"
"Arguments : \n"
"  Text localRoot      : Local directory where packages will be downloaded\n"
"  Real cleanLocalRoot : If true, local directory will be cleaned before to download\n"
"  Text tol_version    : Version of TOL comaptible with all packages\n"
"  Set package.list    : List of packages without explicit version\n"
"Returns true if all packages are found and downloaded.";
Real DownloadCompatibleDeepDependencies(
  Text localRoot,
  Real cleanLocalRoot,    
  Text tol_version,  
  Set package.list)
////////////////////////////////////////////////////////////////////////////////
{
  Real If(cleanLocalRoot, OSDirRemove(localRoot));
  Set dep = GetCompatibleDeepDependencies(tol_version, package.list);
  SetMin(EvalSet(dep, Real(TolPackage::@VersionSynchro vsi)
  {
    DownloadPackage(vsi->te_url,vsi->co_name_version,True,localRoot)
  }))
}

]];



