/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : builder.tol
// PURPOSE: Class TolPackage::Client::@Builder
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//Construye en el disco local el directorio de un repositorio de paquetes
Class @Builder {
//////////////////////////////////////////////////////////////////////////////

Text _.url;           //A unique address with remote or local protocol
Text _.name;          //A unique name 
Text _.type;          //Private, Public
Text _.description;   //Purpose of repository
Set  _.packageList;   //Set of names of packages
Set  _.pkgSourcePath; //Set of paths of packages
Text _.root;          //Local server-side installing directory
Text _.register;      //Local server-side register directory
Text _.index;         //Local server-side index prefix


//////////////////////////////////////////////////////////////////////////////
Static @Builder Create(
  Text url,          
  Text name,         
  Text type,         
  Text description,  
  Text sourceRoot,
  Set packageList_)
//////////////////////////////////////////////////////////////////////////////
{
  Text root = TolPackage::Server::_.localRoot+name+"/";
  Set pkgSourcePath = If(sourceRoot=="",
  {
    EvalSet(packageList_,GetFilePath)
  },
  {
    NCopy(Card(packageList_),sourceRoot)
  });
  Set packageList = If(sourceRoot=="",
  {
    EvalSet(packageList_,GetFilePrefix)
  },
  {
    DeepCopy(packageList_)
  });
  @Builder new = [[
    Text _.url = url;
    Text _.name = name;
    Text _.type = type;
    Text _.description = description;
    Set  _.packageList = packageList;
    Set  _.pkgSourcePath = pkgSourcePath;
    Text _.root = root;
    Text _.register = root+"register/";
    Text _.index = root+"index"
  ]];
  Real OSDirMake(new::_.root);
  Real OSDirMake(new::_.register);

  Real new::Build.All(0);
  new
};

//////////////////////////////////////////////////////////////////////////////
Real Initialize(Real void)  
//////////////////////////////////////////////////////////////////////////////
{
  Text index.csv = 
  "repository;"+
  "name;"+
  "pkgName;"+
  "version.high;"+
  "version.low;"+
  "brief;"+
  "keys;"+
  "authors;"+
  "minTolVersion;"+
  "releaseDate;"+
  "dependencies;"+
  "nonTolResurces;\n";

  Text index.tol =
  "//////////////////////////////////////////////////////////////////////////////\n"
  "//FILE : index.tol                                                            \n"
  "//PURPOSE : internal use of Class TolPackage::Client::@Repository             \n"
  "//                                                                            \n"
  "//       PLEASE, DON´T TOUCH THIS FILE NOR OTHER ONE IN THIS DIRECTORY!       \n"
  "//                                                                            \n"
  "//////////////////////////////////////////////////////////////////////////////\n"
  "  Text name = \""+_.name+"\";\n"+
  "  Text type = \""+_.type+"\";\n"+
  "  Text description = \""+_.description+"\";\n"+
  "\n";
    
  Text WriteFile(_.index+".csv",  index.csv);
  Text WriteFile(_.index+".tol",  index.tol);
//Text WriteFile(_.index+".wiki", index.wiki);
//Text WriteFile(_.index+".html", index.html);
  True
};

//////////////////////////////////////////////////////////////////////////////
Text Escape(Text field)
//////////////////////////////////////////////////////////////////////////////
{
  ReplaceTable(field,[[
    [["\n","[[BR]]"]],
    [[";",","]] ]])
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.FormatSet=
"Builds the TOL expression of a Set";
Text FormatSet(Set set)
//////////////////////////////////////////////////////////////////////////////
{
  Text bl = " ";
  Text name = Name(set);
  "Set { "+If(name=="","",Name(set)+" = ")+bl+
  If(!Card(set),"Copy(Empty)",
  {
    "[["+bl+
    SetSum(For(1,Card(set),Text(Real k)
    {
      Text gk = Grammar(set[k]);
      Text nk = Name(set[k]);
      Text dec = "  "+gk+" { "+If(nk=="","",nk+" = ");
      If(k>1,","+bl,"")+
      Case(
      gk=="Text", dec+"\""+set[k]+"\" } ",
      gk=="Real", dec<<set[k]+" } ",
      gk=="Date", dec<<set[k]+" } ",
      gk=="Set",  FormatSet(set[k]),
      1==1,
      {
        WriteLn("[TolPackage::Server::@Builder::FormatSet] "
        " Unexpected object "+If(nk,nk+" ","")+"of invalid type "+gk,"E"),
        ""
      })
    }))+bl+"]]"
  })+
  " }"
};

//////////////////////////////////////////////////////////////////////////////
Text Build.PackageInfo.Version(Text sourcePath, Text name, Real specificVersion)
//////////////////////////////////////////////////////////////////////////////
{
  Set aux = IncludeText("NameBlock "+name+";");
  NameBlock pkg = aux[1];
  Text sourceRoot = sourcePath+"/"+name; 
  Text pkgName = TolPackage::GetCurrentNameVersion(name,specificVersion);
  Set dependencies = TolPackage::GetDeepDependencies(name, specificVersion);
  Set nonTolResurces = If(!ObjectExist("Set",name+"::_.autodoc.nonTolResources"),
    Copy(Empty),pkg::_.autodoc.nonTolResources);
  Text index.csv = pkg::_.autodoc.url + ";"
  <<name + ";"
  <<pkgName+ ";"
  <<If(!specificVersion,?,pkg::_.autodoc.version.high) + ";"
  <<If(!specificVersion,?,pkg::_.autodoc.version.low) + ";"
  <<Escape(pkg::_.autodoc.brief) + ";"
  <<FormatSet(pkg::_.autodoc.keys) + ";"
  <<FormatSet(pkg::_.autodoc.authors) + ";"
  <<pkg::_.autodoc.minTolVersion + ";"
  <<Now + ";"
  <<FormatSet(dependencies)+ ";"
  <<FormatSet(nonTolResurces)+"\n";
  WriteLn("[TolPackage::Server::@Builder::Build.PackageInfo.Version] "+
    pkgName+":\n"+index.csv+"\n");
  Text WriteFile(_.register+pkgName,  index.csv);
  Real Ois.Store(aux,_.root+pkgName+".oza");
  Set EvalSet(TolPackage::Server::_.supportedPlatforms, Real(Text platform)
  {
    Text ppRoot_ = _.root+platform+"/"+pkgName;
    Text ppRoot = ppRoot_+"/";
    Real OSDirMake(ppRoot);
    Real OSFilCopy(_.root+pkgName+".oza", ppRoot+pkgName+".oza");
    Set selResources = SetConcat(Select(nonTolResurces, Real(Set ptf)
    {
      Or(ptf==platform,ptf=="CrossPlatform")
    }));
    Set EvalSet(selResources, Real(Text resource)
    {
      Text orig = sourceRoot+"/"+resource;
      Text dest = ppRoot+"/"+resource;
      Real OSDirMake(dest);
      // esto parece raro pero solo borra el dir destino, el make
      // anterior ha creado el path de sus padres
      If(OSUnix, OSDirRemove(dest));
      WriteLn("TRACE dir copy '"+orig+"' -> '"+dest+"'");
      OSDirCopy(orig,dest)
    });
    Text ppr = ReplaceSlash(ppRoot_);
    Real PackArchive::PackFull("ZipArchive", ppr);
    Real OSDirRemove(ppRoot);
    True
  });
  Real OSFilRemove(_.root+pkgName+".oza");
  index.csv
};

//////////////////////////////////////////////////////////////////////////////
Text Build.PackageInfo(Text sourcePath, Text name)
//////////////////////////////////////////////////////////////////////////////
{
  Build.PackageInfo.Version(sourcePath, name,True)+
  Build.PackageInfo.Version(sourcePath, name,False)
};


//////////////////////////////////////////////////////////////////////////////
Real Build.All(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  Real Initialize(void);
  Set For(1,Card(_.packageList), Real(Real k)
  {
    Text pkgName = _.packageList[k];
    Text sourcePath = _.pkgSourcePath[k];
    Text AppendFile(_.index+".csv",  Build.PackageInfo(sourcePath, pkgName));
  //Text AppendFile(_.index+".wiki", index.wiki);
  //Text AppendFile(_.index+".html", index.html);
    True
  });

  True
};

//////////////////////////////////////////////////////////////////////////////
Real Rebuild.One(Text sourcePath, Text pkgName)
//////////////////////////////////////////////////////////////////////////////
{
  Real Initialize(void);
  Text Build.PackageInfo(sourcePath,pkgName);
  Set pkgLst = Sort(GetDir(_.register)[2], Real(Text a, Text b)
  {
    Compare(b,a)
  });
  Set EvalSet(pkgLst, Real(Text pkgName)
  {
    Text AppendFile(_.index+".csv", ReadFile(_.register+pkgName));
    True 
  });
  True
}

};
