/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : repository.tol
// PURPOSE: Class TolPackage::Client::@Repository
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Class @Repository {
//////////////////////////////////////////////////////////////////////////////

//Dirección del repositorio remoto.
//Un repositorio remoto puede ser en realidad un directorio local para 
//facilitar proceso de instalación cerrada. Para ello la URL comenzará por 
//file:// seguido del path local donde se ubica el repositorio.\n
//Si la URL empieza por http:// https:// o cualquier otro protocolo
//reconocible por el sistema operativo se realizará la correspondiente 
//descarga remota. 
Text _.url;

//Nombre oficial del repositorio;
Text _.name = "";
//Tipo del repositorio : "Private" ó "Public";
Text _.type = "";
//Descripción del repositorio;
Text _.description = "";
//Protocolo de acceso al repositorio file://, http://, ...
Text _.protocol = "";
//Resto de la URL tras el protocolo
Text _.address = "";
//Cierto si el protocolo no es file://
Real _.isRemote = ?;
//Archivo del estado actual de los paquetes del repositorio
Set _.index = Copy(Empty);
//Resultado de la conexión al repositorio remoto
Real _.connected = ?;
//Instancias de repositorios que han sido consultados durante la sesión de 
//TOL actual
Static Set _.instances = Copy(Empty);
//Listado de todos los paquetes disponibles en todos los repositorios 
//consultados hasta el momento.
//Los nombres de paquetes son únicos no sólo dentro de cada repositorio sino
//que no puede haber repositorios que compartan un mismo paquete
Static Set _.allPackages = Copy(Empty);

//////////////////////////////////////////////////////////////////////////////
//Carga la lista de repositorios accesibles
Static Real LoadInstances(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  If(!Card(_.instances),
  {
    Text file = TolPackage::Client::_.localRoot+"repositories.txt";
    WriteLn("[TolPackage::Client::@Repository::LoadInstances]\n"
            "Loading list of available repositories from "+file);
    NameBlock @Repository::Get(
      "http://packages.tol-project.org/OfficialTolArchiveNetwork/", False);
    Real If(FileExist(file),
    { 
      Set lines = Tokenizer(ReadFile(file),"\n");
      Set EvalSet(lines,Real ev_lines(Text line)
      {
        Text url = Compact(line);
        Case(
        url=="",False,
        url==" ",False,
        TextBeginWith(url, "//"),False,
        1==1,
        {
          NameBlock @Repository::Get(url, False);
          True
        })
      });
      True   
    })
  });
  Card(_.instances)
};

//////////////////////////////////////////////////////////////////////////////
//Guarda la lista de repositorios accesibles
Static Real SaveInstances(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  If(!Card(_.instances), False,
  {
    Text file = TolPackage::Client::_.localRoot+"repositories.txt";
    WriteLn("[TolPackage::Client::@Repository::SaveInstances]\n"
            "Saving list of available repositories to "+file);
    Text WriteFile(file,
    "//////////////////////////////////////////////////////////////////////////////\n"
    "//List of availables repositories of TOL packages\n"
    "//////////////////////////////////////////////////////////////////////////////\n"
    "\n"
    "//Official tol-project packages \n"
    "//This repository is very recommendable. Please don't remove next line\n"
    "//Type: Public\n"
    "  http://packages.tol-project.org/OfficialTolArchiveNetwork/\n"
    "\n"); 
    Set EvalSet(_.instances,Real(@Repository r)
    {
      Text If(r::_.url != "http://packages.tol-project.org/OfficialTolArchiveNetwork/",
      {
        AppendFile(file,
        "\n"
        "//"+r::_.name+" \n"
        "//"+Compact(r::_.description)+" \n"
        "//Type: "+r::_.type+"\n"
        "  "+r::_.url+"\n"
        "\n")
      });
      True   
    });
    True
  })
};

//////////////////////////////////////////////////////////////////////////////
//Devuelve la instancia de repositorio correspondiente a una URL. Si no había
//sido consultado previamente se conecta primero al repositorio remoto.
//Si hay cambios en el directorio remoto durante la sesión TOL estos no serán
//percibidos.
Static @Repository Get(Text url, Real connect)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE @Repository::Get(\""+url+"\","<<connect+")");
  Real pos = FindIndexByName(@Repository::_.instances, ToName(url));
//WriteLn("TRACE @Repository::Get 1 pos="<<pos);
  If(pos, 
  {
  //WriteLn("TRACE @Repository::Get 2");
    Real If(connect, (_.instances[pos])::Connect(0));
    _.instances[pos]
  },
  {
  //WriteLn("TRACE @Repository::Get 3");
    @Repository::Open(url, connect)
  })
};

//////////////////////////////////////////////////////////////////////////////
//Abre un repositorio por primera vez
Static @Repository Open(Text url, Real connect)
//////////////////////////////////////////////////////////////////////////////
{
  Real prtPos = TextFind(url,"://")+2;
  //Protocolo de acceso al repositorio file://, http://, https://, ftp://
  Text protocol = Sub(url,1,prtPos);
  //Resto de la URL tras el protocolo
  Text address =  Sub(url,prtPos+1,TextLength(url));
  Set aux = [[ @Repository new = [[
    Text _.url = url;
    Text _.protocol = protocol;
    Text _.address = address;
    Real _.isRemote =  protocol!="file://"  ]] ]];
  Real If(connect, new::Connect(0));
  NameBlock PutName(ToName(url), aux[1]);
  Set Append(@Repository::_.instances, aux, True);
  aux[1]
};

//////////////////////////////////////////////////////////////////////////////
//Devuelve el contenido de un fichero de texto ubicado en el repositorio
  Text GetFileContens(Text path)
//////////////////////////////////////////////////////////////////////////////
{
  If(!_.isRemote,
  {
    ReadFile(_.address+path)
  },
  {
    StdLib::GetUrlContents(_.url+path)
  })
};

//////////////////////////////////////////////////////////////////////////////
//Copia un fichero del repositorio remoto al directorio local de paquetes
  Real DownloadPackage(Text packageName)
//////////////////////////////////////////////////////////////////////////////
{
  Text localPath = 
    TolPackage::Client::_.localRoot+packageName+".oza";
  If(FileExist(localPath), OSFilRemove(localPath));
  If(!_.isRemote,
  {
    OSFilCopy(_.address+"packages/"+packageName+".oza",localPath)
  },
  {
    //Hay que buscar una forma de copiar remoto sin wget, con el TCL
    OSCmdWait("wget -O\""+localPath+"\" \""+
              _.url+"packages/"+packageName+".oza\"")
  });
  FileExist(localPath)
};

//////////////////////////////////////////////////////////////////////////////
//Función de conexión al repositorio remoto 
Real Connect(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  If(Not(IsUnknown(_.connected)), _.connected,
  {
    WriteLn("[TolPackage::Client::@Repository::Connect] "
      "Trying to conect to repository "+_.url+" ...");
    Real numErr0 = Copy(NError);
    Set repInf = IncludeText(GetFileContens("index.tol"));
    Text _.name := repInf::name;
    Text _.type := repInf::type;
    Text _.description := repInf::description;
    Text aux = GetFileContens("index.csv");
    Set line = Tokenizer(aux,"\n");

    Set cells.all = For(2,Card(line), Set(Real k)
    {
    //WriteLn("TRACE Connect line["<<k+"] = '"<<line[k]+"'");
      Set fields = Tokenizer(line[k],";");
    //WriteLn("TRACE Connect Card(fields) = "<<Card(fields));
      fields
    });
    Set cells = Select(cells.all, Real(Set s) { Card(s)==11 });
    Set pckInf = For(1,Card(cells), TolPackage::@PackageInfo(Real k)
    {
      Set fields = cells[k];
      Set aux = { [[ TolPackage::@PackageInfo(
        Text repository = fields[1],
        Text name = fields[2],
        Text name.version = fields[3],
        Real version.high = Eval(fields[4]),
        Real version.low = Eval(fields[5]),
        Text brief = fields[6],
        Set keys =  Eval(fields[7]),
        Set authors =  Eval(fields[8]),
        Text minTolVersion = fields[9],
        Date releaseDate = Eval(fields[10]),
        Set dependencies = Eval(fields[11])
      ) ]] };
      Set PutName(aux[1]->name.version,aux[1]);
      aux[1]
    });

    Set _.index := Sort(pckInf,Real(TolPackage::@PackageInfo a, TolPackage::@PackageInfo b)
    {
      Compare(b->name.version, a->name.version)
    });
    Real SetIndexByName(_.index);
    Set Append(_.allPackages,_.index, True);
    Set _.allPackages := Sort(_.allPackages,Real(TolPackage::@PackageInfo a, TolPackage::@PackageInfo b)
    {
      Compare(b->name.version, a->name.version)
    });
    Real numErr1 = Copy(NError);
    Real _.connected := And(numErr1==numErr0,Card(_.index));
    If(_.connected, WriteLn(" ... Connected!"), 
                    WriteLn(" ... NOT Connected!","W"));
    _.connected
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Exist = 
"Devuelve cierto si existe el paquete especificado";
Real Exist(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  Real pos = FindIndexByName(_.index,package);
  pos > 0
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Install = 
"Instala desde el repositorio remoto al local un paquete determinado "
"para que esté disponible llamando a #Require. \n"
"Un repositorio remoto puede ser en realidad un directorio local para "
"facilitar proceso de instalación cerrada. Para ello la URL comenzará por "
"file:// seguido del path local donde se ubica el repositorio.\n"
"Si la URL empieza por http:// https:// ftp:// o cualquier otro protocolo"
"reconocible por el sistema operativo se realizará la correspondiente "
"descarga remota. \n"
"En un mismo repositorio local puede haber distintas veriones de un mismo "
"paquete que se distinguirán unas de otras por el texto posterior al "
"primer punto. Antes del punto el nombre del paquete ha de seguir la "
"nomenclatura tipo WIKI AaaBbb \n"
"Si no se especifica ninguna versión se instalará la última disponible "
"con una copia que especifique el nombre con versión y otra sin versión, "
"sólo con el nombre del paquete, de forma que el #Require funcione igual "
"tanto si se especifica la última versión como si no se especifica "
"ninguna. \n"
"Si ya existía una copia en el repositorio local será substituida sin "
"mayores contemplaciones por lo que el usuario debe saber lo que pide. \n"
"Sólo es necesario instalar una vez un paquete y todas las sesiones TOL "
"que se lancen desde ese momento podrán usarlos.";
Real Install(Text package.version, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
  WriteLn("[TolPackage::Client::@Repository::Install] "
    "Trying to download package from "+_.url+package.version);
  Real DownloadPackage(package.version);
  Real ok = FileExist(TolPackage::Client::_.localRoot+package.version);
  If(And(!ok,showError),
  {
    WriteLn("[TolPackage::Install] "
    "Cannot install package "+_.url+package.version,"E")
  });
  ok
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Install.All = 
"Instala la última versión de todos los paquetes disponibles en un "
"repositorio remoto.";
Real Install.All(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  SetMin(EvalSet(_.index, Real(TolPackage::@PackageInfo pi)
  {
    DownloadPackage(pi->name.version)
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Find = 
"Busca un paquete entre todos los repositorios consultables y, si lo "
"encuentra, devuelve el registro de información con estructura @PackageInfo, "
"y si no, el conjunto vacío.";
Static Set Find(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  Set EvalSet(_.instances,Real(@Repository r)
  {
    If(!IsUnknown(r::_.connected), False, r::Connect(0))
  });
  Real pos = FindIndexByName(_.allPackages,package.version);
  Set found = If(pos<=0, Copy(Empty), _.allPackages[pos]);
  found
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.FindAndInstall = 
"Busca un paquete entre todos los repositorios consultables y si lo "
"encuentra lo instala.";
Static Real FindAndInstall(Text package.version, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE @Repository::FindAndInstall(\""+remote.repository+"\","<<showError+")");
  Set pkgInf = @Repository::Find(package.version);
//WriteLn("TRACE @Repository::FindAndInstall 1 Card(pkgInf)="<<Card(pkgInf));
  Case(
  Card(pkgInf)>0,
  { 
  //WriteLn("TRACE @Repository::FindAndInstall 2");
    @Repository r = @Repository::Get(pkgInf->repository, True);
    r::Install(pkgInf->name, showError)
  },
  showError,
  { 
  //WriteLn("TRACE @Repository::FindAndInstall 3");
    WriteLn("[TolPackage::FindAndInstall] "
    "Cannot find package "+package.version+" in available repositories","E");
    False
  },
  1==1,
  {
  //WriteLn("TRACE @Repository::FindAndInstall 4");
    False
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LastDate = 
"Devuelve la fecha de la última actualización de un paquete en un "
"repositorio";
Date LastDate(Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Real pos = FindIndexByName(_.index,package);
  If(!pos, TheBegin,
  { 
    _.index[pos]->lastDate
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Upgrade = 
"Actualiza automáticamente un paquete si ha caducado caduca la copia local "
"llamando a Install.";
Real Upgrade(Text package, Real caducityInDays)
//////////////////////////////////////////////////////////////////////////////
{
  Date localDate = If(!FileExist(TolPackage::Client::_.localRoot+path), 
    TheBegin,
    FileTime(TolPackage::Client::_.localRoot+path));
  Date lastDate = LastDate(package);
  If(lastDate-localDate<=caducityInDays, False, Install(package));
  True
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Upgrade.All = 
"Actualiza automáticamente todos los paquetes disponibles en un repositorio "
"remoto para los que la copia local haya caducado.";
Real Upgrade.All(Real caducityInDays)
//////////////////////////////////////////////////////////////////////////////
{
  SetSum(EvalSet(_.index, Real(TolPackage::@PackageInfo pi)
  {
    Upgrade(pi->name.version, caducityInDays)
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Upgrade.AllInAll = 
"Actualiza automáticamente todos los paquetes disponibles en todos los "
"repositorios remotos consultados para los que la copia local haya caducado.";
Static Real Upgrade.AllInAll(Real caducityInDays)
//////////////////////////////////////////////////////////////////////////////
{
  SetSum(EvalSet(@Repository::_.instances, Real(@Repository r)
  {
    r::Upgrade.All(caducityInDays)
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.ForceExactRequirements = 
"Permite usar una versión de un paquete distinta de la última con #Require "
"asegurando la compatibilidad con el estado exacto de los paquetes de los "
"que depende el requerido y recursivamente los que dependen de ellos. \n"
"Lee en el repositorio remoto la lista de requerimientos para el paquete y " 
"hace los requires de las versiones exactas. \n"
"Hay que llamar a este método siempre antes de hacer ningún #Require de "
"cualquiera de los paquetes requeridos directa o indirectamente por lo que " 
"lo más aconsejable es hacerlo justo después de cargar la StdLib ";
Real ForceExactRequirements(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  Real pos = FindIndexByName(_.index,package.version),
  If(!pos, False,
  { 
    TolPackage::DoRequirements(_.index[pos]->dependencies)
  })
}

};


