/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : repository.tol
// PURPOSE: Class TolPackage::@Repository
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//Información de un paquete dentro del archivo de estado un repositorio
  Struct @PackageInfo {
//////////////////////////////////////////////////////////////////////////////
  Text repository,
  Text name,
  Text name.version,
  Real version.high,
  Real version.low,
  Text brief,
  Set  keys,
  Set  authors,
  Text minTolVersion,
  Text releaseDate,
  Set  dependencies
};

//////////////////////////////////////////////////////////////////////////////
Class @Repository {
//////////////////////////////////////////////////////////////////////////////

//Dirección del repositorio remoto.
//Un repositorio remoto puede ser en realidad un directorio local para 
//facilitar proceso de instalación cerrada. Para ello la URL comenzará por 
//file:// seguido del path local donde se ubica el repositorio.\n
//Si la URL empieza por http:// https:// o cualquier otro protocolo
//reconocible por el sistema operativo se realizará la correspondiente 
//descarga remota. 
Text _.url;

//Nombre oficial del repositorio;
Text _.name = "";
//Tipo del repositorio : "Private" ó "Public";
Text _.type = "";
//Descripción del repositorio;
Text _.description = "";
//Protocolo de acceso al repositorio file://, http://, ...
Text _.protocol = "";
//Resto de la URL tras el protocolo
Text _.address = "";
//Cierto si el protocolo no es file://
Real _.isRemote = ?;
//Archivo del estado actual de los paquetes del repositorio
Set _.index = Copy(Empty);
//Resultado de la conexión al repositorio remoto
Real _.connected = ?;
//Instancias de repositorios que han sido consultados durante la sesión de 
//TOL actual
Static Set _.instances = Copy(Empty);
//Listado de todos los paquetes disponibles en todos los repositorios 
//consultados hasta el momento.
//Los nombres de paquetes son únicos no sólo dentro de cada repositorio sino
//que no puede haber repositorios que compartan un mismo paquete
Static Set _.allPackages = Copy(Empty);

//////////////////////////////////////////////////////////////////////////////
//Devuelve la instancia de repositorio correspondiente a una URL. Si no había
//sido consultado previamente se conecta primero al repositorio remoto.
//Si hay cambios en el directorio remoto durante la sesión TOL estos no serán
//percibidos.
Static @Repository Get(Text url)
//////////////////////////////////////////////////////////////////////////////
{
  Real pos = FindIndexByName(@Repository::_.instances, ToName(url));
  If(pos, _.instances[pos],
  {
    @Repository::_Open(url)
  })
};

//////////////////////////////////////////////////////////////////////////////
//Abre un repositorio por primera vez
Static @Repository _Open(Text url)
//////////////////////////////////////////////////////////////////////////////
{
  Real prtPos = TextFind(url,"://")+2;
  //Protocolo de acceso al repositorio file://, http://, https://, ftp://
  Text protocol = SubString(url,1,prtPos);
  //Resto de la URL tras el protocolo
  Text address =  SubString(url,prtPos+1,TextLength(url));
  Set aux = [[ @Repository new = [[
    Text _.url = url;
    Text _.protocol = protocol;
    Text _.address = address;
    Real _.isRemote =  protocol!="file://"  ]] ]];
  Real If(new::Connect(0),
  {
    NameBlock PutName(ToName(url), aux[1]);
    Set Append(@Repository::_.instances, aux, True);
    True
  });
  aux[1]
};

//////////////////////////////////////////////////////////////////////////////
//Devuelve el contenido de un fichero de texto ubicado en el repositorio
  Text GetFileContens(Text path)
//////////////////////////////////////////////////////////////////////////////
{
  If(!_.isRemote,
  {
    ReadFile(_.address+path)
  },
  {
    StdLib::GetUrlContents(_.url+path)
  })
};

//////////////////////////////////////////////////////////////////////////////
//Copia un fichero del repositorio remoto al directorio local de paquetes
  Real DownloadFile(Text path)
//////////////////////////////////////////////////////////////////////////////
{
  If(FileExist(TolPackge::Client::_.localRoot+path),
    OSFilRemove(TolPackge::Client::_.localRoot+path));
  If(!_.isRemote,
  {
    OSFilCopy(_.address+path,TolPackge::Client::_.localRoot+path)
  },
  {
    //Hay que buscar una forma de copiar remoto sin wget, con el TCL
    OSCmdWait("wget -O\""+TolPackge::Client::_.localRoot+path+"\" \""+
              _.url+path+"\"")
  })
};

//////////////////////////////////////////////////////////////////////////////
//Función de conexión al repositorio remoto 
Real Connect(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  If(Not(IsUnknown(_.connected)), _.connected,
  {
    Real numErr0 = Copy(NError);
    Set repInf = IncludeText(GetFileContens("index.tol"));
    Text _.name := repInf::name;
    Text _.type := repInf::type;
    Text _.description := repInf::description;
    Text aux = GetFileContens("index.csv");
    Set line = Tokenizer(aux,"\n");
    Set pckInf = For(2,Card(line), @PackageInfo(Real k)
    {
      Set fields = Tokenizer(line[k],";","\"","\\");
      Set aux = { [[ @PackageInfo(
        Text repository = url,
        Text name = fields[1],
        Real version.high = Eval(fields[2]),
        Real version.low = Eval(fields[3]),
        Real name.version = Eval(fields[4]),
        Text brief = fields[5],
        Set keys =  Eval(fields[6]),
        Set authors =  Eval(fields[7]),
        Text minTolVersion = fields[8],
        Text releaseDate = fields[9],
        Set dependencies = Eval(fields[10])
      ) ]] };
      Set PutName(aux[1]->name.version,aux[1]);
      aux[1]
    });
    Set _.index := Sort(pckInf,Real(@PackageInfo a, @PackageInfo b)
    {
      Compare(b->name.version, a->name.version)
    });
    Real SetIndexByName(_.index);
    Set Append(_.allPackages,_.index, True);
    Set _.allPackages := Sort(_.allPackages,Real(@PackageInfo a, @PackageInfo b)
    {
      Compare(b->name.version, a->name.version)
    });
    Real numErr1 = Copy(NError);
    _.connected := And(numErr1==numErr0,Card(_.index))
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Exist = 
"Devuelve cierto si existe el paquete especificado";
Real Exist(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  Real pos = FindIndexByName(_.index,package);
  pos > 0
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Install = 
"Instala desde el repositorio remoto al local un paquete determinado "
"para que esté disponible llamando a #Require. \n"
"Un repositorio remoto puede ser en realidad un directorio local para "
"facilitar proceso de instalación cerrada. Para ello la URL comenzará por "
"file:// seguido del path local donde se ubica el repositorio.\n"
"Si la URL empieza por http:// https:// ftp:// o cualquier otro protocolo"
"reconocible por el sistema operativo se realizará la correspondiente "
"descarga remota. \n"
"En un mismo repositorio local puede haber distintas veriones de un mismo "
"paquete que se distinguirán unas de otras por el texto posterior al "
"primer punto. Antes del punto el nombre del paquete ha de seguir la "
"nomenclatura tipo WIKI AaaBbb \n"
"Si no se especifica ninguna versión se instalará la última disponible "
"con una copia que especifique el nombre con versión y otra sin versión, "
"sólo con el nombre del paquete, de forma que el #Require funcione igual "
"tanto si se especifica la última versión como si no se especifica "
"ninguna. \n"
"Si ya existía una copia en el repositorio local será substituida sin "
"mayores contemplaciones por lo que el usuario debe saber lo que pide. \n"
"Sólo es necesario instalar una vez un paquete y todas las sesiones TOL "
"que se lancen desde ese momento podrán usarlos.";
Real Install(Text package.version, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
  Real DownloadFile(package.version);
  Real ok = FileExist(TolPackge::Client::_.localRoot+package.version);
  If(And(!ok,showError),
  {
    WriteLn("[TolPackage::Install] "
    "Cannot install package "+_.url+package.version,"E")
  });
  ok
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Install.All = 
"Instala la última versión de todos los paquetes disponibles en un "
"repositorio remoto.";
Real Install.All(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  SetMin(EvalSet(_.index, Real(@PackageInfo pi)
  {
    DownloadFile(pi->name.version)
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.LastDate = 
"Devuelve la fecha de la última actualización de un paquete en un "
"repositorio";
Date LastDate(Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Real pos = FindIndexByName(_.index,package);
  If(!pos, TheBegin,
  { 
    _.index[pos]->lastDate
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Upgrade = 
"Actualiza automáticamente un paquete si ha caducado caduca la copia local "
"llamando a Install.";
Real Upgrade(Text package, Real caducityInDays)
//////////////////////////////////////////////////////////////////////////////
{
  Date localDate = If(!FileExist(TolPackge::Client::_.localRoot+path), 
    TheBegin,
    FileTime(TolPackge::Client::_.localRoot+path));
  Date lastDate = LastDate(package);
  If(lastDate-localDate<=caducityInDays, False, Install(package));
  True
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Upgrade.All = 
"Actualiza automáticamente todos los paquetes disponibles en un repositorio "
"remoto para los que la copia local haya caducado.";
Real Upgrade.All(Real caducityInDays)
//////////////////////////////////////////////////////////////////////////////
{
  SetSum(EvalSet(_.index, Real(@PackageInfo pi)
  {
    Upgrade(pi->name.version, caducityInDays)
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Upgrade.AllInAll = 
"Actualiza automáticamente todos los paquetes disponibles en todos los "
"repositorios remotos consultados para los que la copia local haya caducado.";
Static Real Upgrade.AllInAll(Real caducityInDays)
//////////////////////////////////////////////////////////////////////////////
{
  SetSum(EvalSet(@Repository::_.instances, Real(@Repository r)
  {
    r::Upgrade.All(caducityInDays)
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.ForceExactRequirements = 
"Permite usar una versión de un paquete distinta de la última con #Require "
"asegurando la compatibilidad con el estado exacto de los paquetes de los "
"que depende el requerido y recursivamente los que dependen de ellos. \n"
"Lee en el repositorio remoto la lista de requerimientos para el paquete y " 
"hace los requires de las versiones exactas. \n"
"Hay que llamar a este método siempre antes de hacer ningún #Require de "
"cualquiera de los paquetes requeridos directa o indirectamente por lo que " 
"lo más aconsejable es hacerlo justo después de cargar la StdLib ";
Real ForceExactRequirements(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  Real pos = FindIndexByName(_.index,package.version),
  If(!pos, False,
  { 
    TolPackage::DoRequirements(_.index[pos]->dependencies)
  })
}



};
