/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : repository.tol
// PURPOSE: Class TolPackage::Client::@Repository
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Class @Repository {
//////////////////////////////////////////////////////////////////////////////

//Dirección del repositorio remoto.
//Un repositorio remoto puede ser en realidad un directorio local para 
//facilitar proceso de instalación cerrada. Para ello la URL comenzará por 
//file:// seguido del path local donde se ubica el repositorio.\n
//Si la URL empieza por http:// https:// o cualquier otro protocolo
//reconocible por el sistema operativo se realizará la correspondiente 
//descarga remota. 
Text _.url;

//Nombre oficial del repositorio;
Text _.name = "";
//Tipo del repositorio : "Private" ó "Public";
Text _.type = "";
//Descripción del repositorio;
Text _.description = "";
//Protocolo de acceso al repositorio file://, http://, ...
Text _.protocol = "";
//Resto de la URL tras el protocolo
Text _.address = "";
//Cierto si el protocolo no es file://
Real _.isRemote = ?;
//Archivo del estado actual de los paquetes del repositorio
Set _.index = Copy(Empty);
//Resultado de la conexión al repositorio remoto
Real _.connected = ?;
//Instancias de repositorios que han sido consultados durante la sesión de 
//TOL actual
Static Set _.instances = Copy(Empty);
//Listado de todos los paquetes disponibles en todos los repositorios 
//consultados hasta el momento.
//Los nombres de paquetes son únicos no sólo dentro de cada repositorio sino
//que no puede haber repositorios que compartan un mismo paquete
Static Set _.allPackages = Copy(Empty);

Static Real _.localOnlyWarningWasShown = False;

Static Text _.platform = If(OSWin, "Windows-x86_32", "Linux-x86_32");

//////////////////////////////////////////////////////////////////////////////
//Carga la lista de repositorios accesibles
Static Real LoadInstances(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  If(!Card(_.instances),
  {
    Text file = TolPackage::Client::_.localRoot+"repositories.txt";
    WriteLn("[TolPackage::Client::@Repository::LoadInstances]\n"
            "Loading list of available repositories from "+file);
    NameBlock @Repository::Get(
      "http://packages.tol-project.org/OfficialTolArchiveNetwork/", False);
    Real If(FileExist(file),
    { 
      Set lines = Tokenizer(ReadFile(file),"\n");
      Set EvalSet(lines,Real ev_lines(Text line)
      {
        Text url = Compact(line);
        Case(
        url=="",False,
        url==" ",False,
        TextBeginWith(url, "//"),False,
        1==1,
        {
          NameBlock @Repository::Get(url, False);
          True
        })
      });
      Text bst = TolPackage::Client::_.localRoot+"packages.bst"; 
      Set If(And(FileExist(bst),FileBytes(bst)),  
        @Repository::_.allPackages := IncludeBST(bst));
      True   
    })
  });
  Card(_.instances)
};

//////////////////////////////////////////////////////////////////////////////
//Guarda la lista de repositorios accesibles
Static Real SaveInstances(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  If(!Card(_.instances), False,
  {
    Text file = TolPackage::Client::_.localRoot+"repositories.txt";
    Text WriteFile(file,
    "//////////////////////////////////////////////////////////////////////////////\n"
    "//List of availables repositories of TOL packages\n"
    "//////////////////////////////////////////////////////////////////////////////\n"
    "\n"
    "//Official tol-project packages \n"
    "//This repository is very recommendable. Please don't remove next line\n"
    "//Type: Public\n"
    "  http://packages.tol-project.org/OfficialTolArchiveNetwork/\n"
    "\n"); 
    Set EvalSet(_.instances,Real(@Repository r)
    {
      Text If(r::_.url != "http://packages.tol-project.org/OfficialTolArchiveNetwork/",
      {
        AppendFile(file,
        "\n"
        "//"+r::_.name+" \n"
        "//"+Compact(r::_.description)+" \n"
        "//Type: "+r::_.type+"\n"
        "  "+r::_.url+"\n"
        "\n")
      });
      True   
    });
    Set If(Card(@Repository::_.allPackages), 
      BSTFile(@Repository::_.allPackages,
        TolPackage::Client::_.localRoot+"packages.bst"));
    WriteLn("[TolPackage::Client::@Repository::SaveInstances]\n"
            "List of available repositories and packages have been saved to "
            "local store \n  "+TolPackage::Client::_.localRoot);
    True
  })
};

//////////////////////////////////////////////////////////////////////////////
//Devuelve la instancia de repositorio correspondiente a una URL. Si no había
//sido consultado previamente se conecta primero al repositorio remoto.
//Si hay cambios en el directorio remoto durante la sesión TOL estos no serán
//percibidos.
Static @Repository Get(Text url, Real connect)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE @Repository::Get(\""+url+"\","<<connect+")");
  Real pos = FindIndexByName(@Repository::_.instances, ToName(url));
//WriteLn("TRACE @Repository::Get 1 pos="<<pos);
  If(pos, 
  {
  //WriteLn("TRACE @Repository::Get 2");
    Real If(connect, (_.instances[pos])::Connect(0));
    _.instances[pos]
  },
  {
  //WriteLn("TRACE @Repository::Get 3");
    @Repository::Open(url, connect)
  })
};

//////////////////////////////////////////////////////////////////////////////
//Abre un repositorio por primera vez
Static @Repository Open(Text url, Real connect)
//////////////////////////////////////////////////////////////////////////////
{
  Real prtPos = TextFind(url,"://")+2;
  //Protocolo de acceso al repositorio file://, http://, https://, ftp://
  Text protocol = Sub(url,1,prtPos);
  //Resto de la URL tras el protocolo
  Text address =  Sub(url,prtPos+1,TextLength(url));
  Set aux = [[ @Repository new = [[
    Text _.url = url;
    Text _.protocol = protocol;
    Text _.address = address;
    Real _.isRemote =  protocol!="file://"  ]] ]];
  Real If(connect, new::Connect(0));
  NameBlock PutName(ToName(url), aux[1]);
  Set Append(@Repository::_.instances, aux, True);
  aux[1]
};

//////////////////////////////////////////////////////////////////////////////
//Devuelve el contenido de un fichero de texto ubicado en el repositorio
  Text GetFileContent(Text path)
//////////////////////////////////////////////////////////////////////////////
{
  Text content = If(!_.isRemote,
  {
  //WriteLn("TRACE [GetFileContent] 1 _.address+path='"+_.address+path+"'");
    ReadFile(_.address+path)
  },
  {
  //WriteLn("TRACE [GetFileContent] 2 _.url+path='"+_.url+path+"'");
    StdLib::GetUrlContents(_.url+path)
  });
//WriteLn("TRACE [GetFileContent] 3 content='"+content+"'");
  content
};

//////////////////////////////////////////////////////////////////////////////
//Copia un fichero del repositorio remoto al directorio local de paquetes
  Real DownloadPackage(Text packageName)
//////////////////////////////////////////////////////////////////////////////
{
  Text pack = packageName+".zip";
  Text oza = packageName+"/"+packageName+".oza";
  Text localPack = TolPackage::Client::_.localRoot+pack;
  Text localOza = TolPackage::Client::_.localRoot+oza;
  Text localDir = TolPackage::Client::_.localRoot+packageName;
  If(FileExist(localPack), OSFilRemove(localPack));
//WriteLn("TRACE DownloadPackage localPack="<<localPack);
  If(!_.isRemote,
  {
  //WriteLn("TRACE DownloadPackage  cp \""+_.address+@Repository::_.platform+"/"+pack+"\" \""+localPack+"\"");
    OSFilCopy(_.address+@Repository::_.platform+"/"+pack,localPack)
  },
  {
    CurlApi::GetUrl([[
      Text url  = _.url+@Repository::_.platform+"/"+pack, 
      Text file = localPack ]]) 
  });
  If(!FileExist(localPack), False,
  {
  //WriteLn("TRACE DownloadPackage UnpackFull("<<localDir+")");
    Real PackArchive::UnpackFull("ZipArchive", localDir);
    OSFilRemove(localPack);
    True
  });
  FileExist(localOza)
};

//////////////////////////////////////////////////////////////////////////////
//Mezcla un listado de paquetes con la lista actual de los mismos comprobando
//si no hay repeticiones y manteniendo los índices y el orden.
Static Real MergePackages(Set packages)
//////////////////////////////////////////////////////////////////////////////
{
  Set newPackages = Select(packages, Real(TolPackage::@PackageInfo a)
  {
    Set ap = @Repository::_.allPackages;
    Real pos = FindIndexByName(ap,a->name.version);
    Case(
    pos<=0, 
    {
      True
    },
    ap[pos]->repository == a->repository,
    {
      False
    },
    1==1,
    {
      WriteLn("[TolPackage::Client::@Repository::Connect] Package "+
      a->name.version+" is duplicated in these repositories: \n"+
      "  "+ap[pos]->repository+"\n"+
      "  "+a->repository+"\n" ,
      "E");
      False
    })
  });
  Set Append(@Repository::_.allPackages, newPackages, True);
  Set @Repository::_.allPackages := Sort(@Repository::_.allPackages,
  Real(TolPackage::@PackageInfo a, TolPackage::@PackageInfo b)
  {
    Compare(b->name.version, a->name.version)
  });
  True
};

//////////////////////////////////////////////////////////////////////////////
//Función de conexión al repositorio remoto 
Real Connect(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  Case(
  Not(IsUnknown(_.connected)), 
  {
    _.connected
  },
  And(_.isRemote,TolConfigManager::Config::Upgrading::TolPackage::LocalOnly),
  {
    If(Not(@Repository::_.localOnlyWarningWasShown),
    {
      WriteLn("[TolPackage::Client::@Repository::Connect] "
        "Remote connections are disabled by user configuration parameter\n"
        "  TolConfigManager::Config::Upgrading::TolPackage::LocalOnly \n"
        "Using just local information.");
      @Repository::_.localOnlyWarningWasShown := True
    });
    Real _.connected := False;
    _.connected
  },
  1==1,
  {
    WriteLn("[TolPackage::Client::@Repository::Connect] "
      "Trying to connect to repository "+_.url+" ...");
    Real numErr0 = Copy(NError);
  //WriteLn("TRACE [Connect] 1");
    Set repInf = IncludeText(GetFileContent("index.tol"));
    Text _.name := repInf::name;
  //WriteLn("TRACE [Connect] 2 _.name='"+_.name+"'");
    Text _.type := repInf::type;
  //WriteLn("TRACE [Connect] 3 _.type='"+_.type+"'");
    Text _.description := repInf::description;
  //WriteLn("TRACE [Connect] 4 _.description='"+_.description+"'");
    Text aux = GetFileContent("index.csv");
  //WriteLn("TRACE [Connect] 5 aux=\n"+aux+"\n");
    Set line = Tokenizer(aux,"\n");
  //WriteLn("TRACE [Connect] 6 Card(line)=\n"<<Card(line)+"\n");
    Set cells.all = For(2,Card(line), Set(Real k)
    {
    //WriteLn("TRACE Connect line["<<k+"] = '"<<line[k]+"'");
      Set fields = Tokenizer(line[k],";");
    //WriteLn("TRACE Connect Card(fields) = "<<Card(fields));
      fields
    });
  //WriteLn("TRACE [Connect] 7 Card(cells.all)=\n"<<Card(cells.all)+"\n");
    Set cells = Select(cells.all, Real(Set s) { Card(s)==12 });
  //WriteLn("TRACE [Connect] 8 Card(cells)=\n"<<Card(cells)+"\n");
    Set pckInf = For(1,Card(cells), TolPackage::@PackageInfo(Real k)
    {
      Set fields = cells[k];
      Set aux = { [[ TolPackage::@PackageInfo(
        Text repository = fields[1],
        Text name = fields[2],
        Text name.version = fields[3],
        Real version.high = Eval(fields[4]),
        Real version.low = Eval(fields[5]),
        Text brief = fields[6],
        Set keys =  Eval(fields[7]),
        Set authors =  Eval(fields[8]),
        Text minTolVersion = fields[9],
        Date releaseDate = Eval(fields[10]),
        Set dependencies = Eval(fields[11]),
        Set  nonTolResources = Eval(fields[12])
      ) ]] };
      Set PutName(aux[1]->name.version,aux[1]);
      aux[1]
    });

    Set _.index := Sort(pckInf,
    Real(TolPackage::@PackageInfo a, TolPackage::@PackageInfo b)
    {
      Compare(b->name.version, a->name.version)
    });
    Real SetIndexByName(_.index);
    Real @Repository::MergePackages(_.index);
    Real @Repository::SaveInstances(0);
    Real numErr1 = Copy(NError);
    Real _.connected := And(numErr1==numErr0,Card(_.index));
    If(_.connected, WriteLn(" ... Connected!"), 
                    WriteLn(" ... NOT Connected!","W"));
    _.connected
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.ForceConnect.All = 
"Fuerza la conexión de todos los paquetes consultados";
Static Real ForceConnect.All(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  SetSum(EvalSet(_.instances,Real(@Repository r)
  {
    If(!IsUnknown(r::_.connected), False, r::Connect(0))
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Find = 
"Busca un paquete entre todos los repositorios consultables y, si lo "
"encuentra, devuelve el registro de información con estructura @PackageInfo, "
"y si no, el conjunto vacío.";
Static Set Find(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  Real @Repository::ForceConnect.All(0);
  Real pos = FindIndexByName(@Repository::_.allPackages,package.version);
  Set found = If(pos<=0, Copy(Empty), @Repository::_.allPackages[pos]);
  found
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Exist = 
"Devuelve cierto si existe el paquete especificado";
Real Exist(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  Real pos = FindIndexByName(_.index,package);
  pos > 0
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Install = 
"Instala desde el repositorio remoto al local un paquete determinado "
"para que esté disponible llamando a #Require. \n"
"Un repositorio remoto puede ser en realidad un directorio local para "
"facilitar proceso de instalación cerrada. Para ello la URL comenzará por "
"file:// seguido del path local donde se ubica el repositorio.\n"
"Si la URL empieza por http:// https:// ftp:// o cualquier otro protocolo"
"reconocible por el sistema operativo se realizará la correspondiente "
"descarga remota. \n"
"En un mismo repositorio local puede haber distintas veriones de un mismo "
"paquete que se distinguirán unas de otras por el texto posterior al "
"primer punto. Antes del punto el nombre del paquete ha de seguir la "
"nomenclatura tipo WIKI AaaBbb \n"
"Si no se especifica ninguna versión se instalará la última disponible "
"con una copia que especifique el nombre con versión y otra sin versión, "
"sólo con el nombre del paquete, de forma que el #Require funcione igual "
"tanto si se especifica la última versión como si no se especifica "
"ninguna. \n"
"Si ya existía una copia en el repositorio local será substituida sin "
"mayores contemplaciones por lo que el usuario debe saber lo que pide. \n"
"Sólo es necesario instalar una vez un paquete y todas las sesiones TOL "
"que se lancen desde ese momento podrán usarlos.";
Real Install(Text package.version, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE Client::Install");
  Real Connect(0);
  Real pos = FindIndexByName(_.index,package.version);
  If(pos<=0,
  {
    WriteLn("[TolPackage::Client::@Repository::Install] "
    "Package "+package.version+ " not found in repository "+_.url,"E");
    False
  },
  {
    Real ok = DownloadPackage(package.version);
    Case(
    ok,
    {
    //Text depend = TolPackage::Client::GetRequirements(
    //  _.index[pos]->dependencies);
    //Text dependFile = TolPackage::Client::LocalDepend(package.version);
    //Text WriteFile(dependFile, depend);
      WriteLn("[TolPackage::Client::@Repository::Install] "
      "Installed package "+package.version)
    },
    showError, 
    {
      WriteLn("[TolPackage::Client::@Repository::Install] "
      "Cannot install package "+package.version,"E")
    });     
    ok
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Install.All = 
"Instala la última versión de todos los paquetes disponibles en un "
"repositorio remoto.";
Real Install.All(Real void)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE Client::Install.All");
  Real Connect(0);
  SetMin(EvalSet(_.index, Real(TolPackage::@PackageInfo pi)
  {
    DownloadPackage(pi->name.version)
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Install.AllInAll = 
"Instala todos los paquetes disponibles en todos los repositorios remotos "
"consultados.";
Static Real Install.AllInAll(Real void)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE Client::Install.AllInAll");
  Real @Repository::ForceConnect.All(0);
  SetSum(EvalSet(@Repository::_.instances, Real(@Repository r)
  {
    r::Install.All(void)
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.FindAndInstall = 
"Busca un paquete entre todos los repositorios consultables y si lo "
"encuentra lo instala.";
Static Real FindAndInstall(Text package.version, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE @Repository::FindAndInstall(\""+repository+"\","<<showError+")");
  Set pkgInf = @Repository::Find(package.version);
//WriteLn("TRACE @Repository::FindAndInstall 1 Card(pkgInf)="<<Card(pkgInf));
  Case(
  Card(pkgInf)>0,
  { 
  //WriteLn("TRACE @Repository::FindAndInstall 2");
    @Repository r = @Repository::Get(pkgInf->repository, True);
    r::Install(pkgInf->name, showError)
  },
  showError,
  { 
  //WriteLn("TRACE @Repository::FindAndInstall 3");
    WriteLn("[TolPackage::Client::@Repository::FindAndInstall] "
    "Cannot find package "+package.version+" in available repositories","E");
    False
  },
  1==1,
  {
  //WriteLn("TRACE @Repository::FindAndInstall 4");
    False
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.ReleaseDate = 
"Devuelve la fecha de la última actualización de un paquete en un "
"repositorio";
Date ReleaseDate(Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Real Connect(0);
  Real pos = FindIndexByName(_.index,package);
  If(!pos, TheBegin,
  { 
    _.index[pos]->releaseDate
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Upgrade = 
"Actualiza automáticamente un paquete si ha caducado caduca la copia local "
"llamando a Install.";
Real Upgrade(Text package.version, Real caducityInMinutes)
//////////////////////////////////////////////////////////////////////////////
{
  Real Connect(0);
  Text localFile = TolPackage::Client::LocalOza(package.version);
  Date localDate = If(!FileExist(localFile), 
    y1900,
    FileTime(localFile));
  Date releaseDate = ReleaseDate(package.version);
  Real lapse = DateDif(S(0), localDate, releaseDate);
//WriteLn("TRACE localFile=" << localFile);
//WriteLn("TRACE Upgrade localDate=" << localDate);
//WriteLn("TRACE Upgrade releaseDate=" << releaseDate); 
//WriteLn("TRACE Upgrade lapse=" << lapse);
//WriteLn("TRACE Upgrade caducityInMinutes=" << caducityInMinutes);
  If(lapse<=caducityInMinutes, False, 
  {
    WriteLn("[TolPackage::Client::@Repository::Upgrade] "
    "Package "+package.version+" is obsolete or not found and will be "
    "upgraded","W");
    Install(package.version, False)
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Upgrade.All = 
"Actualiza automáticamente todos los paquetes disponibles en un repositorio "
"remoto para los que la copia local haya caducado.";
Real Upgrade.All(Real caducityInMinutes)
//////////////////////////////////////////////////////////////////////////////
{
  Real Connect(0);
  WriteLn("[TolPackage::Client::@Repository::Upgrade.All] "
  "Searching for obsolete packages at repository "+_.url);
  Real n = SetSum(EvalSet(_.index, Real(TolPackage::@PackageInfo pi)
  {
    Upgrade(pi->name.version, caducityInMinutes)
  }));
  WriteLn("[TolPackage::Client::@Repository::Upgrade.All] "<<n+
  " packages where upgraded from repository "+_.url);
  n
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Upgrade.AllInAll = 
"Actualiza automáticamente todos los paquetes disponibles en todos los "
"repositorios remotos consultados para los que la copia local haya caducado.";
Static Real Upgrade.AllInAll(Real caducityInMinutes)
//////////////////////////////////////////////////////////////////////////////
{
  Real @Repository::ForceConnect.All(0);
  SetSum(EvalSet(@Repository::_.instances, Real(@Repository r)
  {
    r::Upgrade.All(caducityInMinutes)
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Clean = "Elimina un paquete concreto.";
Real Clean(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  Text localFile = TolPackage::Client::LocalOza(package.version);
  If(!FileExist(localFile), False, OSFilRemove(localFile))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Clean.All = 
"Elimina todos los paquetes disponibles localmente procedentes del "
"repositorio.";
Real Clean.All(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  Real Connect(0);
  WriteLn("[TolPackage::Client::@Repository::Clean.All] "
  "Removing local packages from repository "+_.url);
  Real n = SetSum(EvalSet(_.index, Real(TolPackage::@PackageInfo pi)
  {
    Clean(pi->name.version)
  }));
  WriteLn("[TolPackage::Client::@Repository::Clean.All] "<<n+
  " packages where removed from repository "+_.url);
  n
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Clean.AllInAll = 
"Elimina todos los paquetes disponibles localmente.";
Static Real Clean.AllInAll(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  Real @Repository::ForceConnect.All(0);
  SetSum(EvalSet(@Repository::_.instances, Real(@Repository r)
  {
    r::Clean.All(0)
  }))
}

};


