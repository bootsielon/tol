/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : repository.tol
// PURPOSE: Class TolPackage::Client::@Repository
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Class @Repository {
//////////////////////////////////////////////////////////////////////////////

//Dirección del repositorio remoto.
//Un repositorio remoto puede ser en realidad un directorio local para 
//facilitar proceso de instalación cerrada. Para ello la URL comenzará por 
//file:// seguido del path local donde se ubica el repositorio.\n
//Si la URL empieza por http:// https:// o cualquier otro protocolo
//reconocible por el sistema operativo se realizará la correspondiente 
//descarga remota. 
Text _.url;

//Nombre oficial del repositorio;
Text _.name = "";
//Tipo del repositorio : "Private" ó "Public";
Text _.type = "";
//Descripción del repositorio;
Text _.description = "";
//Protocolo de acceso al repositorio file://, http://, ...
Text _.protocol = "";
//Resto de la URL tras el protocolo
Text _.address = "";
//Cierto si el protocolo no es file://
Real _.isRemote = ?;
//Archivo del estado actual de los paquetes del repositorio
Set _.index = Copy(Empty);
//Resultado de la conexión al repositorio remoto
Real _.connected = ?;
//Instancias de repositorios que han sido consultados durante la sesión de 
//TOL actual
Static Set _.instances = Copy(Empty);
//Listado de todos los paquetes disponibles en todos los repositorios 
//consultados hasta el momento.
//Los nombres de paquetes son únicos no sólo dentro de cada repositorio sino
//que no puede haber repositorios que compartan un mismo paquete
Static Set _.allPackages = Copy(Empty);

//////////////////////////////////////////////////////////////////////////////
//Carga la lista de repositorios accesibles
Static Real LoadInstances(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  If(!Card(_.instances),
  {
    Text file = TolPackage::Client::_.localRoot+"repositories.txt";
    WriteLn("[TolPackage::Client::@Repository::LoadInstances]\n"
            "Loading list of available repositories from "+file);
    NameBlock @Repository::Get(
      "http://packages.tol-project.org/OfficialTolArchiveNetwork/", False);
    Real If(FileExist(file),
    { 
      Set lines = Tokenizer(ReadFile(file),"\n");
      Set EvalSet(lines,Real ev_lines(Text line)
      {
        Text url = Compact(line);
        Case(
        url=="",False,
        url==" ",False,
        TextBeginWith(url, "//"),False,
        1==1,
        {
          NameBlock @Repository::Get(url, False);
          True
        })
      });
      True   
    })
  });
  Card(_.instances)
};

//////////////////////////////////////////////////////////////////////////////
//Guarda la lista de repositorios accesibles
Static Real SaveInstances(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  If(!Card(_.instances), False,
  {
    Text file = TolPackage::Client::_.localRoot+"repositories.txt";
    WriteLn("[TolPackage::Client::@Repository::SaveInstances]\n"
            "Saving list of available repositories to "+file);
    Text WriteFile(file,
    "//////////////////////////////////////////////////////////////////////////////\n"
    "//List of availables repositories of TOL packages\n"
    "//////////////////////////////////////////////////////////////////////////////\n"
    "\n"
    "//Official tol-project packages \n"
    "//This repository is very recommendable. Please don't remove next line\n"
    "//Type: Public\n"
    "  http://packages.tol-project.org/OfficialTolArchiveNetwork/\n"
    "\n"); 
    Set EvalSet(_.instances,Real(@Repository r)
    {
      Text If(r::_.url != "http://packages.tol-project.org/OfficialTolArchiveNetwork/",
      {
        AppendFile(file,
        "\n"
        "//"+r::_.name+" \n"
        "//"+Compact(r::_.description)+" \n"
        "//Type: "+r::_.type+"\n"
        "  "+r::_.url+"\n"
        "\n")
      });
      True   
    });
    True
  })
};

//////////////////////////////////////////////////////////////////////////////
//Devuelve la instancia de repositorio correspondiente a una URL. Si no había
//sido consultado previamente se conecta primero al repositorio remoto.
//Si hay cambios en el directorio remoto durante la sesión TOL estos no serán
//percibidos.
Static @Repository Get(Text url, Real connect)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE @Repository::Get(\""+url+"\","<<connect+")");
  Real pos = FindIndexByName(@Repository::_.instances, ToName(url));
//WriteLn("TRACE @Repository::Get 1 pos="<<pos);
  If(pos, 
  {
  //WriteLn("TRACE @Repository::Get 2");
    Real If(connect, (_.instances[pos])::Connect(0));
    _.instances[pos]
  },
  {
  //WriteLn("TRACE @Repository::Get 3");
    @Repository::Open(url, connect)
  })
};

//////////////////////////////////////////////////////////////////////////////
//Abre un repositorio por primera vez
Static @Repository Open(Text url, Real connect)
//////////////////////////////////////////////////////////////////////////////
{
  Real prtPos = TextFind(url,"://")+2;
  //Protocolo de acceso al repositorio file://, http://, https://, ftp://
  Text protocol = Sub(url,1,prtPos);
  //Resto de la URL tras el protocolo
  Text address =  Sub(url,prtPos+1,TextLength(url));
  Set aux = [[ @Repository new = [[
    Text _.url = url;
    Text _.protocol = protocol;
    Text _.address = address;
    Real _.isRemote =  protocol!="file://"  ]] ]];
  Real If(connect, new::Connect(0));
  NameBlock PutName(ToName(url), aux[1]);
  Set Append(@Repository::_.instances, aux, True);
  aux[1]
};

//////////////////////////////////////////////////////////////////////////////
//Devuelve el contenido de un fichero de texto ubicado en el repositorio
  Text GetFileContens(Text path)
//////////////////////////////////////////////////////////////////////////////
{
  If(!_.isRemote,
  {
    ReadFile(_.address+path)
  },
  {
    StdLib::GetUrlContents(_.url+path)
  })
};

//////////////////////////////////////////////////////////////////////////////
//Función de conexión al repositorio remoto 
Real Connect(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  If(Not(IsUnknown(_.connected)), _.connected,
  {
    WriteLn("[TolPackage::Client::@Repository::Connect] "
      "Trying to conect to repository "+_.url+" ...");
    Real numErr0 = Copy(NError);
    Set repInf = IncludeText(GetFileContens("index.tol"));
    Text _.name := repInf::name;
    Text _.type := repInf::type;
    Text _.description := repInf::description;
    Text aux = GetFileContens("index.csv");
    Set line = Tokenizer(aux,"\n");

    Set cells.all = For(2,Card(line), Set(Real k)
    {
    //WriteLn("TRACE Connect line["<<k+"] = '"<<line[k]+"'");
      Set fields = Tokenizer(line[k],";");
    //WriteLn("TRACE Connect Card(fields) = "<<Card(fields));
      fields
    });
    Set cells = Select(cells.all, Real(Set s) { Card(s)==11 });
    Set pckInf = For(1,Card(cells), TolPackage::@PackageInfo(Real k)
    {
      Set fields = cells[k];
      Set aux = { [[ TolPackage::@PackageInfo(
        Text repository = fields[1],
        Text name = fields[2],
        Text name.version = fields[3],
        Real version.high = Eval(fields[4]),
        Real version.low = Eval(fields[5]),
        Text brief = fields[6],
        Set keys =  Eval(fields[7]),
        Set authors =  Eval(fields[8]),
        Text minTolVersion = fields[9],
        Date releaseDate = Eval(fields[10]),
        Set dependencies = Eval(fields[11])
      ) ]] };
      Set PutName(aux[1]->name.version,aux[1]);
      aux[1]
    });

    Set _.index := Sort(pckInf,
    Real(TolPackage::@PackageInfo a, TolPackage::@PackageInfo b)
    {
      Compare(b->name.version, a->name.version)
    });
    Real SetIndexByName(_.index);
    Set Append(_.allPackages,_.index, True);
    Set _.allPackages := Sort(_.allPackages,
    Real(TolPackage::@PackageInfo a, TolPackage::@PackageInfo b)
    {
      Compare(b->name.version, a->name.version)
    });
    Real numErr1 = Copy(NError);
    Real _.connected := And(numErr1==numErr0,Card(_.index));
    If(_.connected, WriteLn(" ... Connected!"), 
                    WriteLn(" ... NOT Connected!","W"));
    _.connected
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.ForceConnect.All = 
"Fuerza la conexión de todos los paquetes consultados";
Static Real ForceConnect.All(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  SetSum(EvalSet(_.instances,Real(@Repository r)
  {
    If(!IsUnknown(r::_.connected), False, r::Connect(0))
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Exist = 
"Devuelve cierto si existe el paquete especificado";
Real Exist(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  Real pos = FindIndexByName(_.index,package);
  pos > 0
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Find = 
"Busca un paquete entre todos los repositorios consultables y, si lo "
"encuentra, devuelve el registro de información con estructura @PackageInfo, "
"y si no, el conjunto vacío.";
Static Set Find(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  Real @Repository::ForceConnect.All(0);
  Real pos = FindIndexByName(_.allPackages,package.version);
  Set found = If(pos<=0, Copy(Empty), _.allPackages[pos]);
  found
};

//////////////////////////////////////////////////////////////////////////////
//Copia un fichero del repositorio remoto al directorio local de paquetes
  Real DownloadPackage(Text packageName)
//////////////////////////////////////////////////////////////////////////////
{
  Text localPath = TolPackage::Client::LocalFile(packageName);
  If(FileExist(localPath), OSFilRemove(localPath));
  If(!_.isRemote,
  {
    OSFilCopy(_.address+"packages/"+packageName+".oza",localPath)
  },
  {
    //Hay que buscar una forma de copiar remoto sin wget, con el TCL
    Text order = 
      "wget -O\""+localPath+"\" \""+ _.url+"packages/"+packageName+".oza\"";
    WriteLn("[TolPackage::Client::@Repository::DownloadPackage] \n"+order);
    Real ok = OSCmdWait(order);
    Real Sleep(.1);
    ok
  });
  FileExist(localPath)
};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Install = 
"Instala desde el repositorio remoto al local un paquete determinado "
"para que esté disponible llamando a #Require. \n"
"Un repositorio remoto puede ser en realidad un directorio local para "
"facilitar proceso de instalación cerrada. Para ello la URL comenzará por "
"file:// seguido del path local donde se ubica el repositorio.\n"
"Si la URL empieza por http:// https:// ftp:// o cualquier otro protocolo"
"reconocible por el sistema operativo se realizará la correspondiente "
"descarga remota. \n"
"En un mismo repositorio local puede haber distintas veriones de un mismo "
"paquete que se distinguirán unas de otras por el texto posterior al "
"primer punto. Antes del punto el nombre del paquete ha de seguir la "
"nomenclatura tipo WIKI AaaBbb \n"
"Si no se especifica ninguna versión se instalará la última disponible "
"con una copia que especifique el nombre con versión y otra sin versión, "
"sólo con el nombre del paquete, de forma que el #Require funcione igual "
"tanto si se especifica la última versión como si no se especifica "
"ninguna. \n"
"Si ya existía una copia en el repositorio local será substituida sin "
"mayores contemplaciones por lo que el usuario debe saber lo que pide. \n"
"Sólo es necesario instalar una vez un paquete y todas las sesiones TOL "
"que se lancen desde ese momento podrán usarlos.";
Real Install(Text package.version, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE Client::Install");
  Real Connect(0);
  Real DownloadPackage(package.version);
  Real ok = FileExist(LocalFile(package.version));
  Case(
  ok,
  {
    WriteLn("[TolPackage::Client::@Repository::Install] "
    "Installed package "+package.version)
  },
  showError, 
  {
    WriteLn("[TolPackage::Client::@Repository::Install] "
    "Cannot install package "+package.version,"E")
  });
  ok
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Install.All = 
"Instala la última versión de todos los paquetes disponibles en un "
"repositorio remoto.";
Real Install.All(Real void)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE Client::Install.All");
  Real Connect(0);
  SetMin(EvalSet(_.index, Real(TolPackage::@PackageInfo pi)
  {
    DownloadPackage(pi->name.version)
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Install.AllInAll = 
"Instala todos los paquetes disponibles en todos los repositorios remotos "
"consultados.";
Static Real Install.AllInAll(Real void)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE Client::Install.AllInAll");
  Real @Repository::ForceConnect.All(0);
  SetSum(EvalSet(@Repository::_.instances, Real(@Repository r)
  {
    r::Install.All(void)
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.FindAndInstall = 
"Busca un paquete entre todos los repositorios consultables y si lo "
"encuentra lo instala.";
Static Real FindAndInstall(Text package.version, Real showError)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE @Repository::FindAndInstall(\""+repository+"\","<<showError+")");
  Set pkgInf = @Repository::Find(package.version);
//WriteLn("TRACE @Repository::FindAndInstall 1 Card(pkgInf)="<<Card(pkgInf));
  Case(
  Card(pkgInf)>0,
  { 
  //WriteLn("TRACE @Repository::FindAndInstall 2");
    @Repository r = @Repository::Get(pkgInf->repository, True);
    r::Install(pkgInf->name, showError)
  },
  showError,
  { 
  //WriteLn("TRACE @Repository::FindAndInstall 3");
    WriteLn("[TolPackage::Client::@Repository::FindAndInstall] "
    "Cannot find package "+package.version+" in available repositories","E");
    False
  },
  1==1,
  {
  //WriteLn("TRACE @Repository::FindAndInstall 4");
    False
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.ReleaseDate = 
"Devuelve la fecha de la última actualización de un paquete en un "
"repositorio";
Date ReleaseDate(Text package)
//////////////////////////////////////////////////////////////////////////////
{
  Real Connect(0);
  Real pos = FindIndexByName(_.index,package);
  If(!pos, TheBegin,
  { 
    _.index[pos]->releaseDate
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Upgrade = 
"Actualiza automáticamente un paquete si ha caducado caduca la copia local "
"llamando a Install.";
Real Upgrade(Text package.version, Real caducityInDays)
//////////////////////////////////////////////////////////////////////////////
{
  Real Connect(0);
  Text localFile = TolPackage::Client::LocalFile(package.version);
  Date localDate = If(!FileExist(localFile), 
    y1900,
    FileTime(localFile));
  Date releaseDate = ReleaseDate(package.version);
  Real lapse = DateDif(Daily, localDate, releaseDate);
//WriteLn("TRACE Upgrade localDate=" << localDate);
//WriteLn("TRACE Upgrade releaseDate=" << releaseDate);
//WriteLn("TRACE Upgrade lapse=" << lapse);
//WriteLn("TRACE Upgrade caducityInDays=" << caducityInDays);
  If(lapse<=caducityInDays, False, 
  {
    WriteLn("[TolPackage::Client::@Repository::Upgrade] "
    "Package "+package.version+" is obsolete and will be upgraded","W");
    Install(package.version, False)
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Upgrade.All = 
"Actualiza automáticamente todos los paquetes disponibles en un repositorio "
"remoto para los que la copia local haya caducado.";
Real Upgrade.All(Real caducityInDays)
//////////////////////////////////////////////////////////////////////////////
{
  Real Connect(0);
  WriteLn("[TolPackage::Client::@Repository::Upgrade.All] "
  "Searching for obsolete packages at repository "+_.url);
  Real n = SetSum(EvalSet(_.index, Real(TolPackage::@PackageInfo pi)
  {
    Upgrade(pi->name.version, caducityInDays)
  }));
  WriteLn("[TolPackage::Client::@Repository::Upgrade.All] "<<n+
  " packages where upgraded from repository "+_.url);
  n
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Upgrade.AllInAll = 
"Actualiza automáticamente todos los paquetes disponibles en todos los "
"repositorios remotos consultados para los que la copia local haya caducado.";
Static Real Upgrade.AllInAll(Real caducityInDays)
//////////////////////////////////////////////////////////////////////////////
{
  Real @Repository::ForceConnect.All(0);
  SetSum(EvalSet(@Repository::_.instances, Real(@Repository r)
  {
    r::Upgrade.All(caducityInDays)
  }))
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.ForceExactRequirements = 
"Permite usar una versión de un paquete distinta de la última con #Require "
"asegurando la compatibilidad con el estado exacto de los paquetes de los "
"que depende el requerido y recursivamente los que dependen de ellos. \n"
"Lee en el repositorio remoto la lista de requerimientos para el paquete y " 
"hace los requires de las versiones exactas. \n"
"Hay que llamar a este método siempre antes de hacer ningún #Require de "
"cualquiera de los paquetes requeridos directa o indirectamente por lo que " 
"lo más aconsejable es hacerlo justo después de cargar la StdLib ";
Real ForceExactRequirements(Text package.version)
//////////////////////////////////////////////////////////////////////////////
{
  Real Connect(0);
  Real pos = FindIndexByName(_.index,package.version),
  If(!pos, False,
  { 
    TolPackage::DoRequirements(_.index[pos]->dependencies)
  })
}

};


