//////////////////////////////////////////////////////////////////////////////
// FILE    : _serie.tol
// PURPOSE : funciones de serie
//////////////////////////////////////////////////////////////////////////////
//Set Include("TextFun.Tol");
//Set Include("DateFun.Tol");

//////////////////////////////////////////////////////////////////////////////
  Real SerBuildTime(Serie ser, Real show)
//////////////////////////////////////////////////////////////////////////////
{
  Real t0 = Copy(Time);
  Real r  = CountS(ser);
  Real t  = Copy(Time)-t0;
  If(show,WriteLn("SerShowBuildTime("+Identify(ser)+")  -> "<<t+" seconds"));
  t
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
 "Devuelve el tiempo de construcción de una serie temporal forzando la "
 "evaluación efectiva de la misma. Si se especifica escribe una traza.",
 SerBuildTime);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie Normalize(Serie ser)
//////////////////////////////////////////////////////////////////////////////
{
  Real avr = AvrS(ser);
  Real std = StDsS(ser);
  (ser-avr)/std
};

////////////////////////////////////////////////////////////////////////////// 
   Serie DefSub(Serie s)
//
// PURPOSE: Returns the serie between the the default dates
//
////////////////////////////////////////////////////////////////////////////// 
{
  SubSer(s,DefFirst,DefLast)
};


//////////////////////////////////////////////////////////////////////////////
  Serie LevelTransf(Serie s) 
//////////////////////////////////////////////////////////////////////////////
{ 
  s/AvrS(s)
};


//////////////////////////////////////////////////////////////////////////////
  Serie StandardNormTransf(Serie s)
//////////////////////////////////////////////////////////////////////////////
{
  Real avr = AvrS(s);
  Real std = StDsS(s);
  (s-avr)/std
};


//////////////////////////////////////////////////////////////////////////////
  Serie UniformNormTransf(Serie s)
//////////////////////////////////////////////////////////////////////////////
{
  Real min = MinS(s);
  Real len = MaxS(s)-min;
  (s-min)/len
};


//////////////////////////////////////////////////////////////////////////////
  Serie LogTransf(Serie s)
//////////////////////////////////////////////////////////////////////////////
{
  Real min = MinS(s);
  Log(1+s-min)
};

//////////////////////////////////////////////////////////////////////////////
  Serie  BoxCoxTransform(Serie s, Real bct)
//////////////////////////////////////////////////////////////////////////////
{
  If(bct==1, s+0, If(bct==0, Log(s), s^bct))
};


//////////////////////////////////////////////////////////////////////////////
  Serie  BoxCoxInverseTransform(Serie s, Real bct)
//////////////////////////////////////////////////////////////////////////////
{
  Real invExp = 1/bct;
  If(bct==1, s+0, If(bct==0, Exp(s), s^invExp))
};

//////////////////////////////////////////////////////////////////////////////
  Serie AutoBoxCoxTransf(Serie s)
//////////////////////////////////////////////////////////////////////////////
{
  Real   bct    = BoxCoxTrans(s,BoxCoxOptions);
  BoxCoxTransform(s,bct)
};


//////////////////////////////////////////////////////////////////////////////
  Serie BoxCoxTransformation(Serie s, Real translation, Real exponent)
//////////////////////////////////////////////////////////////////////////////
{
  BoxCoxTransform(s + translation, exponent)
};


//////////////////////////////////////////////////////////////////////////////
  Serie Dif(Serie serie, Real periodicidad, Real orden)
//////////////////////////////////////////////////////////////////////////////
{
  ((1-B^periodicidad)^orden):serie
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"
Devuelve la serie diferenciada con el orden y la periodicidad dados. La serie
diferenciada con periodicidad p y orden 1 es el resultado de restar a cada
dato de la serie el dato ocurrido p fechas antes. Si el orden es n>1 indica
que se ha de repetir la operación n veces. Si el orden o la periodicidad son
cero se devuelve la serie original.
"
,Dif);
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
  Serie Acum(Serie serie, Real periodicidad, Real orden)
//////////////////////////////////////////////////////////////////////////////
{
  DifEq(1/((1-B^periodicidad)^orden),serie,0)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"
Devuelve la serie acumulada con el orden y la periodicidad dados. La serie
acumulada con periodicidad p y orden 1 es el resultado de sumar a cada
dato de la serie el dato ocurrido p fechas antes. Si el orden es n>1 indica
que se ha de repetir la operación n veces. Si el orden o la periodicidad son
cero se devuelve la serie original.
"
,Dif);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
  Serie IDelta(Serie Ser)
//////////////////////////////////////////////////////////////////////////////
{
  DifEq(1/(1-B), Ser, 0)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Calcula la serie resultado de sumar para cada fecha su valor mas los de las
fechas anteriores.",
Code IDelta);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie ExtendSer(Serie s)
//////////////////////////////////////////////////////////////////////////////
{
 Serie zero = CalInd(W,Dating(s));  
 zero<<s>>zero
};
PutDescription("
Extiende con ceros por la derecha y por la izda una serie.",ExtendSer);

//////////////////////////////////////////////////////////////////////////////
Serie DatChExtendSer(Serie ser,Text dating, Code stat)
//////////////////////////////////////////////////////////////////////////////
{
  ExtendSer(DatCh(InvCh(ser,CalInd(W,Diario)),Eval("TimeSet "+dating+";"),stat))
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Extiende con ceros una serie tras cambiarla de fechado 
con stat",DatChExtendSer);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie ExtendSerie(Serie ser, Date fecIni, Date fecFin)
//////////////////////////////////////////////////////////////////////////////
{
  Serie subNula  = SubSer(CalInd(W, Dating(ser)), fecIni, fecFin);

  Date fecIniSer = First(ser);
  Real extendIni = fecIniSer > fecIni;

  Date fecFinSer = Last(ser);
  Real extendFin = fecFinSer < fecFin;

  Serie serCon = If(And(extendIni, extendFin),
                    subNula << ser >> subNula,
                    If(extendIni,
                       subNula << ser,
                       If(extendFin, ser >> subNula, ser)));
  serCon
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Annade ceros a una serie entre dos fechas si lo necesita.",
ExtendSerie);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Serie ExtendSerSub(Serie s, Date ini, Date end)
//////////////////////////////////////////////////////////////////////////////
{ ExtendSerie(s, ini, end) };
//////////////////////////////////////////////////////////////////////////////
PutDescription("Función en desuso (DEPRECATED). Usar la función ExtendSerie.",
ExtendSerSub);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie SubSerExtend(Serie s, Date ini, Date end)
//////////////////////////////////////////////////////////////////////////////
{ SubSer(ExtendSerie(s, ini, end),ini, end) };
//////////////////////////////////////////////////////////////////////////////
PutDescription("Extiende con ceros por la derecha y por la izquierda una 
serie y recorta segun las fechas. ",
SubSerExtend);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
   Serie SerTrasTms(Serie ser, TimeSet ctTras, Real perTras)

// PURPOSE: Traslada los datos de ser que pertenecen al conjunto ctTras tanto
//          periodos como indica perTras (negativo para adelantar)
//          
//////////////////////////////////////////////////////////////////////////////
{
  Polyn tr      = If(GT(perTras,0),B^(perTras),F^Abs(perTras));

  Serie indTras = CalInd(ctTras,Dating(ser));
  Serie serTras = ((tr:(indTras*ser) + ser)*Not(indTras))>>ser;

  serTras    
};

//////////////////////////////////////////////////////////////////////////////
Serie LastMax(Serie ser)
//////////////////////////////////////////////////////////////////////////////
{
  bser = ser<<(B:ser);
  If(SumS(LT(ser,bser)), 
     Serie beta =
     {
       LastMax(Max(ser,bser))
     },
     ser     )
};
//////////////////////////////////////////////////////////////////////////////
 Serie FormaTrendCompens(TimeSet indTrend, TimeSet compens, Real gr,
                         TimeSet fdo, Date iniDate, TimeSet tmsOut)
//////////////////////////////////////////////////////////////////////////////
{
   Set   datTr    = Dates(indTrend,y1999,y2000);
   Real  numDatTr = Card(datTr);
   Set   datCm    = Dates(compens,y1999,y2000);
   Real  numDatCm = Card(datCm);

   Serie ind   = SubSer(CalInd(indTrend,fdo),iniDate,y2010);
   Serie acum  = DifEq(1/(1-B),ind) / numDatTr;

   Serie indC  = SubSer(CalInd(compens,fdo),iniDate,y2010);
   Serie acumC = DifEq(1/(1-B),indC) / numDatCm;

   Serie formaDia = IfSer((acum - acumC), (acum - acumC)^gr,0);
   Text tmsOutTxt = Tms2Txt(tmsOut);
  
   Serie Forma = If(tmsOutTxt == "Diario", formaDia,
   Eval("Serie DatCh(formaDia,"+tmsOutTxt+",SumS); "))
};

//////////////////////////////////////////////////////////////////////////////
 Serie TrendAcumUnit(TimeSet indTrend, 
                     Date iniDate, 
                     Date finDate)
//
//
///////////////////////////////////////////////////////////////////////////////
{
 
  TimeSet fechadoInd = Succ(C-indTrend,1)*indTrend+
                       Succ(indTrend,1)*(C-indTrend);

  Serie   datTrSerf   = CalVar(Range(indTrend, 0, 1, indTrend) , fechadoInd);
  Serie   datTrSer    = InvChEx(datTrSerf, Diario);
  
  Serie ind   = SubSer(CalInd(indTrend,Diario),iniDate,finDate);
  Serie acum  = DifEq(1/(1-B),ind) / datTrSer;
  acum
};

//////////////////////////////////////////////////////////////////////////////
 Serie TrendAcumUnitSer(Serie serInd, 
                        Date iniDate, 
                        Date finDate)
//
//
///////////////////////////////////////////////////////////////////////////////
{
 
  Serie serFechadoInd = Or(F:serInd,serInd)-serInd;   

  Serie datTrSerf = DatCh(serInd, SerTms(serFechadoInd), SumS);

  Real  dmax = 2*MaxS(datTrSerf);

  Serie fSus = dmax*CalInd(C,Diario);

  Serie iser = InvCh(datTrSerf,fSus);

  Serie subIser = 
   SubSer(iser, Succ(iniDate,Anual, -1), Succ(finDate, Anual, 1));

  Serie datTrSer = Expand(subIser,dmax);

  Serie ind   = SubSer(serInd,iniDate,finDate);

  Serie acum =  DifEq(1/(1-B),ind/datTrSer);

  acum
};

//////////////////////////////////////////////////////////////////////////////
 Serie IndPerTrans(TimeSet iniPer, TimeSet finPer, Real lMax)
// Calcula el indicador de la interseccion de dos tramos de sentido contrario
// y de longitud lMax, que comienzan en los dias indicados por iniPer y finPer
// respectivamente.
///////////////////////////////////////////////////////////////////////////////
{
 Polyn bMax = Quotient((1-B^lMax)/(1-B));
 Polyn fMax = bMax*(F^(lMax-1));
 Serie indIni = bMax:CalInd(iniPer,Diario);
 Serie indFin = fMax:CalInd(finPer,Diario);
 indIni*indFin
};

/*
//////////////////////////////////////////////////////////////////////////////
 Serie FormaTrendCompensVarInt
   (TimeSet indTrend, TimeSet compens, Real gr, 
    Date iniDate, TimeSet tmsOut)
//////////////////////////////////////////////////////////////////////////////
{
  TimeSet fechadoInd = Succ(C-indTrend,1)*indTrend+
                       Succ(indTrend,1)*(C-indTrend);
  Serie   datTrSerf   = CalVar(indTrend, fechadoInd);
  Serie   datTrSer    = InvChEx(datTrSerf, Diario);  
  Serie ind   = SubSer(CalInd(indTrend,Diario),iniDate,y2004);
  Serie acum  = DifEq(1/(1-B),ind) / datTrSer;

Serie   datCmSer = CalVar(compens, Diario);

  Serie indC  = SubSer(CalInd(compens, Diario),iniDate,y2004);
  Serie acumC = DifEq(1/(1-B),indC) / datCmSer;

  Serie formaDia = IfSer((acum - acumC), (acum - acumC)^gr,0);
   Text tmsOutTxt = Tms2Txt(tmsOut);
  
   Serie Forma = If(tmsOutTxt == "Diario", formaDia,
   Eval("Serie DatCh(formaDia,"+tmsOutTxt+", SumS); "))
};
*/

//////////////////////////////////////////////////////////////////////////////
 Serie FormaTrendCompensAvrS(TimeSet indTrend, TimeSet compens, Real gr,
                         TimeSet fdo,    Date iniDate)
//////////////////////////////////////////////////////////////////////////////
{
   Set   datTr    = Dates(indTrend,y1999,y2000);
   Real  numDatTr = Card(datTr);
   Set   datCm    = Dates(compens,y1999,y2000);
   Real  numDatCm = Card(datCm);

   Serie ind   = SubSer(CalInd(indTrend,fdo),iniDate,y2004);
   Serie acum  = DifEq(1/(1-B),ind) / numDatTr;

   Serie indC  = SubSer(CalInd(compens,fdo),iniDate,y2004);
   Serie acumC = DifEq(1/(1-B),indC) / numDatCm;

   Serie formaDia = IfSer((acum - acumC), (acum - acumC)^gr,0);
   Serie FormaSem = DatCh(formaDia,Semanal,AvrS)
};



//////////////////////////////////////////////////////////////////////////////
 Serie TrendCompens(TimeSet indTrend, TimeSet compens, Real gr,
                    Date iniDate)
//////////////////////////////////////////////////////////////////////////////
{
   Set   datTr    = Dates(indTrend,y1999,y2000);
   Real  numDatTr = Card(datTr);
   Set   datCm    = Dates(compens,y1999,y2000);
   Real  numDatCm = Card(datCm);

   Serie ind   = SubSer(CalInd(indTrend,Diario),iniDate,y2010);
   Serie acum  = DifEq(1/(1-B),ind) / numDatTr;

   Serie indC  = SubSer(CalInd(compens,Diario),iniDate,y2010);
   Serie acumC = DifEq(1/(1-B),indC) / numDatCm;

   Serie formaDia = IfSer((acum - acumC), (acum - acumC)^gr,0);
   Serie FormaSem = DatCh(formaDia,Semanal,SumS)
};


//////////////////////////////////////////////////////////////////////////////
 Serie IntervalTrend(TimeSet indTrend, TimeSet fdo, Date iniDate)
//////////////////////////////////////////////////////////////////////////////
{
   Serie ind   = SubSer(CalInd(indTrend,fdo),iniDate,y2010);
   Serie acum  = DifEq(1/(1-B),ind);

   TimeSet int = Succ(indTrend,1) - indTrend;
   Serie   fin = DatCh(acum, int, FirstS);

   Serie sust  = InvCh(fin,CalInd(W,fdo));
   Serie resta = Expand(sust);
   Serie IntTrend = acum - resta;
   Serie IntTrend 
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Devuelve la serie en el fechado fdo con una tendencia en el intervalo 
indTrend. Fuera de indTrend vale 0. iniDate es la fecha de inicializacion.",
IntervalTrend);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie IntervalTrendDec01(TimeSet indTrend, TimeSet fdo, Date iniDate, Date finDate)
//////////////////////////////////////////////////////////////////////////////
{
   Serie ind   = SubSer(CalInd(indTrend,fdo),iniDate,finDate);
   Serie acum  = DifEq(1/(1-B),ind);

   TimeSet int = Succ(indTrend,1,fdo) - indTrend;
   Serie   fin = DatCh(acum, int, FirstS);

   Serie sust  = InvCh(fin,CalInd(W,fdo));
   Serie resta = Expand(sust);
   Serie IntTrend = acum - resta;

   TimeSet tms1 = Succ((C-indTrend)*fdo, 1, fdo)*indTrend;
   Serie d = DatCh(ind, tms1, SumS);
   Serie g = Expand(InvCh(d,CalInd(W,fdo)));
   Serie res = (g*ind-IntTrend+ind)/g 
};

//////////////////////////////////////////////////////////////////////////////
Serie IntervalTrend01(TimeSet indTrend, TimeSet fdo, Date iniDate, Date finDate)
//////////////////////////////////////////////////////////////////////////////
{
   Serie ind   = SubSer(CalInd(indTrend,fdo),iniDate,finDate);
   Serie acum  = DifEq(1/(1-B),ind);

   TimeSet int = Succ(indTrend,1,fdo) - indTrend;
   Serie   fin = DatCh(acum, int, FirstS);

   Serie sust  = InvCh(fin,CalInd(W,fdo));
   Serie resta = Expand(sust);
   Serie IntTrend = acum - resta;

   TimeSet tms1 = Succ((C-indTrend)*fdo, 1, fdo)*indTrend;
   Serie d = DatCh(ind, tms1, SumS);
   Serie g = Expand(InvCh(d,CalInd(W,fdo)));
   Serie res = (IntTrend)/g 
};
//////////////////////////////////////////////////////////////////////////////
 Serie IntervalTrendOK(TimeSet indTrend, TimeSet fdo, Date iniDate)
//////////////////////////////////////////////////////////////////////////////
{
   Serie ind   = SubSer(CalInd(indTrend,fdo),iniDate,y2010);
   Serie acum  = DifEq(1/(1-B),ind);

   TimeSet int = Succ(indTrend,1,fdo) - indTrend;
   Serie   fin = DatCh(acum, int, FirstS);

   Serie sust  = InvCh(fin,CalInd(W,fdo));
   Serie resta = Expand(sust);
   Serie IntTrend = acum - resta;
   Serie IntTrend 
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Devuelve la serie en el fechado fdo con una tendencia en el intervalo 
indTrend. Fuera de indTrend vale 0. iniDate es la fecha de inicializacion.",
IntervalTrend);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
Serie IntervalTrendSer(Serie ind)
//////////////////////////////////////////////////////////////////////////////
{
  Serie acum    = DifEq(1/(1-B), ind);
  Serie indres  = (B:ind)*Not(ind);
  Serie acumres = acum*indres;
  Serie resta   = Expand(acumres,0);
  acum-resta
};

//////////////////////////////////////////////////////////////////////////////
  Serie SemCom(Serie ser)

// PURPOSE: Par transformar series en timeset diario en semanal pero 
//          solo cogiendo semanas enteras.
//////////////////////////////////////////////////////////////////////////////
{ 
  Date first = First(ser);
  Date last  = Last(ser);

  Date ini = If(Belong(first, WD(1)), first , Succ(first , WD(1), 1)); 
  Date fin = If(Belong(last , WD(7)), last  , Succ(last  , WD(7),-1)); 
  Serie serSem = DatCh(SubSer(ser, ini, fin), Semanal, SumS);
  serSem
//  Eval("Serie "+Name(ser)+".sem = serSem; ")
};



//////////////////////////////////////////////////////////////////////////////
  Serie SemComSab(Serie ser)

// PURPOSE: Par transformar series en timeset diario en semanal pero 
//          solo cogiendo semanas enteras.
//////////////////////////////////////////////////////////////////////////////
{ 
  Date first = First(ser);
  Date last  = Last(ser);
  TimeSet finSem = WD(5)+WD(6)+WD(7); //¡¡¡OJO!!!
  Date ini = If(Belong(first, WD(1)), first , Succ(first , WD(1), 1)); 
  Date fin = If(Belong(last , finSem), last  , Succ(last  ,finSem ,-1)); 
  Serie serSem = DatCh(SubSer(ser, ini, fin), Semanal, SumS);
  Eval("Serie "+Name(ser)+".sem = serSem; ")
};


//////////////////////////////////////////////////////////////////////////////
  Serie MenCom(Serie ser)

// PURPOSE: Par transformar series en timeset diario en mensual pero 
//          solo cogiendo meses enteros.
//////////////////////////////////////////////////////////////////////////////
{ 
  Date first     = First(ser);
  Date last      = Last(ser);
  TimeSet ultdia = Succ(D(1),-1);

  Date ini = If(Belong(first, D(1))  , first , Succ(first , D(1), 1)); 
  Date fin = If(Belong(last , ultdia), last  , Succ(last  , ultdia,-1)); 
  Serie serMen = DatCh(SubSer(ser, ini, fin), Mensual, SumS);
  serMen
//  Eval("Serie "+Name(ser)+".men = serSem; ")
};


/////////////////////////////////////////////////////////////////////////////
Serie LogC(Serie ser)

// PURPOSE : Evita ? por los 0 que tenga s
//////////////////////////////////////////////////////////////////////////////
{
  Serie max = IfSer(LE(ser,ser*0),MaxS(ser),ser);
  Serie min = IfSer(LE(ser,ser*0),AvrS(max),ser);
//  Set Table([[ max,min ]],"");

  Log(min)
};

//////////////////////////////////////////////////////////////////////////////
   Serie AutoDating(Serie s) 
//
// PURPOSE: Funcion para la eliminacion de los valores nulos de una serie.
//////////////////////////////////////////////////////////////////////////////
{ DatCh(s,SerTms(s),FirstS) };

////////////////////////////////////////////////////////////////////////////// 
Serie SerAnadir(Serie ser, Date fec1, Date fec2, Real r1, Real r2)
////////////////////////////////////////////////////////////////////////////// 
{
  Date fSer = First(ser);
  Date lSer = Last(ser);

  Serie r1Ser = CalInd(C, Dating(ser))*r1;
  Serie r2Ser = CalInd(C, Dating(ser))*r2;

  Serie left  = If(fec1 == TheBegin, r1Ser, 
   SubSer(r1Ser, Min(fec1, fSer), fSer));
  Serie right = If(fec2 == TheEnd, r2Ser, 
   SubSer(r2Ser, lSer, Max(fec2, lSer)));

  Serie serCon = Case
  (
    And(fSer == TheBegin, lSer == TheEnd), ser,
    And(fSer == TheBegin, lSer != TheEnd), ser >> right,
    And(fSer != TheBegin, lSer == TheEnd), left << ser,
    And(fSer != TheBegin, lSer != TheEnd), left << ser >> right,
    1,ser
  );    
  
 serCon
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Dada una serie la expande con r1 por detrás y con r2 por 
delante, entre las fechas del argumento, en el caso en que se necesite. Se 
utiliza cuando la serie argumento esta en fechado mensual.", 
SerAnadir);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
  Serie SubSerAnadirCeros(Serie ser,Date fecini, Date fecfin)
//
// PURPOSE: Aplica SerAnadir y Subser a una serie.
//////////////////////////////////////////////////////////////////////////////
{
  SerAnadir(ser,fecini,fecfin,0,0)
};


//////////////////////////////////////////////////////////////////////////////
   Serie ResTrunc(Serie ser, Real numSig) 
//
// PURPOSE: A partir de una serie y un real, la funcion ResTrunc devuelve la 
//          serie que toma valores en los dias que el residuo es mayor que un
//          numero de sigmas dado (numSig).
//////////////////////////////////////////////////////////////////////////////
{ 
  abs = Abs(ser);
  st  = StDsS(ser);
  coc = abs/st;
  GT(Abs(coc),numSig)*ser
};

//////////////////////////////////////////////////////////////////////////////
   Serie Extremos(Serie ser,Real numSig)
// 
// PURPOSE: Devuelve la serie de valores extremos mayores a numSig
//////////////////////////////////////////////////////////////////////////////
{
  Serie a = ResTrunc(ser,numSig);
  AutoDating(a)
};


//////////////////////////////////////////////////////////////////////////////
  Serie AcumulaSerieAn (Serie ser)

// PURPOSE : Devuelve la serie acumulada anual.
//////////////////////////////////////////////////////////////////////////////
{
   Serie acum  = DifEq(1/(1-B),ser);
   Serie SolDic = acum * CalInd(M(12),Dating(ser));
   Serie DicExp = Expand(SolDic);
   Serie Sust   = B:DicExp;
   Serie AcumuladaAnual = acum - Sust;
   AcumuladaAnual
};

//////////////////////////////////////////////////////////////////////////////
   Serie SetSumC(Set series)
//
// PURPOSE: Devuelve la serie Suma de un conjunto de series desde la menor
//          de las fechas a la mayor, cambiando los desconocidos(?) de las
//          series sumandos por 0.
//////////////////////////////////////////////////////////////////////////////
{
  Serie s = If(EQ(Card(series), 0), CalInd(W, C),
  {
    If(EQ(Card(series),1), series[1],
    {
      Date fs = SetMinDate(EvalSet(series,First));
      Date ls = SetMaxDate(EvalSet(series,Last ));
      SetSum(Set EvalSet(series,Serie(Serie ser) 
      { 
        Real SerBuildTime(ser,false);
        SubSerAnadirCeros(ser,fs,ls) 
      }))
    })
  });
  Real r = CountS(s);
  s
};

PutDescription(
 "Devuelve la suma se un conjunto de series desde la menor de las fechas a "
 "la mayor, expandiendo con ceros por delante y por detras las series no  "
 "definidas en todo el intervalo",SetSumC);

//////////////////////////////////////////////////////////////////////////////
   Serie SubFirstNotNull(Serie s)
// 
// PURPOSE: Nos da la serie s empezando la primera fecha de la serie que no
//          tome valor nulo, es decir, quita los ceros iniciales de una serie.
//////////////////////////////////////////////////////////////////////////////
{
  Date first = FirstNotEqual(s,First(s),0);
  Date last  = Last(s);
  Serie ser  = SubSer(s,first,last);
  ser
};
//////////////////////////////////////////////////////////////////////////////
   Serie Pot(Serie Ser1, Serie Ser2) 
//
// PURPOSE: A partir de dos series, la funcion Pot calcula el resultado de 
//          elevar la primera serie-argumento a la segunda serie-argumento.
//////////////////////////////////////////////////////////////////////////////
{
  Serie s1 = LE(Ser1,0);
  Serie s2 = GT(Ser1,0)*Ser1; 
  Serie s3 = s1+s2;
  Serie s4 = Ser2*Log(s3);
  Serie s5 = Exp(s4);
  s5 - EQ(s5,1)
}; 

//////////////////////////////////////////////////////////////////////////////
   Serie Normaliza01(Serie ser) 
//
// PURPOSE: Dada un serie, devuelve su serie normalizada, es decir, la serie   
//          que toma valores sobre el intervalo cerrado [0,1].
//////////////////////////////////////////////////////////////////////////////
{
  Real minSer = MinS(ser);
  Real maxSer = MaxS(ser);
  Serie  num  = (ser-minSer);
  Real   den  = 1/(Not(maxSer-minSer)+maxSer-minSer);
  num*den
};

//////////////////////////////////////////////////////////////////////////////
   Serie Normaliza(Serie ser, Date fec1, Date fec2)
//
// PURPOSE: Normaliza una serie tomando como valores de referencia el maximo
//          y el minimo dentro del intervalo marcado por las fechas fec1 y 
//          fec2. Hace cero los valores fuera del intervalo de normalizacion
//////////////////////////////////////////////////////////////////////////////
{
  Real minSer  = MinS(SubSer(ser,fec1,fec2));
  Real maxSer  = MaxS(SubSer(ser,fec1,fec2));
  TimeSet Int  = In(fec1,fec2);
  Serie IndInt = CalInd(Int,Diario);
  Serie  num   = (ser-minSer);
  Real   den   = 1/(Not(maxSer-minSer)+maxSer-minSer);
  den*num*IndInt
};


//////////////////////////////////////////////////////////////////////////////
  Serie LastM(Serie s, Real m)
//////////////////////////////////////////////////////////////////////////////
{ 
  Date last  = Last(s);
  Date first = Succ(last, Dating(s), -m+1);
  SubSer(s, first, last) 
};

//////////////////////////////////////////////////////////////////////////////
   Serie SerIsKnown(Serie ser, Date ini, Date end)

// PURPOSE : Retorna una serie entre las fechas ini y end que vale:
//           - Cero cuando el valor de ser es desconocido (?).
//           - Y uno cuando el valor de ser es conocido.
//////////////////////////////////////////////////////////////////////////////
{ Not(SubSer(ser-ser, ini, end)) };

//////////////////////////////////////////////////////////////////////////////
   Serie SerIsUnknown (Serie ser)
//
// PURPOSE: Determine the serie unknown values. 
//////////////////////////////////////////////////////////////////////////////
{
  Serie xgt   = GT(ser,0);
  Serie xle   = LE(ser,0);
  Serie xand  = And(xgt,xle);
  Not(Not(xand))
};

//////////////////////////////////////////////////////////////////////////////
   Serie OmitToZero(Serie ser)
//
// PORPUSE: Sustituye los valores desconocidos e interiores de una serie por
//          ceros !!Att!! el diseño de la funcion considera que la funcion
//          SerTms devuelve un conjunto que contiene todos los valores
//          no cero de la serie.
//          Actualmente esto no es así, pero la función no esta 
//          afectada por el comportamiento de SerTms.
//////////////////////////////////////////////////////////////////////////////
{
  IfSer(IsUnknown(ser), 0, ser)
/*
  Serie SrUnknown = SerIsUnknown(ser);
  Real hayUnknown = SumS(SrUnknown);
  Serie result = If(EQ(hayUnknown,0), ser,
  {
    Serie   ser1  = Not(SrUnknown);
    TimeSet known = SerTms(ser1);
    Serie   ser2  = DatCh(ser,known,FirstS);
    SubSer(InvCh(ser2,CalInd(W,Diario)), First(ser2), Last(ser2))
  })
*/ 
};

//////////////////////////////////////////////////////////////////////////////
   Serie CleanExtremeOmit(Serie ser)
//
// PORPUSE: Devuelve la serie sin valores omitidos
//////////////////////////////////////////////////////////////////////////////
{
  Serie known = Not(SerIsUnknown(ser));
  Date  ini   = NotNulN(known,1);
  Date  fin   = NotNulN(known,-1);
  SubSer(ser,ini,fin)
};

//////////////////////////////////////////////////////////////////////////////
   Serie FindSerie(Text nombre)
//
// PURPOSE: Busca una serie y la retorna, si no la encuentra emite un mensaje
//          de error.
//////////////////////////////////////////////////////////////////////////////
{
  Text error="Serie "+nombre+": NO EXISTE";
  Set If(Not(ObjectExist("Serie",nombre)),View(SetOfText(error),""));
  Serie result = Find(nombre);
  result
};

//////////////////////////////////////////////////////////////////////////////
  Serie ValorMedioEnDia(Serie ser, Date dia, TimeSet fdo)

// PURPOSE : Devuelve la serie cambiando el dato de dia por el Valor Medio 
//           del anterior y posterior a dia truncado (floor).
//           Si la fecha no es correcta devuelve ser y un mensaje de error.
//////////////////////////////////////////////////////////////////////////////
{
  Serie vmed = (F+B):ser/2;
  If(And(dia > First(ser), dia < Last(ser)),
     {
       Real vmedfl =Floor(SerDat(vmed,dia));
       ser*Not(CalInd(dia,fdo)) + CalInd(dia,fdo)*vmedfl
     },
     {
       Text mensaje =
        If(
           dia == First(ser),
           "Warning: "+ Name(ser)+"
            NO SE PUEDE DAR EL VALOR MEDIO, "+FormatDate(dia)+NL+
            " ES EL PRIMER DATO DE LA SERIE." ,
           If(
              dia == Last(ser),
              "Warning: "+ Name(ser)+"
               NO SE PUEDE DAR EL VALOR MEDIO, "+FormatDate(dia)+NL+
               " ES EL ULTIMO DATO DE LA SERIE.",
              "Warning: "+ Name(ser)+"
               LA SERIE NO ESTA DEFINIDA PARA ESA FECHA."
             )
          );
       WriteLn(mensaje);
       ser  
     }
    ) 
};

//////////////////////////////////////////////////////////////////////////////
   Serie MM(Serie ser, Real orden)
//
// Calcula la media movil de orden m de una serie
//////////////////////////////////////////////////////////////////////////////
{
  Polyn num = 1-B^orden;
  Polyn den = 1-B;
  Ration nd = num/den;
  Polyn fil = Quotient(nd)/orden;
  fil:ser
};

//////////////////////////////////////////////////////////////////////////////
  Serie SetSer (Set datos, Date ini, TimeSet fechado)
//
// PURPOSE : Dado un conjunto de reales <datos> y un <fechado> devuelve la 
//           serie resultado de esos reales en ese fechado, a partir del día 
//           de inicio <ini>.
//
//////////////////////////////////////////////////////////////////////////////
{
//Text WriteLn("Tiempo 3 "+Time); 
  Matrix coef  = GetNumeric(datos);
//Text WriteLn("Tiempo 4. GetNumeric SetSer "+Time); 
  Polyn pol    = MatPol(coef);
//Text WriteLn("Tiempo 5. MatPol SetSer "+Time); 
  Serie result = pol:Pulse(ini,fechado);
//Text WriteLn("Tiempo 6. pol: "+Time); 
  Date LastDay = Succ(ini,fechado,Card(datos)-1);
//Text WriteLn("Tiempo 7 "+Time); 
  SubSer(result,ini,LastDay)
//  Set s = MatSerSet(coef,fechado,ini);
//  s[1]
}; 

PutDescription("Serie SetSer (Set datos, Date ini, TimeSet fechado):\n"
"Dado un conjunto de reales <datos> y un <fechado> devuelve la serie " 
"resultado de esos reales en ese fechado, a partir del día de "
"inicio <ini>.",SetSer);

//////////////////////////////////////////////////////////////////////////////
  Serie SetSerDat (Set datos, Date ini, TimeSet fechado)
//
// PURPOSE : Dado un conjunto de reales <datos> y un <fechado> devuelve la 
//           serie resultado de esos reales en ese fechado, a partir del día 
//           de inicio <ini>. En caso de que <ini> no pertenezca al <fechado>,
//           el primer valor es atribuido a <ini_fec> talque <ini_fec> es 
//           la primera fecha mayor a <ini> en el <fechado>.
//////////////////////////////////////////////////////////////////////////////
{
  Real inDat = Belong(ini, fechado);
  Real If(inDat==0, 
     PutWarning(FormatDate(ini)+" does not belong to " + Name(fechado), 0),
     0);
  Date ini_fec = If(inDat, ini, Succ(ini, fechado));
  Serie SetSer(datos, ini_fec, fechado)
}; 

PutDescription("Serie SetSerDat (Set datos, Date ini, TimeSet fechado):\n"
"Dado un conjunto de reales <datos> y un <fechado> devuelve la serie " 
"resultado de esos reales en ese fechado, a partir del día "
"de inicio <ini>. En caso de que <ini> no pertenezca al <fechado> "
"el primer valor es atribuido a <ini_fec> talque <ini_fec> es "
"la primera fecha mayor a <ini> en el <fechado>",SetSerDat);

//////////////////////////////////////////////////////////////////////////////
   Real SerCorr(Serie s1,Serie s2)
//
// PURPOSE : Devuelve el coeficiente de correlacion entre dos series
//////////////////////////////////////////////////////////////////////////////
{
 Real cov = AvrS(s1*s2)-AvrS(s1)*AvrS(s2);
 Real d1  = SqRt( AvrS(s1^2)-AvrS(s1)^2 );
 Real d2  = SqRt( AvrS(s2^2)-AvrS(s2)^2 );
 cov/(d1*d2)
};


//////////////////////////////////////////////////////////////////////////////
   Set SetSerCorr(Set s)
//
// PURPOSE : Devuelve un conjunto de conjuntos que contienen los coeficientes 
//           de correlaciones entre las distintas series
//////////////////////////////////////////////////////////////////////////////
{
 For(1,Card(s), Set(Real i)
                { For(1,Card(s), Real(Real j)
                                 { If(GE(j,i),SerCorr( s[i],s[j] ),0) } 
                     )     
                }
    ) 
};                   

//////////////////////////////////////////////////////////////////////////////                            
   Matrix SetSerMatCorr(Set s)
//
// PURPOSE : Devuelve la matriz de correlaciones entre series
//////////////////////////////////////////////////////////////////////////////
{
 Matrix m = SetMat(SetSerCorr(s));
 m+Tra(m)-Diag(Card(s),1)
};

//////////////////////////////////////////////////////////////////////////////
  Serie InvChEx(Serie ser, TimeSet dtn)
//
// PURPOSE: Hace el cambio de fechado inverso de la serie ser a dtn rellenando 
//          las nuevas fechas de la serie con el valor que toma ser 
//          en la fecha  que hereda valor directamente.
//////////////////////////////////////////////////////////////////////////////
{
//  Text tms2Txt = Tms2Txt(dtn);
  Real  dmax = 2*MaxS(ser);
  Serie fSus = CalInd(C,dtn)*dmax;
  Serie iser = InvCh(ser,fSus);
  Serie expand  = Expand(iser,dmax);
  expand
};

//////////////////////////////////////////////////////////////////////////////
  Serie InterpolaL(Serie ser, TimeSet dtn)
//
// PURPOSE: Interpola la serie ser en el fechado armonico dtn linealmente
//////////////////////////////////////////////////////////////////////////////
{
  Interpolate::Scalar::invCh(ser,dtn,"LinearSpline",1)
};


//////////////////////////////////////////////////////////////////////////////
Serie TrasladaAOrigen(Serie ser, Date origen)

// PURPOSE: Traslada la serie ser al origen.
//////////////////////////////////////////////////////////////////////////////
{
  Date fs = First(ser);
  Text opr = If(origen<fs, "F","B");
  Real degF = If(origen>fs,DateDif( Dating(ser), fs, origen),
                 DateDif( Dating(ser), origen, fs));
  Eval("Serie "+Name(ser)+"Tras = ("+opr+"^(degF)):ser;")
};

//////////////////////////////////////////////////////////////////////////////
Serie IndAnuTra(Date last)

//////////////////////////////////////////////////////////////////////////////
{
 Real year = Year(last);
 Real month = Month(last);
 Real day   = Day(last);
 TimeSet mes = Eval("M("+FormatReal(month,"%.0lf")+")");
 TimeSet dia = Eval("D("+FormatReal(day,"%.0lf")+")");
 TimeSet lsup = mes*dia;
 Date fyear   = YMD(year,1,1);
 Real num = DateDif(Diario,fyear,last);
 TimeSet anuPar = Range(M(1)*D(1),0,num-1)+Range(lsup,-num+1,0);
 CalInd(anuPar,Diario)
};

//////////////////////////////////////////////////////////////////////////////
Serie IntervalTrendSerNorm(Serie indExt, Date ini, Date end)
//////////////////////////////////////////////////////////////////////////////
{
  Text txtTms = DatingName(indExt);
  Serie calZero = CalInd(W, Eval("TimeSet "+txtTms+"; "));
  Serie ind = SubSer(calZero<<(indExt>>calZero), ini, end);
  Serie serFechadoInd = Or(F:ind,ind)-ind;   
  Serie datTrSerf     = DatCh(ind, SerTms(serFechadoInd), SumS);
  Serie invDatTrSerf = InvChEx(datTrSerf, Eval("TimeSet "+txtTms+"; "));
  Serie notInvDatTrSerf = Not(invDatTrSerf);
  Serie iser = invDatTrSerf + notInvDatTrSerf;
  Serie coc = SubSer(ind/iser, ini, end);
  Serie acum  = DifEq(1/(1-B),coc);
  Serie indres = (B:ind)*Not(ind);
  Serie acumres = acum*indres;
  Serie resta   = Expand(acumres, 0);
  acum-resta
};
//////////////////////////////////////////////////////////////////////////////
Serie MoveSer(Serie ser, Real grade)
//////////////////////////////////////////////////////////////////////////////
{
  Case
  (
    GT(grade, 0), (B^grade):ser,
    EQ(grade, 0), ser,
    LT(grade, 0), (F^Abs(grade)):ser
  )
};

//////////////////////////////////////////////////////////////////////////////
Serie MoveSerWD(Serie ser, TimeSet wd, Real grade)
//////////////////////////////////////////////////////////////////////////////
{ MoveSer(CalInd(wd, Dating(ser))*ser, grade) };

//////////////////////////////////////////////////////////////////////////////
Serie LonIndicate(Serie indSer)
//////////////////////////////////////////////////////////////////////////////
{
  Serie marker        = Not(Not((1+F):indSer))-indSer;
  Serie count         = DatCh(indSer, SerTms(marker), SumS);
  Serie expCount      = InvChEx(count, Diario);
  Serie expCountInInd = indSer*expCount;
  expCountInInd
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Calcula la longitud de un indicador en cada tramo y devuelve la serie que 
en cada punto del indicador tiene dicha longitud.",
LonIndicate);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie SubExpand(Serie serInd, Date ini, Date end)
//////////////////////////////////////////////////////////////////////////////
{
  Serie subSer = SubSer(serInd, ini, end);
  Expand(subSer, 0)
};

//////////////////////////////////////////////////////////////////////////////
Set PriorMeanDev(Serie a, Serie b, Real minFirst, Real minInc)
//////////////////////////////////////////////////////////////////////////////
//
// Devuelve media y desviacion tipica de una distribución subjetiva de
// cierta prevision que se expresa consecutivamente en dos previsiones 
// distintas.
// Las variables son:
// Serie a: primera prevision
// Serie b: segunda prevision
// Real minFirst: desviacion tipica minina para la primera prevision
// Real minInc : incremento minimo de la desviacion tipica periodo a periodo
//
// Se supone que las series a y b tienen identica media. Su desviacion
// tipica es, sin embargo, creciente con un incremento minimo, minInc.
// Asimismo se supone que existe una desviacion tipica inicial minima.
//
// Dadas las series a y b se obtiene el estimador insesgado de la media y
// la varianza de expresion subjetiva.
//////////////////////////////////////////////////////////////////////////////
{
 TimeSet dtn = Dating(a);
 Date inia = First(a);
 Date inib = First(b);

 Date enda = Last(a);
 Date endb = Last(b);

 Date iniDate = Min(inia, inib);
 Date finDate = Max(enda, endb);

 Serie zero = CalInd(W, dtn);
 Serie ab = 
  SubSer
  (
    IfSer(CalInd(In(inia, enda), dtn), zero<<a>>zero, zero<<b>>zero), 
    iniDate, 
    finDate
  );
 Serie ba = 
  SubSer
  (
    IfSer(CalInd(In(inib, endb), dtn), zero<<b>>zero, zero<<a>>zero), 
    iniDate, 
    finDate
  );


// Serie ab    = a>>b;
// Serie ba    = a<<b;

 Serie mu    = (ab+ba)/2;
 Serie desMin = SqRt((ab-mu)^2+(ba-mu)^2);

 Serie desSub = LastMax(desMin);


 Serie incNor = SubSer(minInc*CalInd(C,dtn),Succ(iniDate,dtn),finDate);
 Serie desNor = DifEq(1/(1-B),incNor,minFirst);
 Serie desMax = Max(desNor,desSub);

 SetOfSerie(mu,desMax)
};

//////////////////////////////////////////////////////////////////////////////
Serie GetEffect(Text effect, Set inputEstim)
//////////////////////////////////////////////////////////////////////////////
{
  Set inpSel = Select(inputEstim, Real(Set reg)
  { 
    Text nameInp = Name(reg->X);
    GT(TextFind(nameInp, effect), 0)
  });
  Serie effectSer = If(IsEmpty(inpSel),
  {
    Text WriteLn("The effect "+effect+" does not exist.");
    Serie nullSer = CalInd(C, Diario);
    nullSer
  },
  {
    GroupInputs(inpSel)
  });
  effectSer 
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Reorna el efecto agrupado de un conjunto con estructura inputDef.",
GetEffect);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie GetSetInputEffect(Set setInputEffects, Set effects)
//////////////////////////////////////////////////////////////////////////////
{
  Set inpSel = Select(effects, Real(Serie ser)
  { 
    Text nameEffect = Name(ser);
    FindSetPattern(setInputEffects, nameEffect)
  });
  Serie effectSer = If(IsEmpty(inpSel),
  {
    Text WriteLn("[GetSetInputEffect]: No encontrado ningun efecto");
    Serie nullSer = CalInd(W, Diario);
    nullSer
  },
  {
    SetSum(inpSel)
  });
  effectSer
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Retorna la serie resultado de agrupar los efectos que se encuentran en 
el conjunto de nombres de setInputEffects y le da el nombre nameSetInput .",
GetSetInputEffect);
//////////////////////////////////////////////////////////////////////////////


Serie GroupInputsEx(Set input)
{
  Set inputEx = EvalSet(input, Serie(Set reg)
  {
    Serie inputVar = reg->X;
    Polyn omega    = reg->Omega;
    Serie effect   = omega:inputVar;
    CalInd(W, Dating(inputVar))<<(effect>>CalInd(W, Dating(inputVar)))
  });
  SetSum(inputEx)
};

//////////////////////////////////////////////////////////////////////////////
//Funcion de creación de series para el interfaz
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie CreaPulso(TimeSet fechado, Date dt)
//////////////////////////////////////////////////////////////////////////////
{
  Serie pul = Pulse(dt ,fechado)
};

//////////////////////////////////////////////////////////////////////////////
Serie CreaRampa(TimeSet fechado, Date dt1, Date dt2)
//////////////////////////////////////////////////////////////////////////////
{
  Serie If(dt2 == TheEnd, Trend(dt1, fechado),
  {
    Real  dif     = DateDif(fechado, dt1, dt2)+1;
    Serie ser     = SubSer(Trend(dt1, fechado), dt1, dt2);
    Serie serNorm = ser/dif;
     CalInd(W,fechado) << serNorm >> CalInd(W,fechado)
  })
};

//////////////////////////////////////////////////////////////////////////////
Serie TrendMinMax(Date fecIni, Date fecFin, Real iniVal,
                  Real finVal, TimeSet fdo)
//////////////////////////////////////////////////////////////////////////////
{
  If(fecIni >= fecFin , CalInd(W,fdo),
  { 
    Real  lon  = DateDif(fdo,fecIni,fecFin);
    Real  incr = (finVal-iniVal)/lon;
    Serie recta = B:(DifEq(1/(1-B),
                        SubSer(incr:CalInd(C,fdo),fecIni,fecFin),
                        iniVal));
   recta
  })
};

//////////////////////////////////////////////////////////////////////////////
Serie CreaDesnivel(TimeSet fechado, Date dt1, Date dt2, Real n1, Real n2)
//////////////////////////////////////////////////////////////////////////////
{
  Serie recta = TrendMinMax(dt1, dt2, n1,n2, fechado);
  (CalInd(W,fechado) << recta )>> CalInd(W,fechado)
};

//////////////////////////////////////////////////////////////////////////////
Serie DatChWeigh(Serie ser, TimeSet fechado, Set pond)
//////////////////////////////////////////////////////////////////////////////
{
  Text   name   = Name(ser);
  Matrix mat    = SetRow(pond);  
  Polyn  pol    = MatPol(mat);
  Serie  cal    = InvCh(CalInd(C, fechado), CalInd(W, Diario));
  Serie  serPol = (pol:cal)*ser;
  DatCh(serPol, fechado, SumS)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Cambio de fechado de una serie ponderando el numero de días con valor 
no nulo y sumandolos",
DatChWeigh);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
  Serie TramoSerie(Serie ser, Real p, Real q)
//////////////////////////////////////////////////////////////////////////////
{
  Real a = MinS(ser);
  Real b = MaxS(ser);
  Real min = a + p * (b-a);
  Real max = a + q * (b-a);
  Max(min,Min(max,ser))
};  

//////////////////////////////////////////////////////////////////////////////
  Set SeriePorTramos(Serie ser, TimeSet tms)
//////////////////////////////////////////////////////////////////////////////
{
  Set tramos = Dates(tms, y1994, y2001);
  Set tr = For(1, Card(tramos)-1, Serie(Real k)
  {
    Date  d1 = tramos[k]; 
    Date  d2 = Succ(tramos[k+1],SerTms(ser),-1); 
    Serie s = SubSer(ser, d1, d2);
    Text  y = FormatDate(d1,"%Y");
    Text  a = FormatDate(d1,"_%N");
    Text  b = FormatDate(d2,"_%N");
    Text  c = y+If(tms==Anual,"",If(a!=b,a+b,a));
    Eval("Serie "+Name(ser)+"_"+c+" = s; ")
  });
  Eval("Tramos_"+Name(tms)+" = tr; ")
};  
//////////////////////////////////////////////////////////////////////////////
Serie SerComunFechado(Set ser)
//////////////////////////////////////////////////////////////////////////////
{
    Set serMen = EvalSet(ser,Serie(Serie s){ InvCh(s,CalInd(W,Diario)) });
    Serie and  = AutoDating(Group("And",serMen))
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Devuelve el fechado intersección del conjunto de series que recibe.",
SerComunFechado);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Serie SerUnionFechado(Set ser)
//////////////////////////////////////////////////////////////////////////////
{
    Set serMen = EvalSet(ser,Serie(Serie s)
        { Not(Not(InvCh(s,CalInd(W,Diario)))) });
    Serie or   = AutoDating(SetSumC(serMen))
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Devuelve el fechado union del conjunto de series que recibe.",
SerUnionFechado);
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
Serie PlotFunction(Date orig, 
                   Date desde, 
                   Date hasta, 
                   Text fechado, 
                   Real escala,
                   Code funcion)
//////////////////////////////////////////////////////////////////////////////
{
  Real despY    = DateDif(Eval(fechado), desde, orig);
  Serie tendVal = SubSer(escala*(Trend(desde, Eval(fechado))-despY-1), desde, hasta);
  funcion(tendVal)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Devuelve una serie acotada resultado de aplicar la  funcion a una tendencia 
con pendiente < escala > con origen (0,0) en la fecha <origen>.",
PlotFunction);
//////////////////////////////////////////////////////////////////////////////
/*
//////////////////////////////////////////////////////////////////////////////
Serie ReverseSer(Serie ser)

//  PURPOSE: Return the series ser in inverse order
////////////////////////////////////////////////////////////////////////////// 
{
 Set  ordenIni = SerSet(ser);
 Real n        = Card(ordenIni);
Text WriteLn("Tiempo 1."+Time);
 Set  ordenFin = EvalSet(Range(1,n,1),Real(Real i){ ordenIni[n-i+1] });
Text WriteLn("Tiempo 2."+Time);
 SetSer(ordenFin, First(ser), Dating(ser))
};
*/
//////////////////////////////////////////////////////////////////////////////
Serie ReverseSer(Serie ser)

//  PURPOSE: Return the series ser in inverse order
////////////////////////////////////////////////////////////////////////////// 
{
  Set  ordenIni = SerSet(ser);
  Real n        = Card(ordenIni);
  Set  ordenFin = EvalSet(Range(1,n,1),Real(Real i){ ordenIni[n-i+1] });
  Matrix coef   = GetNumeric(ordenFin);
  Set s         = MatSerSet(coef, Dating(ser), First(ser));
  s[1]
};

//////////////////////////////////////////////////////////////////////////////
Serie ReversePar(Serie out, Serie inp)

//  PURPOSE: Hace Reverse y traslada out de forma que en Reverse(in) y en 
//           ReversePar(out,in) observaciones correspondientes a idénticas
//           fechas originalmente se encuentran en idénticas fechas en el
//           output
//////////////////////////////////////////////////////////////////////////////
{
  Date dOutFirst = First(out);
  Date dInpFirst = First(inp);
  Real difBegin  = DateDif(Dating(out),dInpFirst,dOutFirst);

  Serie outR     = ReverseSer(out);
  Date dOutLast  = Last(out);
  Date dInpLast  = Last(inp);
  Real difFinal  = DateDif(Dating(out),dInpLast,dOutLast);
  Real trasl     = difFinal+difBegin ;
  Polyn pol      = If(LT(trasl,0), B^(-trasl),F^trasl);
  pol:outR
};

//////////////////////////////////////////////////////////////////////////////
  Serie DatChTms(Serie ser, TimeSet tms, Code stat)
//////////////////////////////////////////////////////////////////////////////
{
  Date ini = First(ser);
  Date fin = Last(ser);
  TimeSet fechado = SerTms(ser)*tms + (SerTms(ser)-In(ini, fin));
  SubSer(DatCh(ser, fechado, stat), ini, fin)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Hace el cambio de fechado de la serie ser al conjunto temporal tms con el
estadistico stat.",
DatChTms);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
  Serie DatChSerTmsSer(Serie ser, Serie serTms)
//////////////////////////////////////////////////////////////////////////////
{
  TimeSet autoFec = SerTms(serTms) * In(First(serTms), Last(serTms));
  Serie serFecSer = SubSer(DatCh(ser, autoFec, FirstS), First(ser), Last(ser));
  serFecSer
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Hace el cambio de fechado de la serie ser al fechado no nulo de la serie
serTms con el estadistico FirstS.",
DatChSerTmsSer);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie NullSer(TimeSet tms)
//////////////////////////////////////////////////////////////////////////////
{ CalInd(W, tms) };
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Retorna la serie nula en el fechado tms.",
NullSer);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie SubNullSer(TimeSet tms, Date iniD, Date eDat)
//////////////////////////////////////////////////////////////////////////////
{ SubSer(NullSer(tms), iniD, eDat) };
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Retorna la serie nula en el fechado tms entre las fechas dadas.",
SubNullSer);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie Id(Serie ser)
//////////////////////////////////////////////////////////////////////////////
{ ser };
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Retorna la serie argumento.",
Id);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie SubSerDef(Serie ser)
//////////////////////////////////////////////////////////////////////////////
{ SubSer(ser, DefFirst, DefLast) };
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Retorna la serie argumento cortada entre las fechas por defecto.",
SubSerDef);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
  Serie TendLocNegTimeSet(TimeSet t, Date d1, Date d2)
//////////////////////////////////////////////////////////////////////////////
{
  Serie  s1     = CalInd(t,Diario);
  Date defFirst = Succ(d1,Diario,-1);
  Date defLast  = Succ(d2,Diario,1);
  Serie s2      = DifEq(1/(1-B),SubSer(-s1,defFirst,defLast));
  CalInd(W,Diario) << (Normaliza(s2,d1,d2)*s1) >> CalInd(W,Diario)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Contruye la tendencia lineal negativa de un conjunto temporal entre dos 
fechas.",
TendLocNegTimeSet);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
  Serie TendLocPosTimeSet(TimeSet t, Date d1, Date d2)
//////////////////////////////////////////////////////////////////////////////
{
 
  Serie  s1     = CalInd(t,Diario);
  Date defFirst = Succ(d1,Diario,-1);
  Date defLast  = Succ(d2,Diario,1);
  Serie s2      = DifEq(1/(1-B),SubSer(s1,defFirst,defLast));
  CalInd(W,Diario) << (Normaliza(s2,d1,d2)*s1) >> CalInd(W,Diario)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Contruye la tendencia lineal negativa de un conjunto temporal entre dos 
fechas.",
TendLocNegTimeSet);
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
Serie SawTrend( TimeSet tmDef, TimeSet tmOut, Date ini, Date fin )

// PORPUSE:
////////////////////////////////////////////////////////////////////////////
{
Serie  wdSer      = CalInd( tmDef, Diario);
Serie indAnual    = CalVar( tmDef, Anual);
Serie acuIndAnual = DifEq(1/(1-B), 
                          SubSer(B:indAnual,Succ(ini, Anual,1), 
                          fin));
Serie dif = tmDefSer( InvChEx(SubSer(acuIndAnual,  
                                     ini, 
                                     fin),  Diario)
                     ,tmDef);
Serie norm = tmDefSer(InvChEx(SubSer(indAnual, 
                                     ini, 
                                     fin),  Diario)
                     ,tmDef);
Serie trend = Trend( Succ(ini, tmDef,1), tmDef );
Serie ser   = SubSer(trend, First(norm),Last(norm));  
Serie tend  = DatCh(ser,tmDef, FirstS);
Text  tmTxt = DatingName(wdSer);
Serie tend_ = If(tmTxt=="Diario" , tend, tend - Real 1);
Serie norm_ = If(tmTxt=="Diario" , norm, norm - Real 1);
Serie ind   = InvCh( (tend_ - dif)/(norm_), CalInd(C, Diario)*Real 0);  
ind
};
/////////////////////////////////////////////////////////////////////////////////
PutDescription("
Dado un fechado crea una configuracion de diente de sierra con valor maximo
en el ultimo dia ",
SawTrend);
//////////////////////////////////////////////////////////////////////////////
Serie SawTrendInv( TimeSet tmDef, TimeSet tmOut, Date ini, Date fin )

// PORPUSE:
///////////////////////////////////////////////////////////////////////////
{
ReverseSer(SawTrend(tmDef,tmOut,ini,fin))
};
/////////////////////////////////////////////////////////////////////////////////
PutDescription("
Dado un fechado crea una configuracion de diente de sierra con valor
maximo en el primer dia ",
SawTrendInv);


//////////////////////////////////////////////////////////////////////////////
Serie DifEqSerExt(Serie ser, Real rho )
//////////////////////////////////////////////////////////////////////////////
{
Serie ser_   = SubSer(ser, y1999, y2009);
Serie difEq = DifEq( 1/(1-rho*B), ser_, 0);
Serie out   = ExtendSer(difEq);
out 
};
//////////////////////////////////////////////////////////////////////////////
Serie DifEqRho(Date d1, Real rho )
//////////////////////////////////////////////////////////////////////////////
{
Serie ser   = SubSer(Pulse(d1, Diario), y1999, y2009);
Serie difEq = DifEq( (1-rho)/(1-rho*B), ser, 0);
Serie out   = difEq;
out 
};

//////////////////////////////////////////////////////////////////////////////
Serie DifEqSerRho(Serie ser, Real rho )
//////////////////////////////////////////////////////////////////////////////
{
Serie difEq = DifEq( (1-rho)/(1-rho*B), ser, 0);
Serie out   = ExtendSer(difEq);
out 
};

//////////////////////////////////////////////////////////////////////////////
Serie DifEqSerFi_Rho(Serie ser, Polyn fi,  Polyn rho )
//////////////////////////////////////////////////////////////////////////////
{
Serie difEq = DifEq( (fi)/(rho), ser, 0);
Serie out   = ExtendSer(difEq);
out 
};



//////////////////////////////////////////////////////////////////////////////
Serie DifEqFi_Rho(Date d1, Polyn fi,  Polyn rho )
//////////////////////////////////////////////////////////////////////////////
{
Serie ser   = SubSer(Pulse(d1, Diario), y1999, y2009);
Serie difEq = DifEq( (fi)/(rho), ser, 0);
Serie out   = ExtendSer(difEq);
out 
};



/////////////////////////////////////////////////////////////////
Serie Tendencia (Serie ser , Date d1, Date d2)
////////////////////////////////////////////////////////////////
{
Serie zeros = CalInd(C-In(d1,d2) ,Diario);
Serie ser_  = zeros * ser;
Real n  = DateDif(Diario,d2,d1);
Real y1 = SerDat(ser , d1);
Real y2 = SerDat(ser , d2);
Serie x_ = SubSer( Trend(d1,Diario), d1,d2);
Real b  = (y2-y1)/n;
Serie tend =  ExtendSer(y1 - b* x_);
ser_ +tend
};
/////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////
Serie   TrasfMonoCrec( Serie pulse ,Real b)
/////////////////////////////////////////////////////////////
{

Serie ser_ = (ser /(Real(2)*MaxS(ser)))^(b);
Serie out  = 1 / (1+Exp(ser_)) - Real 0.5;
out
};
/////////////////////////////////////////////////////////////
Serie   TrasfMonoCrecDif( Serie ser,  Date d1 ,Real val)

/////////////////////////////////////////////////////////////
{
Serie pulse = SubSer( Pulse( d1, Dating(ser)),y2000 ,y2010 );
Serie aux   = ((1-B):ser)*((1)+ DifEq((val)/(1-0.98*B), pulse,0));
Serie difEq = DifEq( (1)/(1-B),aux,0);
Serie out   = ExtendSer(difEq);
out
};

/////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
  Serie ExpandOmit(Serie ser)
//////////////////////////////////////////////////////////////////////////////
{
  Serie serIndOmit = IsUnknown(ser);
  Serie serNotOmit = serIndOmit * 123456789 +
                     Not(serIndOmit) * OmitToZero(ser);
  Expand(serNotOmit, 123456789)
/*
  Date  iniDate    = First(ser);
  Date  finDate    = Last(ser);
  Real  numDatos   = DateDif(Diario, iniDate, finDate) + 1; 
  Serie serIndOmit = IsUnknown(ser);
  Real  numOmit    = SumS(serIndOmit);
  Real  allOmit    = EQ(numDatos, numOmit);
  Serie serNotOmit = serIndOmit * 123456789 +
                     Not(serIndOmit) * OmitToZero(ser);
  Serie expand = If(allOmit,
                    SubNulaFec(Diario, iniDate, finDate),
                    Expand(serNotOmit, 123456789));
  expand
*/
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Expande el valor anterior a un omitido en esos dias.
Si la serie es toda de omitidos devuelve la serie nula.",
ExpandOmit);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Serie DifEqF(Polyn p, Polyn q, Serie ser, Serie ini)
//////////////////////////////////////////////////////////////////////////////
{
  Serie out = ReverseSer(ser);
  Serie inp = ReversePar(ini, ser);
 
  Polyn pB = ChangeBF(p);
  Polyn qB = ChangeBF(q);

  Ration r = pB/qB;
 
  Serie res = DifEq(r, out, inp);
  Serie resOut = ReversePar(res, ser);

  resOut
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Calcula (p(F)/q(F)):ser con valor inicial ini.",
DifEqF);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set DatChSet(Set setOfSerie, TimeSet dating, Code stat)
//////////////////////////////////////////////////////////////////////////////
{
  Set s = EvalSet(setOfSerie, Serie(Serie ser)
  {
    Eval("Serie "+ Name(ser) +"."+ Name(dating) +"."+ Name(stat) +" =
          DatCh(ser, dating, stat);")
  });
  Eval("Set "+ Name(setOfSerie) +"."+ Name(dating) +"."+ Name(stat) +" = s;")
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Aplica el cambio de fechado dado a un conjunto de series y
las renombra con el nuevo fechado y el estadístico",
DatChSet);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set DatChSetCommonTmsNotOmit(Set sSer, Code fun)
//////////////////////////////////////////////////////////////////////////////
{
  TimeSet tmsCommonNotOmit = Group("Union",
  EvalSet(sSer, TimeSet(Serie sr)
  { SerTms(Not(IsUnknown(sr))) }));
  DatChSet(sSer, tmsCommonNotOmit, fun)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Aplica a un conjunto de series el cambio de fechado al
fechado comun en el que las series no tienen omitidos, y las renombra con el
nuevo fechado y el estadístico",
DatChSetCommonTmsNotOmit);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Serie DatChLVSumaSD(Serie ser)
//////////////////////////////////////////////////////////////////////////////
{

  // añadir dos ceros precedentes a la serie, para los dos retardos que se
  // utilizarán después
  Serie ser.Ceros = SubSer(0<<ser,First(ser)-2,Last(ser));

  Serie ser.LV = ser.Ceros*CalInd(CtLV, Diario)+
  (B^2):(ser.Ceros*CalInd(WD(6),Diario))+
  (B):(ser.Ceros*CalInd(WD(7), Diario));

  DatCh(ser.LV, CtLV, FirstS)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Cambia la serie introducida al fechado CtLV, acumulando en el
lunes los valores correspondientes a sábado y domingo.",
DatChLVSumaSD);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie Log0(Serie ser)
//////////////////////////////////////////////////////////////////////////////
{
  Log(ser+Not(ser))
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Aplica la funcion Log devolviendo 0 cuando la serie original
vale 0.",
Log0);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Serie SubstractC(Serie ser01, Serie ser02)
//////////////////////////////////////////////////////////////////////////////
{
  Set setSerSameDates = ExpandSetSer(SetOfSerie(ser01, ser02));
  setSerSameDates[1] - setSerSameDates[2]
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Devuelve la diferencia de dos series ampliando ambas al minimo
de los inicios y al maximo de los finales (rellenando con ceros).",
SubstractC);
//////////////////////////////////////////////////////////////////////////////





//////////////////////////////////////////////////////////////////////////////
  Serie SolveDifEq(Polyn A, Polyn B, Serie X, Serie X0, Serie Y0)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("SolveDifEq ");
  Ration R = A/B;
  Real  a = Degree(A);
  Real  b = Degree(B);
  If(Not(Or(a,b)), X,
  {
    TimeSet tms = Dating(X);
    Date    ini = First(X);
    Date    fin = Last (X);
    
    Date iniX0 = Succ(ini,tms,-a);
    Date finX0 = Succ(ini,tms,-1);
    Date iniY0 = Succ(ini,tms,-b);
    Date finY0 = finX0;
    
  //Set View([[ini,fin,iniX0,finX0,iniY0,finY0]],"");

    Serie X0Cor = SubSer(X0,iniX0,finX0);  
    Serie Y0Cor = SubSer(Y0,iniY0,finY0);
    Serie conX0 = If(a, X0Cor<<X, X);  
    Serie difEq = DifEq(R,conX0,Y0Cor);
    SubSer(difEq,ini,fin)
  //Set Table([[X,X0,X0Cor,Y,Y0,Y0Cor]],"");
  })
};
