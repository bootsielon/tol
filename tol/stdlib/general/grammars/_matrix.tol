//////////////////////////////////////////////////////////////////////////////
// FILE    : _matrix.tol
// PURPOSE : Matrix added functions from SADD0
// VERSION : 2003/09/03 CPA
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
  Matrix SerCovarianze(Set series)
//////////////////////////////////////////////////////////////////////////////
{
  Matrix M = SerSetMat(series);
  Cov(M)
};


//////////////////////////////////////////////////////////////////////////////
  Matrix SerCorrelation(Set series)
//////////////////////////////////////////////////////////////////////////////
{
  Matrix M = SerSetMat(series);
  Cor(M)
};


//////////////////////////////////////////////////////////////////////////////
Matrix IncludeMatrix(Text file)
//////////////////////////////////////////////////////////////////////////////
{
  Matrix M     = IncludeBMT(file)[1];
  Set    lastF = MatSet(SubRow(M, SetOfReal(Rows(M))));
  Real   isUnk = BinGroup("*",EvalSet(lastF[1],Real(Real r){ IsUnknown(r) }));
  If(isUnk, Sub(M, 1, 1, Rows(M) -1, Columns(M)), M)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Devuelve la matriz del fichero file.",IncludeMatrix);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix MatSetSeries(Set setSer)
//////////////////////////////////////////////////////////////////////////////
{
  Date  FsDat(Serie s){ First(s) };
  Date  LsDat(Serie s){ Last(s) };
  Date fs = BinGroup("Max", EvalSet(setSer,FsDat));
  Date ls = BinGroup("Min", EvalSet(setSer,LsDat));
  SerSetMat(setSer,fs,ls)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Devuelve una matriz a partir de un conjunto de series desde el mayor de los 
inicion al menor de los finales",MatSetSeries);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix MatDiag(Matrix mat)
//////////////////////////////////////////////////////////////////////////////
{
  Set diag = MatSet(SubDiag(mat,0));
  Matrix rdiag = SetDiag(diag[1]);
  rdiag
};

//////////////////////////////////////////////////////////////////////////////
PutDescription("
Devuelve la matriz diagonal de la matrix que recibe.",MatDiag);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix CovMat(Set setSer)
//////////////////////////////////////////////////////////////////////////////
{
  Real CovS(Serie s1, Serie s2){ AvrS(s1*s2)- AvrS(s1)*AvrS(s2)};

  Set setCov = For(1,Card(setSer),Set(Real i)  
  {
    Set fila  = For(i,Card(setSer),Real(Real j)
    { CovS(setSer[i], setSer[j]) });
    Set ceros = For(Card(fila)+1,Card(setSer),Real(Real c){ 0 });
    ceros<<fila
  });

  Matrix CovTS = SetMat(setCov);
  Matrix VarDg = MatDiag(CovTS);
  Matrix CovTI = Tra(CovTS-VarDg);
  CovTI + CovTS
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Devuelve la Matriz de Varianzas-Covarianzas de un conjunto de series.",
CovMat);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
  Matrix MatCorrSetSer(Set s)
//////////////////////////////////////////////////////////////////////////////
{
  Matrix m = SetMat(SetSerCorr(s));
  m + Tra(m) - Diag(Card(s),1)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Crea la matriz de correlaciones de un conjunto de series.",
MatCorrSetSer);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix MatTriSup(Matrix mat)
//////////////////////////////////////////////////////////////////////////////
{
  Real row = Rows(mat);
  Real col = Columns(mat);
  If(NE(row, col), mat,
  {
    Set diags = For(0, row-1, Matrix(Real n) 
    {
      Matrix diag = SetDiag(MatSet(SubDiag(mat,n))[1]);
      Real dim    = Rows(diag);
      If(EQ(dim, col), diag,
      {
        Matrix leftMat = Gaussian(row, row-dim, 0, 0); 
        Matrix downMat = Gaussian(row-dim, dim, 0, 0);
        leftMat|(diag<<downMat)      
      })      
    });
    BinGroup("+", diags)
  })
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Devuelve la matriz triangular superior de una matriz cuadrada.",
MatTriSup);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix MatTriInf(Matrix mat)
//////////////////////////////////////////////////////////////////////////////
{ Tra(MatTriSup(Tra(mat))) };
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Devuelve la matriz triangular inferior de una matriz cuadrada.",
MatTriSup);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
  Matrix ConcatSetCols (Set cols)
//
// PURPOSE : Retorna la matriz resultado de concatenar los vectores columna del
//           conjunto <cols>.
//////////////////////////////////////////////////////////////////////////////
{BinGroup("|",cols)};

PutDescription("Matrix ConcatSetCols (Set cols):\n"
"Retorna la matriz resultado de concatenar los vectores columna del " 
"conjunto <cols>.", ConcatSetCols);

//////////////////////////////////////////////////////////////////////////////
  Matrix ConcatSetRows (Set rows)
//
// PURPOSE : Retorna la matriz resultado de concatenar los vectores fila del
//           conjunto <rows>.
//////////////////////////////////////////////////////////////////////////////
{BinGroup("<<",rows)};

PutDescription("Matrix ConcatSetRows (Set rows):\n"
"Retorna la matriz resultado de concatenar los vectores fila del "
"conjunto <rows>.", ConcatSetRows);

//////////////////////////////////////////////////////////////////////////////
  Matrix CoPro (Matrix mat1, Matrix mat2, Real min)
//
// PURPOSE : Retorna la matriz que por entradas tiene el producto de las 
//           entradas de las matrixes <mat1> y <mat2>.
//           El argumento <min> tiene el siguiente significado:
//           - Si min=0, indica que el usuario sabe que las matrices tienen
//             todas sus entradas positivas.(Mas rapido).
//           - Si min<0, el usuario sabe que el minimo de las entradas de 
//             las dos matrices es <min>.(Velocidad intermedia).
//           - Si min>0, indica que el usuario no sabe el minimo de las 
//             entradas de las dos matrices.(Mas lento).
//
// (Nota: Se usa la funcion Real MinMatrix() de las libreria common)
//
//////////////////////////////////////////////////////////////////////////////
{
  If(EQ(min,0),
  {
    Exp(Log(mat1)+Log(mat2))
  },
  If(LT(min,0),
  {
    Real k = 1-min;
    RSum(Exp(Log(RSum(mat1,k))+Log(RSum(mat2,k)))-RProd(mat1+mat2,k),-k^2)
  },
  { 
    Real min1 = MinMatrix(mat1);
    Real min2 = MinMatrix(mat2);
    Real k    = 1-Min(min1,min2);
    RSum(Exp(Log(RSum(mat1,k))+Log(RSum(mat2,k)))-RProd(mat1+mat2,k),-k^2)
  }))
};

PutDescription("Matrix CoPro (Matrix mat1, Matrix mat2, Real min):\n"
"Retorna la matriz que por entradas tiene el producto de las "
"entradas de las matrixes <mat1> y <mat2>.\n"
"El argumento <min> tiene el siguiente significado:\n"
"           - Si min=0, indica que el usuario sabe que las matrices tienen "
"todas sus entradas positivas.(Mas rapido).\n"
"           - Si min<0, el usuario sabe que el minimo de las entradas de "
"las dos matrices es <min>.(Velocidad intermedia).\n"
"           - Si min>0, indica que el usuario no sabe el minimo de las "
"entradas de las dos matrices.(Mas lento).\n"
"\n"
" (Nota: Se usa la funcion Real MinMatrix() de las libreria common)",
CoPro);

//////////////////////////////////////////////////////////////////////////////
  Matrix SubPos (Matrix A, Real rows, Real cols) 
//
// PURPOSE : Calcula la submatriz de la matriz <A> asociado a la posicion 
//           (<rows>,<cols>). 
//
//////////////////////////////////////////////////////////////////////////////
{
  Real rowsA = Rows(A);
  Real colsA = Columns(A);
  
  Set colsIndex = Range(1,colsA,1)-[[cols]];
  Set rowsIndex = Range(1,rowsA,1)-[[rows]]; 
  
  SubRow(SubCol(A,colsIndex),rowsIndex)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Matrix SubPos (Matrix A, Real rows, Real cols) :\n"
"Calcula la submatriz de la matriz <A> asociado a la posicion (<rows>,<cols>)."
, SubPos);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix CoProL(Matrix M1, Matrix M2)
//////////////////////////////////////////////////////////////////////////////
{
  If(!VerifyDim(M1,M2),
  {
    WriteLn("ERROR:\n< CoProL: > 
     Intento de producto especial de matrices de distinta dimension");
    UnknownMatrix
  },
  {
    Real n    = Copy(1);
    Real m    = Copy(1);
    Set  fila = Copy(Empty);

    Real While(LE(n,Rows(M1)),
    {
      Set  columna = Copy(Empty);
      Real(m:=Copy(1));
      Real While(LE(m,Columns(M1)),
      {
        Set(columna:=columna<< SetOfReal(MatDat(M1,n,m)*MatDat(M2,n,m)));
        Real(m:=m+1)
      });
      Set(fila:=fila<<SetOfSet(columna));
      Real(n:=n+1)
    });
    SetMat(fila)
  })
};

//////////////////////////////////////////////////////////////////////////////
Matrix FreqRel(Matrix M, Real sample, Real ini, Real end)
//////////////////////////////////////////////////////////////////////////////
{
  Matrix F   = If(EQ(ini,end,0), Frequency(M, sample), 
                   Frequency(M, sample, ini, end));
  Real total = MatSum(SubCol(F, SetOfReal(2)));
  Matrix densRel = RProd(SubCol(F, SetOfReal(2)), 1/total);  
  Matrix acuProb = DifEq(1/(1-B),densRel);
  Matrix acuProbInv = Rand(sample, 1, 1, 1)-acuProb;
  SubCol(F, SetOfReal(1))|densRel|acuProb|acuProbInv
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(I2("Calculates the relative frequency of a
column matrix and returns a matrix with the following columns:
- Interval superior extremes
- Relative frequency of each interval
- Acumulative probability
- one minus acumulative probability.",
"Calcula la frecuencia relativa de los elementos de una 
matriz columna y retorna una matriz con las siguientes columnas:
- Extremos superiores de cada intervalo
- Frecuencia relativa de cada intervalo
- Probabilidad acumulada
- 1- Probabilidad acumulada."), 
FreqRel);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix FrequencySql(Text qry, Real sample, Real ini, Real fin)
//////////////////////////////////////////////////////////////////////////////
{
  Text query = GetFreSql(qry,sample,ini,fin,1);
  DBMatrix(query)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Hace un análisis de frecuencia de sample intervalos para una
query que devuelve una columna con nombre k. Devuelve una matriz con dos 
columnas. En la primera columna contiene el límite superior de cada intervalo.
En la segunda columna contiene el número de valores de M que pertenecen a
cada intervalo.",
FrequencySql);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Matrix FreqRelSql(Text qry, Real sample, Real ini, Real end)
//////////////////////////////////////////////////////////////////////////////
{
  Matrix F   = FrequencySql(qry, sample, ini, end);
  Matrix S   = SubCol(F, SetOfReal(2));
  Real total = MatSum(S);
  SubCol(F, SetOfReal(1))|RProd(S, 1/total)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Calcula la frecuencia relativa de los elementos de una 
matriz columna.", 
FreqRelSql);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix SubMat(Matrix mat, Set filas,Set columnas)
//////////////////////////////////////////////////////////////////////////////
{ SubCol(SubRow(mat, filas), columnas) };
//////////////////////////////////////////////////////////////////////////////
PutDescription("Retorna la submatriz de la matriz dada que tiene las 
filas y columnas argumento", SubMat);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix SubMatCond(Matrix mat, Text filas, Text columnas)
//////////////////////////////////////////////////////////////////////////////
{
  Real cols = Columns(mat);
  Real rows = Rows(mat);
  Set indexCol = Range(1, cols, 1);
  Set indexRow = Range(1, rows, 1);
  Set selCol = Select(indexCol, Real(Real col)
  { Eval(columnas) });
//Text WriteLn("selCol "<<selCol);
  Set selRow = Select(indexRow, Real(Real row)
  { Eval(filas) });
//Text WriteLn("selRow "<<selRow);
  SubMat(mat, selRow, selCol)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Retorna la submatriz de la matriz argumento a través de 
condiciones dadas por os argumentos de texto para filas y columnas. Estos
argumentos son sentencias tol que se evaluan y que deben servir de indicadores
de pertenencia. Se usan variables <col> y <row> para hacer notar las columnas
y filas a seleccionar. Por ejemplo:

col == 1 y row>=5 selecciona la columna 1 y las filas mayores o iguales que 5.

Solo sepueden color valores numéricos. Es decir no se pueden colocar 
expresiones como col>row.", SubMatCond);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix MatUnkInd(Matrix mat)
//////////////////////////////////////////////////////////////////////////////
{ Not(Or(mat, Not(mat))) };
//////////////////////////////////////////////////////////////////////////////
PutDescription("Retorna una matriz indicadora con 1 si hay ? en mat y 0 en
otro caso (incluyendo 1/0 y -1/0).",
MatUnkInd);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix FunArMat(Polyn ar, Matrix z, Real n)
//////////////////////////////////////////////////////////////////////////////
{
  Matrix zAr = If(ar==0, z, SubRow(DifEq(ar/1, z), Range(Degree(ar)+1, n, 1)));
  zAr
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Aplica un Polyn ar a una Matrix z", FunArMat);
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
  Matrix ForMat(Real rows, Real columns, Code fun)
//////////////////////////////////////////////////////////////////////////////
{
  Real n = 0;
  Matrix M = Rand(rows,columns,0,0);
  Real While
  (
    n<rows,
    {
      n:=n+1;
      Real m = 0;
      While
      (
        m<columns,
        {
          m:=m+1;
          Real x = fun(n,m);
          PutMatDat(M,n,m,x); 
          m
        }   
      ),
      n
    } 
  );
  M
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
  "",
  "Devuelve una matriz con las dimensiones dadas y los valores generados "+
  "por la funcion indicada, la cual toma dos argumentos reales "+
  "correspondientes a las coordenadas (i,j) y devuelve el elemento (i,j) "+
  "de la matriz.") + NL +
  I2("Example : ", "Ejemplo : ") + NL +
  "Matrix ForMat(2, 3, Real (Real n, Real m){n*m});",
  ForMat);
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
  Set ExtractRowsAbsGE(Matrix M, Real min)
//////////////////////////////////////////////////////////////////////////////
{
  Set S = MatSet(M);
  Select(Range(1,Rows(M),1),Real (Real k) 
  { 
    Set  row = S[k];
    Real max = Max(Abs(SetMax(row)),Abs(SetMin(row)));
    GE(max,min)
  }) 
};


//////////////////////////////////////////////////////////////////////////////
  Set BigMatrixTable(Matrix M, Set xNames, Text name, Real min)
//////////////////////////////////////////////////////////////////////////////
{
  Set s = ExtractRowsAbsGE(M,min);
  If(Card(s)==0,Copy(Empty),
  {
    Matrix A = SubCol(SubRow(M,s),s);
    Set sxNames = ExtractByIndex(xNames,s);
    Set head  = [[name]] + sxNames;
    Real n = Rows(A);
    Real m = Columns(A);
    Set body  = For
    ( 
      1,n,
      Set (Real i)
      {
        Set row = For(1,m, Anything dat_i_j(Real j) 
        {
          Real x = MatDat(A, i, j);
          If(Abs(x)>min, x, "_")
        });
        SetOfText(sxNames[i]) + row
      }
    );
    SetOfSet(head) + body
  })
};

//////////////////////////////////////////////////////////////////////////////
Matrix  ColDiag( Matrix col)
//////////////////////////////////////////////////////////////////////////////
{ SetDiag( BinGroup("<<",MatSet(col))) };
//////////////////////////////////////////////////////////////////////////////
PutDescription("Dada una matriz columna de tamaño n devuevle una matriz 
cuadrada con elementos en la diagonal a[ii]=col[i]. 

Por ejemplo:
Matrix col = Col(1,2,3);
Matrix a   = ColDiag(col);" 
,ColDiag);
//////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
  Real MatEQ(Matrix A, Matrix B)
////////////////////////////////////////////////////////////////////////////
{ 
  Real r = Rows(A);
  Real c = Columns(A);
  Real dropInv = 10*r*c;
  And
  (
    r==Rows(B),
    c==Columns(B),
    MatMax(Abs(A-B))+dropInv==dropInv
  )
};
PutDescription("Returns true if two matrices are equals but a numerical "
"rounding error", MatEQ);