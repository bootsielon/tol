//////////////////////////////////////////////////////////////////////////////
// FILE    : _set.tol
// PURPOSE : Funciones de SET
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Struct @DistribSt
(
   Set Valores,
   Real Media,
   Real DesTip,
   Real Maximo,
   Real Minimo,
   Real Mediana,
   Set  IQR
);

//////////////////////////////////////////////////////////////////////////////
  Set SerSetTable(Set s)
//////////////////////////////////////////////////////////////////////////////
{
  Matrix M = SerSetMat(s);
  MatSet(M)
};


//////////////////////////////////////////////////////////////////////////////
  Set MatrixTable(Matrix mat, Set xNames, Set yNames, Text name)
//////////////////////////////////////////////////////////////////////////////
{
  Set head  = [[name]] + xNames;
  Real n = Rows(mat);
  Real m = Columns(mat);
  Set body  = For
  (
    1,n,
    Set (Real i)
    {
      Set row = For(1,m, Real dat_i_j(Real j) { MatDat(mat, i, j) });
      SetOfText(yNames[i]) + row
    }
  );
  SetOfSet(head) + body
};

//////////////////////////////////////////////////////////////////////////////
  Set MainComponents (Set series)
//////////////////////////////////////////////////////////////////////////////
{
  Real n = Card(series);
  Matrix covMat = SerCovarianze(series);
  Set J = JordanIterative(covMat);  
  Matrix comp = J[1];
  Matrix val  = J[2];
  Set valSet = For(1,n, Text (Real j) { ""+MatDat(val,j,j) });
  Matrix serData    = SerSetMat(series);
  Matrix serNewData = Tra(comp)*serData;
  Date   first = Group("Max",EvalSet(series,Date (Serie s) { First(s) }));
  Set    newSeries  = MatSerSet(serNewData,Dating(series[1]),first);
  [[comp,val,newSeries]]
};

////////////////////////////////////////////////////////////////////////////// 
   Set EvalText(Set set, Code code)
//
// PURPOSE: Returns a set with each evaluation of text generated by code from
//          each element of set 
//
////////////////////////////////////////////////////////////////////////////// 
{  
  IncludeText(BinGroup("+", EvalSet(set, code)))
};

//////////////////////////////////////////////////////////////////////////////
Set Seting(Anything any)
//////////////////////////////////////////////////////////////////////////////
{
  Text gra = Grammar(any);
  If(gra == "Set", any, SetOfAnything(any))
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Convierte lo que recibe en un conjunto",Seting);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set SetDist(Set values,Real isSort)
//////////////////////////////////////////////////////////////////////////////
{
  Real max     = SetMax(values);
  Real min     = SetMin(values);
  Real media   = SetAvr(values);
  Real desTip  = SetStDs(values);
  Real mediana = Percentil(50,values, isSort);
  Set  IQR     = SetOfReal(Percentil(25,values, isSort),
                           Percentil(75,values, isSort));
  DistribSt(values,media,desTip,max,min,mediana,IQR)
};

//////////////////////////////////////////////////////////////////////////////
Set SetConcat(Set set)
//////////////////////////////////////////////////////////////////////////////
{
  // Eliminar de set aquellos elementos que sean Empty o no sean de tipo Set
  Set setOk = Select(set, Real(Anything subSet)
  {
    If(Grammar(subSet)!="Set", FALSE,
    If(LE(Card(subSet),0),     FALSE,
                               TRUE))
  });

  If(LE(Card(setOk),0), Empty,
  {
    // Contar el numero de elementos en cada subset de set
    Real numEle = SetSum(EvalSet(set, Real(Set subSet) { Card(subSet) }));
  
    Real ctrSub = 1; // Contador de subsets dentro de set
    Real ctrEle = 1; // Contador de elementos en cada subset
  
    For(1, numEle, Anything(Real num)
    {
      Real newSet = If(LE(ctrEle, Card(setOk[ctrSub])), FALSE,
      {
        Real(ctrSub:=ctrSub+1); // Cambia al siguiente subset
        Real(ctrEle:=1);        // Comienza desde el primer elemento
        FALSE
      });

      Anything ele = setOk[ctrSub][ctrEle]; // Extraer el elemento
      Real(ctrEle:=ctrEle+1);               // Siguiente elemento
      ele                                   // Retornar el elemento
    })
  })
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Retorna lo mismo que la expresion BinGroup('<<',set), donde set es un set de
sets y lo hace mediante una sola instruccion For().
Esta funcion es el doble de lenta que el BinGroup(), pero frente a conjuntos
grandes (por ejemplo 70x300) es mas robusta.",
SetConcat);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set SetClassify(Set set, Code fun)
//////////////////////////////////////////////////////////////////////////////
{
  If(LE(Card(set),0), Empty,
  {
    Set  keyCol = EvalSet(set, Anything(Anything ele) { fun(ele) });
    Set  keyUni = Unique(keyCol);
    Text graFun = CodeGrammar(fun);
    Set keySor = 
      If(graFun=="Text", Sort(keyUni, Real(Text a, Text b){ Compare(a,b) }),
      If(graFun=="Real", Sort(keyUni, Real(Real a, Real b){ Compare(a,b) }),
      If(graFun=="Date", Sort(keyUni, Real(Date a, Date b){ Compare(a,b) }),
                         Empty)));

    EvalSet(keySor, Set(Anything key)
          { Select(set, Real(Anything ele) { key==fun(ele) }) })
/*  For(1, Card(keySor), Set(Real numCla)
    {
      Anything key = keySor[numCla];
      Set      sel = Select(set, Real(Anything ele) { key==fun(ele) });
      Text     nam = "Class"+FormatReal(numCla,"%.0lf");
      Eval("Set "+nam+" = sel; ")
    }) */
  })
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Retorna la clasificacion de un conjunto set de forma identica a la funcion
Set Classify(Set set, Real funCla(Anything a, Anything b) ) donde funCla se
define como Real funCla(Anything a, Anything b) { Compare(fun(a),fun(b) }
siendo fun el codigo de entrada a esta funcion SetConCat(set, fun).
Como Sort(keyUni, Real(Anything a, Anything b) { Compare(a,b) }); no funciona
la funcion fun ha de retornar: Text, Real o Date.
La extraccion final puede realizarse con un EvalSet() o con un For() y un
Eval() que sirve para denominar a las clases Class1, Class2, ... como lo hace
la funcion Classify().
Esta funcion es el triple de lenta que el Classify(), pero frente a conjuntos
grandes (por ejemplo 20000) es mas robusta.",
SetClassify);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set ReadTable(Text path)
//////////////////////////////////////////////////////////////////////////////
{
  Text filTxt = ReadFile(path);
  Set  rowSet = Tokenizer(filTxt,"\n");
  Set  tabSet = EvalSet(rowSet,Set(Text lin)
  { Tokenizer(lin,";") });

  Text WriteLn("Incluyendo "+path);
  tabSet
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Lee un fichero con estructura de tabla separados los campos por <;>. Todos los
Campos los devuelve tipo Text."
,SetConcat);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set IncludeBlind(Text path)
//////////////////////////////////////////////////////////////////////////////
{
  SetOfSet(Include(path))
};

//////////////////////////////////////////////////////////////////////////////
Set DateIndexTimeSet( TimeSet ctInd, Date ini, Date fin)
//////////////////////////////////////////////////////////////////////////////
{
  TimeSet ctFin    = Succ(ctInd,-1);
  TimeSet ctIniFin = ctInd + ctFin; 
  
  Date ini = Succ(ini,ctInd);
  Date fin = Succ(fin,ctFin,-1);

  Set fechas = Dates(ctIniFin,ini,fin);

  Set For(1,(Card(fechas)/2), Set(Real s)
  {
    Real r = 2*s;
    SetOfDate(fechas[r-1],fechas[r])
  })
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Devuelve las fechas indicadoras de inicio y fin de un TimeSet entre dos 
fechas.", DateIndexTimeSet);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
  Set SerSet(Serie ser)
//
// PURPOSE: Retorna el conjunto con los datos de la serie
//////////////////////////////////////////////////////////////////////////////
{
  Set dates = Dates(Dating(ser),First(ser),Last(ser));
  EvalSet(dates,Real(Date d){SerDat(ser,d)})
}; 

//////////////////////////////////////////////////////////////////////////////
   Set DatesNotEqual(Serie ser, Real num, TimeSet fdo)
//
// PURPOSE : Retorna el cto de fechas donde la serie tiene un valor distinto
//           del real que toma.(POR RECURSION).
//           Se tiene que aumentar un día la serie porque si el ultimo dia 
//           es distinto de num se crea un bucle infinito.
//////////////////////////////////////////////////////////////////////////////
{
  ////////////////////////////////////////////////////////////////////////////
   Set datesNotEqualAux(Serie ser,Set setdates, Real num, TimeSet fdo)
  ////////////////////////////////////////////////////////////////////////////
  {
    Serie salida = Not(Eq(ser,num));
    If(SumS(salida)==0, setdates,
     {
       Date date = FirstNotEqual(ser,First(ser),num);
       Serie subser = SubSer(ser,Succ(date,fdo,1),Last(ser));
       Set newsetdates = SetOfDate(date) + setdates;
       datesNotEqualAux(subser,newsetdates,num,fdo)
     })
  };
  Serie undiamas =SubSer(CalInd(fdo,fdo)*num,Last(ser),Succ(Last(ser),fdo,1));
  Serie ser00 = ser >> undiamas;
  datesNotEqualAux(ser00,Empty,num,fdo)
};

////////////////////////////////////////////////////////////////////////////
Set InpDefPulse(Serie indicador)
////////////////////////////////////////////////////////////////////////////
{
  Text datingSer = DatingName(indicador);
  TimeSet tmSer  = SerTms(indicador);
  Set  datesPul  = Dates(tmSer,First(indicador),Last(indicador));
  Set  inputDef  = If(IsEmpty(datesPul), Empty, EvalSet(datesPul,Set(Date dat)
  {
    Eval("@InputDef(0.1,Pulse("+FormatDate(dat)+","+datingSer+"));")
  }))
};
////////////////////////////////////////////////////////////////////////////
PutDescription("Devuelve un conjunto @InputDef con Omega 0.1 y Serie Pulse para 
cada fecha con valor no nulo de la serie que recibe",InpDefPulse);
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
Set InpDefPulseName(Serie indicador, Text label)
////////////////////////////////////////////////////////////////////////////
{
  TimeSet tmSer  = SerTms(indicador);
  Set  datesPul  =
   Dates(tmSer,KnownDate(First(indicador)),KnownDate(Last(indicador)));
  Set  inputDef  = If(IsEmpty(datesPul), Empty, 
   EvalSet(datesPul,Set(Date dat)
   {
     Serie pul = Pulse(dat, Dating(indicador));
     @InputDef
     (
       0.1,
       Eval("Serie "+label+"Pulse"+FormatDate(dat, "%c%Y%m%d")+" = pul; ")
     )
   })
  )
};
////////////////////////////////////////////////////////////////////////////
PutDescription("Devuelve un conjunto @InputDef con Omega 0.1 y Serie Pulse para 
cada fecha con valor no nulo de la serie que recibe", InpDefPulseName);
////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set TrasladaMinOrigen(Set setSer)

// PURPOSE: Coloca todas las series del cjto setSer en el origen de la 
//          serie mas adelantada
//////////////////////////////////////////////////////////////////////////////
{
  Set   origenSer = EvalSet(setSer, Date(Serie ser){First(ser)});
  Date  origen = BinGroup("Min",origenSer);
  Serie traslado(Serie ser){ TrasladaAOrigen(ser, origen) };
  Set EvalSet(setSer,traslado)
};

//////////////////////////////////////////////////////////////////////////////
Set TrasladaMaxOrigen(Set setSer)

// PURPOSE: Coloca todas las series del cjto setSer en el origen de la 
//          serie mas adelantada
//////////////////////////////////////////////////////////////////////////////
{
  Set   origenSer = EvalSet(setSer, Date(Serie ser){First(ser)});
  Date  origen = BinGroup("Max",origenSer);
  Serie traslado(Serie ser){ TrasladaAOrigen(ser, origen) };
  Set EvalSet(setSer,traslado)
};

//////////////////////////////////////////////////////////////////////////////
Set IncludeBDTChName(Text path, Text suf)
//////////////////////////////////////////////////////////////////////////////
{
  Set setSer  = Include(path);
  Set EvalSet(setSer, Serie(Serie ser)
  { Eval("Serie "+Name(ser)+suf+" = ser;")})
};

//////////////////////////////////////////////////////////////////////////////
Set IncludeIf(Text path)
//////////////////////////////////////////////////////////////////////////////
{
  Real fileExist = FileExist(path);
  Real fileSize  = FileBytes(path);

  If(fileExist, 
  If(fileSize, Include(path), 
  {
    Text WriteLn("WARNING: El archivo "+path+" esta vacio.");
    Copy(Empty)
  }),  
  {
    Text WriteLn("WARNING: El archivo "+path+" no existe.");
    Copy(Empty)
  }) 
}; 

//////////////////////////////////////////////////////////////////////////////
Set IncludeBDTChNameIf(Text path,Text suf)
//////////////////////////////////////////////////////////////////////////////
{
  Real fileExist = FileExist(path);
  Real fileSize  = FileBytes(path);

  If(fileExist, 
  If(fileSize, IncludeBDTChName(path, suf), 
  {
    Text WriteLn("WARNING: El archivo "+path+" esta vacio.");
    Copy(Empty)
  }),  
  {
    Text WriteLn("WARNING: El archivo "+path+" no existe.");
    Copy(Empty)
  }) 
}; 

//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Incluye un fichero si existe y no es vacio.",
IncludeIf);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set ForCluster(Set set , Real num)
//////////////////////////////////////////////////////////////////////////////
{
  Real card  = Card(set);
  Case(Or(EQ(card,0), LE(num,0)), 
  {
    Text WriteLn("El conjunto es vacio o el numero es menor o igual que 0.");
    Empty
  },
  EQ(card,1), 
  SetOfSet(set),
  Not(Or(EQ(card, 0), EQ(card, 1))),
  {
    Real numOK = Round(num);
    Set index  = Range(1, card, 1);
    Set indexSet = Classify(index, Real(Real i1, Real i2)
    {
      Real ci1 = (i1-(i1%numOK))/numOK;
      Real ci2 = (i2-(i2%numOK))/numOK;
      Compare(ci1, ci2)
    });
    Set cluster = EvalSet(indexSet, Set(Set index)
    { ExtractByIndex(set, index) });
    cluster
  })  
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Clusterizacion del conjunto set por num. Cada conjunto resultante tiene como 
mucho num elementos",
ForCluster);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set TokenizerAll(Text txt)
//////////////////////////////////////////////////////////////////////////////
{
  Text repAll = RepTok(txt);
  Set tokenAll = Tokenizer(repAll, "_");  
  tokenAll
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Tokeniza un texto con una tabla prefijada de tokens",
TokenizerAll);
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
Set SplitSet(Set set, Real num)
//////////////////////////////////////////////////////////////////////////////
{
  Real c = Card(set);
  If(EQ(c,0), Empty,
  If(EQ(c,1), SetOfSet(set),
  If(LT(c, num), EvalSet(set , Set(Anything element)
  { SetOfAnything(element) }),
  {
    Set  index = Range(1, c, 1);
    Set setIndex = Classify(index , Real(Real i1, Real i2)
    {
      Real mod1 = i1%num;
      Real mod2 = i2%num;
      Compare(mod1, mod2)
    });
    Set split = EvalSet(setIndex, Set(Set index)
    { ExtractByIndex(set, index) })
  })))  
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Clusterizacion del conjunto set por num. El conjunto resultante tiene a lo
sumo num subconjuntos.",
ForCluster);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set SplitInput(Set input, Date iniEstim, Date endEstim)
//////////////////////////////////////////////////////////////////////////////
{
  Set monomesSer = EvalSet(input, Set(Set reg)
  { 
    Text nameInput = reg->NameInput;
    Polyn omega    = reg->Omega;
    Set monOmega   = Monomes(omega);
    Set monInputSet = EvalSet(monOmega, Set(Polyn monome)
    {  @InputDef(monome, Eval("Serie "+nameInput+"; "))  });
    monInputSet
  });  
   
  Set selInpDef = EvalSet(monomesSer, Set(Set inpDefSet)
  {
    Set selMon =  Select(inpDefSet, Real(Set reg)
    { 
      Polyn monome = reg->Omega;
      Serie ser    = reg->X;
      Serie subSer = SubSer(monome:ser, iniEstim, endEstim);
      Not(IsSerNull(subSer)) 
    });
    If(IsEmpty(selMon), Copy(Empty),
    {
      @InputDef
      (
        SetSum(EvalSet(selMon, Polyn(Set reg){reg->Omega})),
        selMon[1]->X
      )
    })
  });
  Set selNotEmpty = Select(selInpDef, Real(Set set)
  { Not(IsEmpty(set)) });
  selNotEmpty
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Desagrupa un conjunto de input de forma monomica.",
SplitInput);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set PulseInd(Serie ind, Text label)
//////////////////////////////////////////////////////////////////////////////
{
  Date f = If(First(ind)==TheBegin, DefFirst,First(ind));
  Date l = If(Last(ind)==TheEnd, DefLast,Last(ind));

  Text datingTxt = DatingName(ind);
  Set  EvalSet(Dates(SerTms(ind)*In(f,l),f,l), Set(Date d)
  {
    InputExpression
    (
      0.1,
      Text p = "Pulse"+label+Dte2TxtC(d);
      Text e = "Pulse("+Dte2TxtC(d)+","+datingTxt+")"
    )
  })
};

//////////////////////////////////////////////////////////////////////////////
Set ExtractField(Set set, Text field)
//////////////////////////////////////////////////////////////////////////////
{
  If(IsEmpty(set), Empty,
  {
    EvalSet(set, Anything(Set reg){ Eval("Anything reg->"+field) })
  })
};
//////////////////////////////////////////////////////////////////////////////
PutDescription
(
"Retorna los elementos del campo argumento del conjunto set.",
ExtractField);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set ExtractSetField(Set set, Set setField)
//////////////////////////////////////////////////////////////////////////////
{
  If(Or(IsEmpty(set), IsEmpty(setField)), Empty,
  {
    EvalSet(set, Anything(Set reg) {
      EvalSet(setField, Anything (Text field) {
        Eval("Anything reg->"+field)
      })
    })
  })
};
//////////////////////////////////////////////////////////////////////////////
PutDescription
("Retorna los elementos de los campos argumento especificados en setField del
conjunto set.",
ExtractSetField);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set GetPolynDegrees
(
  Polyn pol
)
//////////////////////////////////////////////////////////////////////////////
{ EvalSet(Monomes(pol), Real(Polyn monome){ Degree(monome) }) };
//////////////////////////////////////////////////////////////////////////////
PutDescription
(
  "Retorna el conjunto de los grados de un polinomio de los monomios no 
   nulos.",
  GetPolynDegrees
);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set ReverseSet(Set set)
//////////////////////////////////////////////////////////////////////////////
{ If(IsEmpty(set), set, ExtractByIndex(set, Range(Card(set), 1, -1))) };
//////////////////////////////////////////////////////////////////////////////
PutDescription
(
  "Retorna el conjunto en orden inverso.",
  ReverseSet
);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set RandSet(Real rea)
//////////////////////////////////////////////////////////////////////////////
{
  Set randSet = Copy(Empty);
  Real conta  = 1;
  Real While(LT(Card(randSet), rea), 
  {
    Real k0 = Floor(Rand(0, rea)+1);
    Set  (randSet := randSet + SetOfReal(k0));
    Real (conta   := conta + 1);
    conta
  });
  randSet
};
//////////////////////////////////////////////////////////////////////////////
PutDescription
(
  "Construye un conjunto de k elementos a través de la extracción uniforme
   de k elementos desde 1 hasta k.",
  RandSet
);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set RandExtract(Set set)
//////////////////////////////////////////////////////////////////////////////
{ ExtractByIndex(set, RandSet(Card(set))) };
//////////////////////////////////////////////////////////////////////////////
PutDescription
(
  "Realiza una extraccion aleatoria de los elementos de un conjunto, 
   devolviendo el conjunto compuesto por dicha extraccion.",
  RandExtract
);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
  Struct @DimMatrixSt
//
// PURPOSE : Estructura que define la dimension de una matriz
//
//////////////////////////////////////////////////////////////////////////////
{
  Real Rows,
  Set RowsCols
};

//////////////////////////////////////////////////////////////////////////////
// Funciones
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
  Set AdjustSetSer(Set setSer)
//////////////////////////////////////////////////////////////////////////////
{
  Set ft     = EvalSet(setSer,First);
  Set lt     = EvalSet(setSer,Last);
  Date ftMax = BinGroup("Max",ft);
  Date ltMin = BinGroup("Min",lt);
  Set  adjustSetSer = EvalSet(setSer, Serie(Serie ser)
  { 
    Text name = Name(ser);
    Text nm = If(name=="","",Name(ser)+".ass = ");
    Eval("Serie "+nm+"SubSer(ser, ftMax, ltMin);"
  ) })
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Set AdjustSetSer (Set setSer):\n"
"Retorna el conjunto de series ajustadas al menor de los finales y al maximo
de los inicios del conjunto de series <setSer>.", AdjustSetSer);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
  Set SerIdePer(Serie ser01, Serie ser02)
//////////////////////////////////////////////////////////////////////////////
{
  Set setOfSerie = SetOfSerie(ser01, ser02);
  AdjustSetSer(setOfSerie)
};  
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Devuelve las dos series que se pasan como argumentos en el periodo comun, es
decir entre el maximo de sus fechas iniciales y el minimo de sus fechas
finales.",
SerIdePer);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
  Set DimMat (Matrix mat)
//
// PURPOSE: Devuelve el conjunto formado por las filas y las columnas de la 
//          matriz <mat>.
//
//////////////////////////////////////////////////////////////////////////////
{
  Real rows    = Rows(mat);
  Set rowsCols = [[rows,Columns(mat)]];
  DimMatrixSt(rows,rowsCols)
};

PutDescription(
"Set DimMat (Matrix mat):\nDevuelve el conjunto formado por las filas y las"
" columnas de la matriz <mat>.",DimMat);

//////////////////////////////////////////////////////////////////////////////
Set CartProdSet(Set s)
//////////////////////////////////////////////////////////////////////////////
{
  Real c = Card(s);
  If(EQ(c, 0), Empty,
  If(EQ(c, 1), s,
  If(EQ(c, 2), CartProd(s[1],s[2]),
  {
    Set saux = CartProd(s[1],CartProdSet(ExtractByIndex(s, Range(2,c,1))));
    EvalSet(saux, Set(Set set){SetOfAnything(set[1])<<set[2]})     
  })))
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Construye el producto cartesiano de un conjunto de conjuntos",
CartProdSet);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set NCartProd(Set s, Real n)
//////////////////////////////////////////////////////////////////////////////
{ CartProdSet(NCopy(n, s)) };
//////////////////////////////////////////////////////////////////////////////
PutDescription("Construye el producto cartesiano de un conjunto s 
consigo mismo n veces.",
NCartProd);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set DatesInd(Serie ind)
//////////////////////////////////////////////////////////////////////////////
{
  Select(Dates(Dating(ind), First(ind), Last(ind)), Real(Date dte)
  {
    SerDat(ind, dte)
  })
};

//////////////////////////////////////////////////////////////////////////////
Set Combination(Set s, Real n)
//////////////////////////////////////////////////////////////////////////////
{
  Real m = Card(s);
  Real k = Round(n);
  Set Result = Case(
    Or(m<k,k<=0), {
      Text WriteLn("Warning: No se pueden hacer combinaciones de "+IntText(n)+" elementos en un conjunto de "+IntText(Card(s))+" elementos.");
      Copy(Empty)
    },
    m==k, [[ Copy(s) ]],
    m>k,  {
      Set sb = For(2, m, Anything (Real k){ s[k] });
      Set aux1 = If(k-1>0,
        EvalSet(Combination(sb,k-1), Set(Set s1){ [[ s[1] ]]<<s1 }),
        SetOfSet([[ s[1] ]])
      );
      Set aux2 = Combination(sb,k);
      Copy(aux1+aux2)
    }
  )
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Genera todas las combinaciones de tamaño n con los elementos 
del conjunto s. Si Card(s)<n o n<=0, devuelve vacío.",Combination);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set Anualiza(Serie ser, Real yearIni)
//////////////////////////////////////////////////////////////////////////////
{
  Real minYear = If(IsUnknown(yearIni), Year(First(ser)), yearIni);
  Real maxYear = Year(Last(ser));
  Set setSerYear = EvalSet(Range(minYear, maxYear, 1), Serie(Real year)
  {
    Date  end = Succ(YMD(year+1, 1, 1), Dating(ser), -1);
    Serie serYear = SubSer(ser, YMD(year, 1, 1), end);
    Real  tras = DateDif(Dating(ser), YMD(minYear, 1, 1), YMD(year, 1, 1));
    Eval("Serie "+ Name(ser) +"."+ IntText(year) +" = (F^tras):serYear;")
  });
  Eval("Set "+ Name(ser) +".Anualiza = setSerYear;")
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Construye un Serie para cada uno de los años de la Serie
proporcionada", Anualiza);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set AnualizaEqualWD(Serie ser, Real yearIni)
//////////////////////////////////////////////////////////////////////////////
{
  Set setSerYear =
  If(Not(Or(DatingName(ser) == "Diario", DatingName(ser) == "Diario")),
  { Text WLERROR("AnualizaEqualWD:\nFechado no Diario"); Empty },
  {
    Real minYear = If(IsUnknown(yearIni), Year(First(ser)), yearIni);
    Real maxYear = Year(Last(ser));
    Real fstWdMinYear = WeekDay(YMD(minYear, 1, 1));
    Set EvalSet(Range(minYear, maxYear, 1), Serie(Real year)
    {
      Serie serYear = SubSer(ser, YMD(year, 1, 1), YMD(year, 12, 31));
      Real  tras = DateDif(C, YMD(minYear, 1, 1),
                              Succ(YMD(year-1, 12, 31), WD(fstWdMinYear), 1));
      Eval("Serie "+ Name(ser) +"."+ IntText(year) +" = (F^tras):serYear;")
    })
  });
  Eval("Set "+ Name(ser) +".AnualizaEqualWD = setSerYear;")
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Construye un Serie para cada uno de los años de la Serie
proporcionada llevando el comienzo al mismo dia de la semana. La Serie
proporcionada ha de estar en fechado Diario.", AnualizaEqualWD);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set SetSerWD(Anything setSerOrSerDia)
//////////////////////////////////////////////////////////////////////////////
{
  Set setSerWD.OneSerie(Serie serDia)
  {
    Text nameSerDia = ToTolName(Name(serDia));
    Set sWD = For(1, 7, Serie(Real numWD)
    {
      Eval("Serie "+ nameSerDia +".wd"+ IntText(numWD) +" =
            DatChUsu((F^(numWD-1)):serDia, Semanal, FirstS);")
    });
    Eval("Set "+ nameSerDia +".WD = sWD;")
  };

  Text gram = Grammar(setSerOrSerDia);
  Case(
  gram == "Serie", setSerWD.OneSerie(setSerOrSerDia),
  gram == "Set",
  {
    Set sWD.SS = Group("Concat", EvalSet(setSerOrSerDia, setSerWD.OneSerie));
    Eval("Set WD."+ ToTolName(Name(setSerOrSerDia)) +".WD = sWD.SS;")
  },
  1, { Text WLERROR("SetSerWD:\n Unknown grammar"); Copy(Empty)})
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Construye una Serie para cada dia de la semana. El fechado de
la Serie proporcionada ha de estar en base Diaria. Las Series resultado estan
en fechado Semanal", SetSerWD);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set GuiConcatSetCol(Set s)
//////////////////////////////////////////////////////////////////////////////
{
  Set ConcatSetCol = BinGroup("|", s);
  ConcatSetCol
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Concatena los conjuntos seleccionados por columnas",
GuiConcatSetCol);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set GuiConcatSetRow(Set s)
//////////////////////////////////////////////////////////////////////////////
{
  Set ConcatSetRow = Group("Concat", s);
  ConcatSetRow
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Concatena los conjuntos seleccionados por filas",
GuiConcatSetRow);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set TableColumns(Anything qry_OR_cto){
//////////////////////////////////////////////////////////////////////////////
  Real enOtroCaso = 1;

  Text qry_OR_cto.gram = Grammar(qry_OR_cto);

  Set ctoDatos = Case(
  // ------------
    qry_OR_cto.gram=="Text", 
    DBTable(qry_OR_cto),
  // ------------
    qry_OR_cto.gram=="Set", 
    qry_OR_cto,
  // ------------
    enOtroCaso,
  {
    WriteLn("<E>ERROR DBTableColumns: gramática de qry_OR_cto, '"+
            qry_OR_cto.gram +
            "' no contemplada</E>");
    Empty
  });

  // ---------------------------
  Text identidad(Text algo){ 
  // ---------------------------
    algo
  };

  // ---------------------------
  Real posicion(Set cto, Text elto){
  // ---------------------------
    Real card = Card(cto);
    Real cont = Copy(1);
    Text elto_i = Copy(cto[cont]);
    Real condicion = And(elto_i!=elto, LT(cont, card));

    Real While(condicion,
    {
      Real {cont := cont+1};
      Text {elto_i := cto[cont]};
      Real {condicion := And(elto_i!=elto, LT(cont, card))};
      1
    });
    If(elto_i==elto, cont, 0)
  };

  Real card = Card(ctoDatos);

  Set  ctoGram = If(Not(card), 
    SetOfText("", "", ""), 
    If(NE(Card(ctoDatos[1]), 3), 
      {WriteLn("<E>ERROR TableColumns: La consulta debe tener tres campos</E>");
       SetOfText("", "", "")
      }, 
      SetOfText(Grammar(ctoDatos[1][1]), 
                Grammar(ctoDatos[1][2]), 
                Grammar(ctoDatos[1][3])))
   );


  Text gram_pre = ctoGram[1];
  Text gram_ind = ctoGram[2];
  Text gram_dat = ctoGram[3];

  Code funcionText_pre = Case(gram_pre=="Real", FormatReal,
                              gram_pre=="Date", FormatDate,
                              enOtroCaso      , identidad);

  Code funcionText_ind = Case(gram_ind=="Real", FormatReal,
                              gram_ind=="Date", FormatDate,
                              enOtroCaso      , identidad);

  Code funcionText_dat = Case(gram_dat=="Real", FormatReal,
                              gram_dat=="Date", FormatDate,
                              enOtroCaso      , identidad);

  Set indices = {
    Set c01 = Extract(ctoDatos, 2);
    Set c02 = For(1, card, Text(Real i){
       funcionText_ind(c01[i][1])
    });
    Set c03 = Unique(c02);
    Sort(c03, Real(Text t1, Text t2){ Compare(t1, t2) })
  };

  Set prefijos = {
    Set c01 = Extract(ctoDatos, 1);
    Set c02 = For(1, card, Text(Real i){
       funcionText_pre(c01[i][1])
    });
    Set c03 = Unique(c02);
    Sort(c03, Real(Text t1, Text t2){ Compare(t1, t2) })
  };

  Set prefijos_indices = For(1, Card(indices), Set(Real i){
    Set cto = For(1, Card(prefijos), Text(Real j){ "" });
    cto
  });

  Set EvalSet(ctoDatos, Real(Set reg){
    Text reg_pre = funcionText_pre(reg[1]);
    Text reg_ind = funcionText_ind(reg[2]);
    Text reg_dat = funcionText_dat(reg[3]);

    Real pos_i = posicion(indices, reg_ind);
    Real pos_j = posicion(prefijos, reg_pre);
    Text elto  = reg_dat;
    Text {prefijos_indices[pos_i][pos_j] := Copy(elto)};
    1
  });

  Set ctoIndices = EvalSet(indices, Set(Text t){ SetOfText(t) });

  Set ctoPrefijos = SetOfSet(SetOfText("indices / prefijos") << prefijos);

   ctoPrefijos << (ctoIndices | prefijos_indices)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Dada una consulta que devuelve tres campos y sólo tres, crea un conjunto-tabla
donde las columnas serán el primer campo (prefijo), y las filas serán el segundo
(índice).

La primera fila del Set resultante serán los nombres de los prefijos.
La primera columna del Set resultante serán los nombres de los índices.
¡¡¡ TODO lo que se devuelve dentro del conjunto es de tipo Text !!!, por lo tanto, el 
orden que se sigue tanto en los prefijos como en los índices es el lexicográfico;
las máscaras utilizadas en FormatReal() y en FormatDate son las que usa Tol por 
defecto.
", TableColumns);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set Share(Set setSer)
//////////////////////////////////////////////////////////////////////////////
{
  Set   setSerAdj = AdjustSetSer(setSer);
  Serie serSum    = SetSum(setSerAdj);
  Set share = EvalSet(setSerAdj, Serie(Serie subSer)
  { 
    Text name = Name(subSer);
    Text nm = If(name=="","",Replace(name, ".ass", "")+".share = ");
    Eval("Serie "+ nm +  "subSer / (serSum + Not(serSum));") 
  })
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("A partir de un conjunto de series devuelve las series-cuota
de cada una de ellas respecto a la suma de todas.",
Share);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set ShareAcum(Set setSer)
//////////////////////////////////////////////////////////////////////////////
{
  Set setSer.share = Share(setSer);
  Real numSer      = Card(setSer);

  Set shareAcum = For(1, numSer, Serie(Real nSer)
  {
    Set nSetSer = ExtractByIndex(setSer.share, Range(1, nSer, 1));
    Eval("Serie "+ Name(setSer.share[nSer]) +".acum = SetSum(nSetSer);")
  })
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("A partir de un conjunto de series devuelve las series-cuota
acumuladas de cada una de ellas respecto a la suma de todas.",
ShareAcum);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set InnerJoin(Set tabla01, Set tabla02, Anything paramOmit)
//////////////////////////////////////////////////////////////////////////////
{
  Set tabla01_sort = Sort(tabla01, Real(Set reg01, Set reg02){
    Compare(reg01[1], reg02[1])
  });

  Set tabla02_sort = Sort(tabla02, Real(Set reg01, Set reg02){
    Compare(reg01[1], reg02[1])
  });

  Set indice01 = Extract(tabla01_sort, 1 );
  Set indice02 = Extract(tabla02_sort, 1 );
  Set indice0102 = Unique(indice01 + indice02);

  Set indice0102_sort = Sort(indice0102, Real(Set reg01, Set reg02){
    Compare(reg01[1], reg02[1])
  });
  
  Set indice = Traspose(indice0102_sort)[1];

  Set union = For(1, Card(indice), Set(Real k){
    Set cto01 = Select(tabla01_sort, Real(Set reg){
      EQ(Compare(reg[1], indice[k]), 0)
    });

    Set cto02 = Select(tabla02_sort, Real(Set reg){
      EQ(Compare(reg[1], indice[k]), 0)
    });
   
    Set reg01 = If(Card(cto01), SetOfAnything(cto01[1][2]), SetOfAnything(paramOmit));
    Set reg02 = If(Card(cto02), SetOfAnything(cto02[1][2]), SetOfAnything(paramOmit));

    SetOfSet(SetOfAnything(indice[k]), reg01, reg02)
  });

   Traspose(union)[1] | Traspose(union)[2] | Traspose(union)[3]
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Concatena dos columnas de dos conjuntos-tabla con una columna
índice común (no necesariamente ambos conjuntos deben tener el mismo número
de registros), rellenando con el valor paramOmit que le pasamos como parámetro
los omitidos de cada conjunto en alguno de los registros del conjunto resultante.
", InnerJoin);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set FullPermutations(Set Objects)
//////////////////////////////////////////////////////////////////////////////
{
    Set perms = EvalSet(Objects, Set (Anything i)
    {
        Set Rest = Objects - [[i]];
        Set res=If(Not(IsEmpty(Rest)),
          {
            Set permRest = FullPermutations(Rest); 
            Set res = EvalSet(permRest, Set (Set perm)
            {
               [[Anything _i=i]]<<perm
            })
          },
          SetOfSet([[Anything _i=i]]))
    });
    Set perm = Group("Concat", perms)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Genera todas las permutaciones para un conjunto de objetos, y
retorna dichas permutaciones en un conjunto en que cada elemento es una
permutación. Esta función es recursiva y puede causar stack overflow en
conjuntos muy grandes. Debe usarse siempre bajo esta consideración.
", FullPermutations);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set ExpandSetSer(Set setSer)
//////////////////////////////////////////////////////////////////////////////
{
  Set ft     = EvalSet(setSer,First);
  Set lt     = EvalSet(setSer,Last);
  Date ftMin = BinGroup("Min",ft);
  Date ltMax = BinGroup("Max",lt);
  Set  expandSetSer = EvalSet(setSer, Serie(Serie ser)
  { Eval("Serie "+ Name(ser) +".ess = ExtendSerie(ser, ftMin, ltMax);") })
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("Set ExpandSetSer(Set setSer):\n"
"Retorna el conjunto de series ajustadas al mayor de los finales y al menor
de los inicios del conjunto de series <setSer>.", ExpandSetSer);
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
  Set BDTAppendToFile(Set series, Text fileName)
//////////////////////////////////////////////////////////////////////////////
{
  If(!FileExist(fileName),
    Set BDTFile(series,fileName,"_DEFAULT_HEADER_",1),
    Set BDTFile(series,fileName,"",                0) )
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
"It adds data of a set of series to a file with format BDT.\n"
"If the file does not exist also writes the head of the file with "
"the dating and the name of the series.  It does not verify if "
"already data for those dates exist nor the existing serial number "
"in the file."
,
"Añade datos de un conjunto de series a un fichero con formato BDT.\n" 
"Si el fichero no existe escribe también la cabecera del fichero con "
"el fechado y el nombre de las series.\n"
"No comprueba si ya existen datos para esas fechas ni el número de "
"series existentes en el fichero."), 
BDTAppendToFile);
//////////////////////////////////////////////////////////////////////////////


  
//////////////////////////////////////////////////////////////////////////////
  Set IncludeLocalTol(Text fileName)
//////////////////////////////////////////////////////////////////////////////
{
  Do IncludeText(ReadFile(fileName))
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
"Includes a tol file in a local way, so its elements are not vissible from "
"calling scope."
,
"Incluye un fichero tol de forma local sin que sus elementos sean visibles "
"desde el ámbito de la llamada."), 
IncludeLocalTol);
//////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
  Real CheckBST(Set set, Text path)
/////////////////////////////////////////////////////////////////////////////
{
//WriteLn("CheckBST("<<Card(set)+","+path);
  Real OSFilRemove(path);
  Set Do BSTFile(set,path);
  Real check = If(Card(set),
  {
    Real oldShow = Show(0,"STANDARD");
    Set aux = Include(path);
    Real Show(oldShow,"STANDARD");
    Card(aux)==Card(set)
  },
  {
    !FileExist(path)
  })
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
"Creates a BST file and checks it all has worked fine",
"Crea un archivo BST y se asegura de que todo ha ido bien"),
CheckBST); 
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
  Real CheckBDT(Set series, Text path)
/////////////////////////////////////////////////////////////////////////////
{
//WriteLn("CheckBDT("<<Card(series)+","+path);
  Real OSFilRemove(path);
  Set Do BDTFile(series,path);
  Real check = If(Card(series),
  {
    Real oldShow = Show(0,"STANDARD");
    Set aux = Include(path);
    Real Show(oldShow,"STANDARD");
    Card(aux)==Card(series)
  },
  {
    !FileExist(path)
  })
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
"Creates a BDT file and checks it all has worked fine",
"Crea un archivo BDT y se asegura de que todo ha ido bien"),
CheckBDT); 
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
  Real CheckBMT(Matrix mat, Text path)
/////////////////////////////////////////////////////////////////////////////
{
  Real OSFilRemove(path);
  Set Do BMTFile([[mat]],path);
  Real check = 
  {
    Real oldShow = Show(0,"STANDARD");
    Matrix aux = Include(path)[1];
    Real Show(oldShow,"STANDARD");
    And(Rows   (aux)==Rows   (mat),
        Columns(aux)==Columns(mat))
  }
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
"Creates a BMT file and checks it all has worked fine",
"Crea un archivo BMT y se asegura de que todo ha ido bien"),
CheckBMT); 
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set SelectIndexByName(Set a, Set b)
//////////////////////////////////////////////////////////////////////////////
{
  Real a.card = Card(a); 
  Real b.card = Card(b); 
  Case(Or(!a.card,!b.card), 
  {
    Copy(Empty)
  },
  Or(!HasIndexByName(b)),
  {
    WriteLn(I2(
    "Cannot apply SelectIndexByName to a non indexed by name set 'b'.",
    "No se puede aplicar SelectIndexByName a un conjunto 'b' no "
    "indexados por nombre."),
    "E");
    Copy(Empty)
  },
  1==1,
  {
    Real GT0 (Real idx) { idx>0 };
    Set idx = EvalSet(a, Real(Anything obj)
    {
      FindIndexByName(b, Name(obj))
    });
    Select(idx,  GT0)
  })
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
"Returns the set of indexes of elements of 'a' which there is in indexed by "
"name set 'b' an element with the same name.",
"Devuelve el conjunto de índices de los elementos 'a' tales que en el "
"conjunto indexado por nombre 'b' existe un elemento del mismo nombre.\n"),
SelectIndexByName); 
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set IntersectIndexByName(Set a, Set b)
//////////////////////////////////////////////////////////////////////////////
{
  Real a.card = Card(a); 
  Real b.card = Card(b); 
  Case(
  Or(!HasIndexByName(a), !HasIndexByName(b)),
  {
    WriteLn(I2(
    "Cannot apply IntersectIndexByName to non indexed by name sets.",
    "No se puede aplicar IntersectIndexByName a conjuntos no "
    "indexados por nombre."),
    "E");
    Copy(Empty)
  },
  a.card > b.card, 
  {
    Set selIdx = SelectIndexByName(b, a);
    ExtractByIndex(a, selIdx)
  },
  1==1,
  {
    Set selIdx = SelectIndexByName(a, b);
    ExtractByIndex(b, selIdx)
  })
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
"Returns intersection of two sets that are indexed by name",
"Devuelve la intersección de dos conjuntos indexados por nombre"),
IntersectIndexByName); 
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set SetTolNameAndIndex(Set names)
//////////////////////////////////////////////////////////////////////////////
{
  Real n = Card(names);
  Set aux = For(1, n, Text(Real k)
  {
    Eval(ToName(names[k])+"=\""+names[k]+"\"")
  });    
  Real If(n, SetIndexByName(aux));
  aux
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
"Put valid TOL names to a set of texts and indexes it",
"Pone nombres válidos a un conjunto de textos y lo indexa"),
SetTolNameAndIndex); 
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set Col2Set(Matrix M)
//////////////////////////////////////////////////////////////////////////////
{
  MatSet(Tra(M))[1]
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
"Returns a set of real numbers with elements of a column vector",
"Devuelve un conjunto de números reales con los elementos de un vector "
"columna"),
Col2Set); 
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set Row2Set(Matrix M)
//////////////////////////////////////////////////////////////////////////////
{
  MatSet(M)[1]
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
"Returns a set of real numbers with elements of a row vector",
"Devuelve un conjunto de números reales con los elementos de un vector "
"fila"),
Row2Set); 
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set VCol2Set(VMatrix M)
//////////////////////////////////////////////////////////////////////////////
{
  MatSet(VMat2Mat(M,1))[1]
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
"Returns a set of real numbers with elements of a column vector",
"Devuelve un conjunto de números reales con los elementos de un vector "
"columna"),
VCol2Set); 
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set VRow2Set(VMatrix M)
//////////////////////////////////////////////////////////////////////////////
{
  MatSet(VMat2Mat(M,0))[1]
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
"Returns a set of real numbers with elements of a row vector",
"Devuelve un conjunto de números reales con los elementos de un vector "
"fila"),
VRow2Set); 
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set VMat2Set(VMatrix M)
//////////////////////////////////////////////////////////////////////////////
{
  MatSet(VMat2Mat(M))
};
//////////////////////////////////////////////////////////////////////////////
  PutDescription(I2(
"Converts by rows a matrix in a set of sets of real numbers.",
"Convierte por filas una matriz en un conjunto de conjuntos "
"de reales."),
VMat2Set); 
//////////////////////////////////////////////////////////////////////////////
