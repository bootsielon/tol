//////////////////////////////////////////////////////////////////////////////
// FILE: Polytope.tol
// PURPOSE: Polytope related classes and methods
//////////////////////////////////////////////////////////////////////////////


NameBlock Polytope = [[

//Forward declaration of class 
Class @Region;

//////////////////////////////////////////////////////////////////////////////
Class @Point 
// Defines a point and its situation repect to a polytope
//////////////////////////////////////////////////////////////////////////////
{
  @Region region; //@Region A*x <= a
  VMatrix x;       //@Point coordintaes
  Real isFinite;   //Check if x is well defined
  VMatrix g;       //Border distance g = A*x - a
  VMatrix G;       //Matching equations indicator: G[i] = g[i] <= 0  
  Real match;      //Global matching indicator: G[i] == 1 for all i=1..r
  VMatrix h;       //Non matching distances: h[i]=Max(0, g[i])
  Real f;          //Total non matching square distance: Sum(h[i]^2)

  ////////////////////////////////////////////////////////////////////////////
  Static Real EnsureKnown(Real aux, Real defValue)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(IsUnknown(aux), defValue, aux)
  };
  ////////////////////////////////////////////////////////////////////////////
  Static @Point New(@Region region_, VMatrix x_)
  ////////////////////////////////////////////////////////////////////////////
  { 
    @Point new = [[
      @Region region = region_;
      VMatrix x = x_;
      Real drop = region::r*region::n*1.E-15;
      Real isFinite = (VMatSum(IsFinite(x))==VRows(x));
      VMatrix g = region::evalBorderDistance(x);
      Real match = @Point::EnsureKnown(VMatMax(g)<=
                                      drop, 0);
      VMatrix G = GT(g, region::zero);
      VMatrix h = Max(region::zero,g);
      Real f = 
      {
        Real aux = @Point::EnsureKnown(VMatSum(RPow(h,2)), 1/0);
        Max(aux,drop^2) 
      }
    ]];
    new
  }
};
    
//////////////////////////////////////////////////////////////////////////////
Class @ScalarMin
// Class used fo minimize total non matching square distance (P::f) in a 
// segment [a,b] of a given direction v around a central point P0
// 
//   min P::f
// 
//   where 
// 
//     P = P0 + t*v ;  
//     a <= t <= b
// 
//////////////////////////////////////////////////////////////////////////////
{
  @Point P0;
  @Point P;
  VMatrix v = Rand(0,0,0,0);
  Real a = -100;
  Real b = +100;
  Real tol = 1.E-10;
  Text lastIterMethod = "";

  ////////////////////////////////////////////////////////////////////////////
  Real evalSegmentPoint(Real t)
  ////////////////////////////////////////////////////////////////////////////
  {
    @Point P_ = @Point::New(P0::region, P0::x + v*t);
//  WriteLn("TRACE @ScalarMin::evalSegmentPoint "
//          "lastIterMethod="+lastIterMethod+
//          " t="<<t+
//          " P_::f="<<P_::f);
    Real If(P_::isFinite & (P_::f <= P0::f), { @Point  P := P_; True });
    P_::f
  };

  ////////////////////////////////////////////////////////////////////////////
  Real minimize(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(VMatSum(IsUnknown(v)), 
    {
      If(P::region::verbose>1,
      {
        WriteLn("[@ScalarMin::minimize] Non valid direction"
                " lastIterMethod="+lastIterMethod)
      });
      False
    },
    {
      Real min = ?;
      Real tMin = FibonacciMin(evalSegmentPoint, min,  a,  b, tol);
    //WriteLn("TRACE @ScalarMin::minimize lastIterMethod="+lastIterMethod+
    //        " P::f="<<P::f);
      Real ok = And(P::isFinite, (P::f < P0::f));
      ok
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Static @ScalarMin New(@Point P0_)
  ////////////////////////////////////////////////////////////////////////////
  {
    @ScalarMin new = [[
      @Point P0 = P0_;
      @Point P = Copy(P0)
    ]]
  }
};

//////////////////////////////////////////////////////////////////////////////
Class @Region 
// Defines a @Region by a set of linear inequations
// 
//   A*x <= a
// 
//////////////////////////////////////////////////////////////////////////////
{
  VMatrix A;    //Matrix of coeffcients
  VMatrix a;    //Border
  Real    r;    //Number of inequations
  Real    n;    //Number of variables
  VMatrix zero; //Vector of r zeroes
  Real    drop; //Values under this value will be taken as zero
  VMatrix At;   //Transpose coeeffcients
  Real verbose = False;

  ////////////////////////////////////////////////////////////////////////////
  VMatrix evalBorderDistance(VMatrix x)
  // Evaluates distance to border for a point
  ////////////////////////////////////////////////////////////////////////////
  {
    Drop(A*x-a, drop)
  };

  ////////////////////////////////////////////////////////////////////////////
  Static @Region New(VMatrix A_, VMatrix a_)
  //Creates an instance of @Region
  ////////////////////////////////////////////////////////////////////////////
  {
    @Region new =
    [[
      VMatrix A = A_;
      VMatrix a = a_;
      VMatrix At = Tra(A);
      Real r = VRows(A);
      Real n = VColumns(A);
      VMatrix zero = Zeros(r,1);
      Real drop = 1.E-16*(n*r)
    ]]
  };

  ////////////////////////////////////////////////////////////////////////////
  @Point FindFeasible(VMatrix x0, Real maxIter, Real verbose_) 
  //Finds a feasible point of the polytope by means of a battery of methods:
  // 1) Newton-Raphson
  // 2) Stepest descent
  // 3) Alternate variable
  // 4) Random jump
  ////////////////////////////////////////////////////////////////////////////
  {
    Real verbose := verbose_;
    @Point P = @Point::New(_this, x0);
    Real iter = 1;
    @ScalarMin sm = @ScalarMin::New(P);
    Text If(verbose, sm::lastIterMethod := "initial");
    While(And(Not(P::match), (P::f>=TheMinAbsValue), iter<=maxIter), {
      If(verbose, WriteLn("FindFeasible " 
      "f["<<iter+"]="<<P::f+" -> "<<P::match+" method:"+sm::lastIterMethod));
      VMatrix grad = At * P::h * 2;
      VMatrix hess = At * Eye(r,r,0,P::G) * A * 2;
      Text If(verbose, sm::lastIterMethod := "Newton-Raphson");
/* * /
      NameBlock sps = SolvePrecondSym(hess, False);
      Real sps::ScaleOptimize(drop);
      NameBlock solution = sps::Solve(grad,drop,true);
      VMatrix sm::v := solution::_.x; 
/* */
      VMatrix sm::v := -MinimumResidualsSolve(hess, grad); 
/* */
      Real ok = If(sm::minimize(0),
      {
        @Point P := sm::P;
        True
      },
      {
        Text If(verbose, sm::lastIterMethod := "step descent");
        VMatrix sm::v := grad;
        Real If(sm::minimize(0),
        {
          @Point P := sm::P;
          True
        },
        {
          Text If(verbose, sm::lastIterMethod := "alternate variable");
          Real k=1;
          Real ok = False;
          While(And(k<=n, !ok),
          {
            VMatrix sm::v := Convert(Triplet(SetRow([[k,1,1]]),n,1),
                               "Cholmod.R.Sparse");
            Real ok := sm::minimize(0);
            Real k:= k+1
          }); 
          If(ok,
          {
            @Point P := sm::P;
            True
          },
          {
            Text If(verbose, sm::lastIterMethod := "random jump");
            @Point P := @Point::New(_this, P::x + Rand(n,1,-1,1));
            False
          })
        })
      }); 
      Real iter := iter + 1
    });
    If(verbose, WriteLn("FindFeasible "
       "f["<<iter+"]="<<P::f+" -> "<<P::match+ " method:"+sm::lastIterMethod));
    P
  };

  ////////////////////////////////////////////////////////////////////////////
  @Point FindFeasible.QP.MinNorm(Real verbose_) 
  //Finds the minimum norm feasible point of the polytope using quadprog
  ////////////////////////////////////////////////////////////////////////////
  {
    Matrix  Dt    = VMat2Mat(Tra(A));
    Matrix  d     = VMat2Mat(a);
    Matrix  XtX   = Diag(n,1);
    Matrix  XtY   = Rand(n,1,0,0);
    Matrix  cnstr = Rquadprog::solveQP(XtX, XtY, -Dt, -d,
                                      {[[Real verbose=verbose_]]})[1];
    @Point P = @Point::New(_this, Mat2VMat(cnstr))
  };

  ////////////////////////////////////////////////////////////////////////////
  @Point FindFeasible.QP.MLE(VMatrix X, VMatrix Y, Real verbose_) 
  //Finds the maximum likelihood feasible point of the polytope using quadprog
  ////////////////////////////////////////////////////////////////////////////
  {
    Matrix  Dt    = VMat2Mat(Tra(A));
    Matrix  d     = VMat2Mat(a);
    Matrix  XtX   = VMat2Mat(MtMSqr(X));
    Matrix  XtY   = VMat2Mat(Tra(Tra(Y)*X));
    Matrix  cnstr = Rquadprog::solveQP(XtX, XtY, -Dt, -d,
                                      {[[Real verbose=verbose_]]})[1];
    @Point P = @Point::New(_this, Mat2VMat(cnstr))
  }

};


  ////////////////////////////////////////////////////////////////////////////
  VMatrix FindFeasible(VMatrix A, VMatrix a, 
                       VMatrix x0, Real maxIter, Real verbose)
  ////////////////////////////////////////////////////////////////////////////
  {
    @Region R = @Region::New(A, a);
    @Point  P = R::FindFeasible(x0, maxIter, verbose);
    P::x
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix FindFeasible.QP.MinNorm(VMatrix A, VMatrix a, 
                                  Real verbose)
  ////////////////////////////////////////////////////////////////////////////
  {
    @Region R = @Region::New(A, a);
    @Point  P = R::FindFeasible.QP.MinNorm(verbose);
    P::x
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix FindFeasible.QP.MLE(VMatrix A, VMatrix a, 
                              VMatrix X, VMatrix Y, Real verbose)
  ////////////////////////////////////////////////////////////////////////////
  {
    @Region R = @Region::New(A, a);
    @Point  P = R::FindFeasible.QP.MLE(X,Y,verbose);
    P::x
  };

  ////////////////////////////////////////////////////////////////////////////
  Real IsFeasible(VMatrix A, VMatrix a, VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatMax(A*x - a)<=0
  }


]];



