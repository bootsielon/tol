////////////////////////////////////////////////////////////////////////////////
// FILE: Rglpk.tol
// PURPOSE: TOL API for R package Rglpk
////////////////////////////////////////////////////////////////////////////////

NameBlock Rglpk =
[[
  //Acknowledgements
  Text _R_citation(Real void) {
  "R Development Core Team (2007). R: A language and environment for "
  "statistical computing. R Foundation for Statistical Computing, "
  "Vienna, Austria. ISBN 3-900051-07-0, \n"
  "URL http://www.R-project.org.\n"};

  Text _Rglpk_citation(Real void) {
  "Kurt Hornik and Stefan Theussl. Rglpk:"
  "R interface to the GNU Linear Programing Kit (GLPK version 4.25). "
  "R package version 0.1-7. GLPK is open source software for solving "
  "large-scale linear programming (LP), mixed integer linear programming "
  "(MILP) and other related problems.\n"
  "URL http://www.gnu.org/software/glpk/\n"};

  //read only autodoc
  Text _.autodoc.description =
  "TOL API for R package Rglpk \n"+
  "External requirements:\n"
  " 1. Install R (>=2.6.0) and ensure that is added to system path "
  "environment\n"
  " 2. Installing R Rglpk package\n"
  "Acknowledgements:\n"+
     _R_citation(0)+"\n"+
     _Rglpk_citation(0);
  
  Set _.autodoc.authors = [["josp@tol-project.org"]];

  Text _cwd = GetAbsolutePath(".");
  Text _tolRglpk.R = _cwd+"/"+ "tolRglpk.R";
  Text _tmpdir = Replace(TmpDir, "\\", "/");
  Text _om.bbm = _tmpdir+"/"+"om%S.bbm";
  Text _rhs.bbm = _tmpdir+"/"+"rhs%S.bbm";
  Text _lower.bbm = _tmpdir+"/"+"lower%S.bbm";
  Text _upper.bbm = _tmpdir+"/"+"upper%S.bbm";
  Text _result.bbm = _tmpdir+"/"+"result%S.bbm";

  //////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.solveLP =
  "Rglpk::solveLP is a function to interface with the R function "
  "Rglpk_solve_LP \n"
  "\n"
  "URL http://www.R-project.org.\n"
  "\n"
  "Description\n"
  "solveLP is High level interface to the GNU Linear Programming Kit for "
  "solving linear as well as mixed integer linear programming problems "
  "(MILPs)\n"
  "\n"
  "Arguments:\n"
  "\n"
  "   C: a vector with the objective coefficients.\n"
  "\n"
  "   A: a matrix of the constraint coefficients.\n"
  "\n"
  "   RHS: the right hand side of the constraints.\n"
  "\n"
  "with the following extra args given in the Set optArgs:\n"
  "\n"
  "   dir: a character Set with the directions of the constraints.\n"
  "        Each element must be one of \"<\", \"<=\", \">\", \">=\", or\n"
  "        \"==\". Default is \"<\" for all constraints.\n"
  "\n"
  "   idxInt: a vector with indices representing which objective\n"
  "           coefficients should be of type integer. Default is Empty.\n"
  "\n"
  "   max: a boolean value giving the direction of the optimization. 'TRUE'\n"
  "        means that the objective is to maximize the objective\n"
  "        function, 'FALSE' (default) means to minimize it.\n"
  "\n"
  "bounds: Empty (default) or a Set with elements 'upper' and 'lower'\n"
  "        containing the indices and corresponding bounds of the\n"
  "        objective variables.  The default for each variable is a\n"
  "        bound between 0 and 'Inf'.\n"
  "\n"
  "\nverbose: a boolean value for turning on/off additional solver output:\n"
  "           Default: 'FALSE'.\n"
  "\n"
  "Return Value:\n"
  "\n"
  "     A list containing the optimal solution, with the following\n"
  "     components:\n"
  "\n"
  "status: an integer with status information about the solution\n"
  "        returned: 0 if the optimal solution was found, a non-zero\n"
  "        value otherwise.\n"
  "\n"
  "objval: the value of the objective function at the optimum.\n"
  "\n"
  "solution: the vector of optimal coefficients.\n"
  "\n"
  "Examples:\n"
  "\n"
  "/*\n"
  "  Simple linear program.\n"
  "  maximize:   2 x_1 + 4 x_2 + 3 x_3\n"
  "  subject to: 3 x_1 + 4 x_2 + 2 x_3 <= 60\n"
  "              2 x_1 +   x_2 +   x_3 <= 40\n"
  "                x_1 + 3 x_2 + 2 x_3 <= 80\n"
  "                x_1, x_2, x_3 are non-negative real numbers\n"
  "*/\n"
  "\n"
  "Set sol1 = {\n"
  "  Matrix obj = ((2,4,3));\n"
  "  Matrix mat = ((3,4,2),\n"
  "                (2,1,2),\n"
  "                (1,3,2));\n"
  "  Matrix rhs = ((60,40,80));\n"
  "\n"
  "  Set sol=Rglpk::solveLP(obj, mat, rhs,\n"
  "                         {[[Real verbose=TRUE, Real max=TRUE]]})\n"
  "};\n"
  "\n"
  "/*\n"
  "  Simple mixed integer linear program.\n"
  "  maximize:    3 x_1 + 1 x_2 + 3 x_3\n"
  "  subject to: -1 x_1 + 2 x_2 +   x_3 <= 4\n"
  "                       4 x_2 - 3 x_3 <= 2\n"
  "                 x_1 - 3 x_2 + 2 x_3 <= 3\n"
  "                 x_1, x_3 are non-negative integers\n"
  "                 x_2 is a non-negative real number\n"
  "*/\n"
  "\n"
  "Set sol2 = {\n"
  "  Matrix obj = ((2,1,3));\n"
  "  Matrix mat = ((-1,2,1),\n"
  "                (0,4,-3),\n"
  "                (1,-3,2));\n"
  "  Matrix rhs = ((4,2,3));\n"
  "\n"
  "  Set idxInt = [[1,3]];\n"
"\n"
  "  Set sol=Rglpk::solveLP(obj, mat, rhs,\n"
  "                         {[[Set idxInt, Real verbose=TRUE, Real max=TRUE]]})\n"
  "};\n"
  ;
  Set solveLP(Matrix C, Matrix A, Matrix RHS, Set optArgs)
  //////////////////////////////////////////////////////////////////////////////
  {
    // Prepare exchange files
    
    // Extract extra arguments
    Set dir      = getOptArg(optArgs, "dir",     Empty);
    Set idxInt   = getOptArg(optArgs, "idxInt",  Empty);
    Real max     = getOptArg(optArgs, "max",     FALSE);
    Set  bounds  = getOptArg(optArgs, "bounds",  Empty);
    Real verbose = getOptArg(optArgs, "verbose", FALSE);

    Set args.info =
      [[
        [[dir, "dir", "char"]],
        [[idxInt, "int", "int"]],
        [[max, "max", "bool"]],
        [[verbose, "verbose", "bool"]],
        [[_result.bbm, "result.bbm"]]
      ]];
    Matrix om = C << A;
    Set args.bbm =
    [[
      [[ _om.bbm,  om  ]];
      [[ _rhs.bbm, rhs ]]
    ]];
    Real If(Card(bounds), {
        Real _BuildBoundsInfo(bounds, "lower", _lower.bbm, args.info, args.bbm);
        Real _BuildBoundsInfo(bounds, "upper", _upper.bbm, args.info, args.bbm)
      });

    Text argList = Rapi::CreateArgList("Rglpk_args", args.info);
        
    Set result.names =
    [[
      _result.bbm
    ]];
    
    Text script = 
      "source('"+_tolRglpk.R+"'); "
      "Rglpk_solve_LP.TOL('"+_om.bbm+"','"+_rhs.bbm+"','%A')";

    Set result = Rapi::RunRScript(script, args.bbm, argList, result.names,
                                  verbose);
    Set [[
          Real status     = MatDat(result[1],1,1),
          Real objval     = MatDat(result[1],1,2),
          Matrix solution = Sub(result[1],1,3,1,Columns(result[1])-2)]]
  };

  Real _BuildBoundsInfo(Set argBounds, Text item, Text bound.bbm,
                        Set args.info, Set args.bbm)
  {
    Set bounds = getOptArg(argBounds, item, Empty);
    Real If (!Card(bounds), FALSE, {
        WriteLn("BuildBoundsInfo: "+item+" "+bound.bbm);
        Set Append(args.info, [[ [[bound.bbm, item]] ]]);
        Set Append(args.bbm,  [[ [[bound.bbm, SetMat(bounds) ]] ]]);
        Real 1
      })
  }

]];
