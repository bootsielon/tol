//////////////////////////////////////////////////////////////////////////////
// FILE    : _simulate.tol
// PURPOSE : functions to simulate ARIMA models
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
  Struct @ARIMASimulate
//////////////////////////////////////////////////////////////////////////////
(
  Set   ARIMA,
  Polyn AR,
  Polyn MA,
  Polyn DIF,
  Real  Sigma,
  Serie Residuals,
  Serie Noise
);


//////////////////////////////////////////////////////////////////////////////
  Polyn GenStatMon(Real unused)
//////////////////////////////////////////////////////////////////////////////
{
  Real signo = If(LT(Rand(0,4),1),-1,1);
  Real x = signo * Rand(0.05,0.95);
  Polyn mon = 1 - x * B;
//WriteLn("GenStatMon "<<mon);
  mon
};

//////////////////////////////////////////////////////////////////////////////
  Polyn GenStatRealBin(Real unused)
//////////////////////////////////////////////////////////////////////////////
{
  GenStatMon(0)*GenStatMon(0)
};


//////////////////////////////////////////////////////////////////////////////
  Polyn GenStatComplexBin(Real unused)
//////////////////////////////////////////////////////////////////////////////
{
  Real mod  = Rand(0.01,0.99);
  Real alfa = Rand(0,2*PI);
  Real x    = Sin(alfa)*mod;
  Real y    = Cos(alfa)*mod;
  Polyn bin = 1-2*x*B+(mod*B)^2;
//WriteLn("GenStatComplexBin "<<bin);
  bin
};

//////////////////////////////////////////////////////////////////////////////
  Polyn GenStatBin(Real unused)
//////////////////////////////////////////////////////////////////////////////
{
  If(LE(Rand(0,4+PI),4),GenStatRealBin(0),GenStatComplexBin(0))
};


//////////////////////////////////////////////////////////////////////////////
  Polyn GenStatPol(Real degree, Real s)
//////////////////////////////////////////////////////////////////////////////
{
  Real n1 = degree%2;
  Real n2 = degree/2;
  Polyn bin = SetProd(For(1,n2,GenStatBin));
  Polyn mon = If(n1,GenStatMon(0),1);
  ChangeBDegree(mon*bin,s)
};


//////////////////////////////////////////////////////////////////////////////
  Set RandARIMA(@ARIMADegreeStruct deg)
//////////////////////////////////////////////////////////////////////////////
{
  Real  s   = deg->Periodicity;
  Text x = IntText(s);
  Polyn ar  = GenStatPol(deg->ARDegree,s); 
//WriteLn("AR["+x+"]="<<ar);
  Polyn ma  = GenStatPol(deg->MADegree,s); 
//WriteLn("MA["+x+"]="<<ma);
  Polyn dif = (1-(B^s))^(deg->DIFDegree); 
//WriteLn("DIF["+x+"]="<<dif);
  @ARIMAStruct(s,ar,ma,dif)
};


//////////////////////////////////////////////////////////////////////////////
  Set RandARIMADegree(@ARIMADegreeRangeStruct degRange)
//////////////////////////////////////////////////////////////////////////////
{
  @ARIMADegreeStruct
  (
    degRange->Periodicity,
    IntRand(degRange->MinARDegree,  degRange->MaxARDegree),
    IntRand(degRange->MinMADegree,  degRange->MaxMADegree),
    IntRand(degRange->MinDIFDegree, degRange->MaxDIFDegree)
  )
};


//////////////////////////////////////////////////////////////////////////////
  Set RandFactARIMADegree(Set degRangeTable)
//////////////////////////////////////////////////////////////////////////////
{
  EvalSet(degRangeTable, RandARIMADegree)
};


//////////////////////////////////////////////////////////////////////////////
  Set RandFactARIMA(Set degTable)
//////////////////////////////////////////////////////////////////////////////
{
  EvalSet(degTable, RandARIMA)
};


//////////////////////////////////////////////////////////////////////////////
  Set RandARIMAStruct(Real period,   Real maxDifDeg, 
                      Real maxARDeg, Real maxMADeg)
//////////////////////////////////////////////////////////////////////////////
{
  Text s = InText(period);
  Polyn ar = GenStatPol(Rand(0,maxARDeg ), period);
//WriteLn("AR["+s+"]="<<ar);
  Polyn ma = GenStatPol(Rand(0,maxMADeg ), period);
//WriteLn("MA["+s+"]="<<ma);
  Polyn dif = (1-(B^period))^Rand(0,maxDifDeg);
//WriteLn("DIF[+s+]="<<dif);
  @ARIMAStruct
  ( 
    period, 
    ar, 
    ma, 
    dif
  )
};


//////////////////////////////////////////////////////////////////////////////
  Set RandRangeArimaModel(TimeSet dating, 
                          Serie initValues,
                          Date first, Date last,
                          Real per, Real sigma,
                          Set R1, Set R6)
//////////////////////////////////////////////////////////////////////////////
{
 Set RT = [[R1,RS]];
  
 Set ARTD=EvalSet(RT,Set(@ARIMADegreeRangeStruct deg)
 {
    Real s = deg->Periodicity;
    @ARIMADegreeRangeStruct
    (
      s,
      deg->MinARDegree,
      deg->MaxARDegree,
      deg->MinMADegree,
      deg->MaxMADegree,
      deg->MinDIFDegree,
      deg->MaxDIFDegree
    )
 });

  Set RTD = EvalSet(RT, Set(@ARIMADegreeRangeStruct deg)
  {
    Real s = deg->Periodicity;
    @ARIMADegreeRangeStruct
    (
      s,
      s*deg->MinARDegree,
      s*deg->MaxARDegree,
      s*deg->MinMADegree,
      s*deg->MaxMADegree,
      s*deg->MinDIFDegree,
      s*deg->MaxDIFDegree
    )
  });
 
  Set GR = 
  {
    Set t = Traspose(RTD);
    @ARIMADegreeRangeStruct
    (
      SetSum(t[1]),
      SetSum(t[2]),
      SetSum(t[3]),
      SetSum(t[4]),
      SetSum(t[5]),
      SetSum(t[6]),
      SetSum(t[7])
    )
  };
  
//Set Table(SetOfSet(RT<<[[GR]]),"Std");
  
  Set USet1  = GenerateDifference(R1);
  Set USetS  = GenerateDifference(RS);
  Set USet   = GenerateDifferenceSet(RT);
  
  
  Set ADT    = RandFactARIMADegree(RT);
//Set Table(SetOfSet(RT<<[[GR]]),"Std");

  Set ARIMAT = RandFactARIMA(ADT);
  Set ARMAT  = GetARMATable(ARIMAT);

//Set Table([[ARIMAT]],"");
  
  Set GA = GroupFactARIMA(ARIMAT);
  
  Real  s   = Card(ARMAT);
  Polyn ar  = GA->AR;
  Polyn ma  = GA->MA;
  
  Polyn dif = GA->DIF;
  Polyn ari = ar*dif;
  
  Real  p  = Degree(ar);
  Real  q  = Degree(ma);
  Date  lastInit  = Succ(first,dating,-1);
  Date  firstInit = Succ(first,dating,-p-Degree(dif)-500);
  Date  firstRes  = Succ(first,dating,-q-500);
  
  Serie residuals = SubSer(Gaussian(0,sigma,dating),firstRes,last);
  
  Serie zz = DifEq(ma/ari,residuals,initValues);
  Serie noise = SubSer(zz,first,last);
  
  ARIMASimulate
  (
    ARIMAT,
    ar,
    ma,
    dif,
    sigma,
    residuals,
    noise
  )
  
};


//////////////////////////////////////////////////////////////////////////////
  Set RandArimaModel(TimeSet dating, Date first, Date last,
                     Real per, Real sigma,
                     Real maxAR, Real maxMA, Real maxDIF)
//////////////////////////////////////////////////////////////////////////////
{
  Set R1 = @ARIMADegreeRangeStruct
  (
    1,
    0, maxAR,
    0, maxMA,
    0, maxDIF
  );
  
  Set RS = @ARIMADegreeRangeStruct
  (
    per,
    0, maxAR,
    0, maxMA,
    0, maxDIF
  );
  RandRangeArimaModel(dating,forst,last,per,sigma,R1,RS)
};

//////////////////////////////////////////////////////////////////////////////
   Polyn ReversePolyn(Polyn p)

// PURPOSE: Invierte el orden de los coeficientes de un polinomio con respecto
//          al grado de los monomios   
//////////////////////////////////////////////////////////////////////////////
{
  (B^Degree(p))*ChangeBF(p)
};

//////////////////////////////////////////////////////////////////////////////
   Polyn RandSchur(Real n)

// PURPOSE: Genera un polinomio de Schur aleatorio
//////////////////////////////////////////////////////////////////////////////
{
  Real eps = 0.02;
  Real a = Rand(-1+eps, 1-eps);
//WriteLn(Trace(n)+"\t"+Trace(a));
  Polyn p = If(n==0, 1,
  If(n==1, a+B,
  {
    Polyn p1   = RandSchur(n-1);
    Polyn q1   = F*ReversePolyn(p1);
    Polyn aux  = p1+a*q1;
    Polyn aux1 = Sub(aux,0,n-2);
  //WriteLn(Trace(p1 )+" "+Trace(q1)+"\n"+
  //        Trace(aux)+" "+Trace(aux1));
    a+B*aux1+B^n
  }));
//WriteLn("p = "<<p);
  p
};

//////////////////////////////////////////////////////////////////////////////
   Polyn RandStat(Real n, Real period)

// PURPOSE: Genera un polinomio estacionario aleatorio en B^period
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("RandStat("+IntText(n)+","+IntText(period));
  Polyn p = RandSchur(n);
  Polyn q = ReversePolyn(p);
  Polyn q0 = 1+Sub(q/Coef(q,0),1,n);
  ChangeBDegree(q0,period)
}; 

//////////////////////////////////////////////////////////////////////////////
   Set RandCopyARIMA(Set ARIMA)

// PURPOSE: Genera aleatoriamente un conjunto de conjuntos con estructura 
//          ARIMA idéntica al ejemplo facilitado como parámetro. Los 
//          polinomios AR y MA generados son estacionarios
//////////////////////////////////////////////////////////////////////////////
{
  EvalSet(ARIMA, Set(@ARIMAStruct factor)
  {
    Real s = factor->Periodicity;
    @ARIMAStruct
    (
      s,
      RandStat(Degree(factor->AR)/s,s),
      RandStat(Degree(factor->MA)/s,s),
      factor->DIF
    )
  })
};

//////////////////////////////////////////////////////////////////////////////
   Set ARIMAToParam(Set arima)

// PURPOSE: Devuelve un conjunto plano con los coeficientes de los polinomios
//          (1-P(B)) donde P es cada uno de los factores AR ó MA de un conjunto
//          de conjuntos con estructura @ARIMAStruct
//////////////////////////////////////////////////////////////////////////////
{
  Set ARMAPolynSet = SetConcat(Traspose(EvalSet(arima,Set(Set factor)
  {
    [[factor->AR, factor->MA]]
  })));
  SetConcat(EvalSet(ARMAPolynSet,Set(Polyn pol)
  {
    EvalSet(Monomes(1-pol),Real(Polyn m) { Coef(m,Degree(m)) })
  }))
};

//////////////////////////////////////////////////////////////////////////////
  Set ParamToARIMA(Set arima, Set param)

// PURPOSE: Devuelve de un conjunto de conjuntos con estructura @ARIMAStruct a 
//          partir de un conjunto plano con los coeficientes de los polinomios
//          (1-P(B)) donde P es cada uno de los factores AR ó MA 
//////////////////////////////////////////////////////////////////////////////
{
  Set degrees = SetConcat(Traspose(EvalSet(arima,Set(Set factor)
  {
    SetOfReal(Card(Monomes(1-factor->AR)), Card(Monomes(1-factor->MA)))
  })));
  Real from = 1;
  Set s = EvalSet(degrees,Polyn(Real d)
  { 
    Real f = Copy(from);
    Real u = f+d;
    Real (from := u);
    1-SetSum(For(f,u-1,Polyn(Real k)
    {
      param[k]*B^(k-f+1)
    }))
  });
  Set arima_ = For(1,Card(arima),Set(Real k)
  {
    Real period = ARIMA[k]->Periodicity;
    @ARIMAStruct
    (
      period,
      ChangeBDegree(s[k],period),
      ChangeBDegree(s[Card(arima)+k],period),
      ARIMA[k]->DIF
    )
  })
};

//////////////////////////////////////////////////////////////////////////////
   Set EvalARIMA(Set ARIMA, Serie Noise)

// PURPOSE: Evalúa una estructura ARIMA sobre una serie de ruido calculando
//          los residuos por la esperanza condicionada a dicho ruido así
//          como todas las componenets necesarias para el cálculo de la
//          verosimilitud del modelo.
//////////////////////////////////////////////////////////////////////////////
{
  Real d   = Degree(ARIMAGetDIF(ARIMA));
  Real q   = Degree(ARIMAGetMA (ARIMA));
  Real Nd  = CountS(Noise)-d;
  Set ev   = ARIMALevinsonEval(ARIMA, Tra(SerMat(Noise)));
  Set ev1  =
  [[
    Real sigmaEst       = Sqrt(ev[10]/Nd);
    Real sqrtACovDetN   = Sqrt(ev[ 9]);
    Real sqrtWACoef     = Sqrt(ev[10]/ev[11]);
    Real likelyHoodCoef = sqrtWACoef*sqrtACovDetN;
    Real lhNorm         = likelyHoodCoef*Sqrt(ev[11]/Nd)
  ]];
//Set Table([[ARIMA]],"Std");
//Set View(ev1,"");
//WriteLn("\n");
  [[ev, ev1]]
};


