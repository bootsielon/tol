//////////////////////////////////////////////////////////////////////////////
// FILE   : _fun_combination.tol
// PURPOSE: Functions for maximum likelyhood forecast combination of ARIMA
//          models and other models combination
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// STRUCTURES
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Struct @MLHRelation
//////////////////////////////////////////////////////////////////////////////
(
  Code Relation, // Function of Matrix(Matrix z1, Set param) 
                 // Relation(z1, param)=z2
  Set ParamSet,  // Aditional params of Relation
  Real Dim1,     // Rows(z1)
  Real Dim2      // Rows(z2)
);

//////////////////////////////////////////////////////////////////////////////
Struct @MLHConstrain
//////////////////////////////////////////////////////////////////////////////
(
  Matrix MatA, // A matrix in Az1+a = z2
  Matrix Mata  // a matrix in Az1+a = z2
);

//////////////////////////////////////////////////////////////////////////////
Struct @MLHTransf
//////////////////////////////////////////////////////////////////////////////
(
  Code T1, // Transformation for a vector z1. It is a Matrix (Matrix z) 
           // function
  Code T2  // Transformation for a vector z1. It is a Matrix (Matrix z) 
           // function
);

//////////////////////////////////////////////////////////////////////////////
Struct @MLHInfo
//////////////////////////////////////////////////////////////////////////////
(
  Set ResSet,    // Set of residuals time series
  Set ForSet,    // Set of forecast time series
  Set MASet,     // Set of MA polynomials
  Set ARISet,    // Set of ARI polynomials
  Set TraSet,    // Direct transformations for time series vector z1 and
                 // z2. This set is structured by MLHTransf Struct
  Set InvTraSet  // Inverse transformatios for time series vector z1 and
                 // z2. This set is structured by MLHTransf Struct
);

//////////////////////////////////////////////////////////////////////////////
// FUNCTIONS
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix MLH_IdTrans_LinRel
(
  Matrix nu,   
  Matrix cov,  
  Matrix matB, 
  Matrix b     
)
//////////////////////////////////////////////////////////////////////////////
{ cov*Tra(matB)*SVDInverse(matB*cov*Tra(matB))*(b-matB*nu)+nu };
//////////////////////////////////////////////////////////////////////////////
PutDescription(I2("Returns the average vector for a linear regression system:
z = nu + e, and e distributed by N(0, cov) with linear restriction Bz = b",
"Devuelve el vector media de la distribucion condicional de un sistema 
de regresion lineal z = nu + e con e distribuido como N(0, cov) y restriccion
lineal dada por Bz = b"),
MLH_IdTrans_LinRel);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix MLH_Trans_Rel
(
  Code t1,       // Matrix(Matrix z1) is a Column vector transformation
  Code t1Inv,    // Matrix(Matrix z1) is a inverse Column vector transformation
  Code t2,       // Matrix(Matrix z2) is a Column vector transformation
  Code t2Inv,    // Matrix(Matrix z2) is a inverse Column vector transformation
  Matrix nuZ1,
  Matrix nuZ2,
  Matrix cov,
  Code rel,      // Matrix(Matrix z1, Set paramSet) rel(z1, paramSet)=z2
  Set paramSet,  // Additional parameters for rel relation function between
                 // z1 and z2 
  Real show      // If it is TRUE show Marquardt Traces.
)
//////////////////////////////////////////////////////////////////////////////
{
  Set svdCov = SVD(cov);
  Matrix W = svdCov[1];
  Matrix D = svdCov[2];
  
//Real Msg("cov","TGLB"<<cov);

  Matrix matLInv = PseudoInverseDiag(SqRt(D),0)*Tra(W);
//Real Msg("matL","TGLB"<<matL);

  Real n1 = Rows(nuZ1);
  Real n2 = Rows(nuZ2);
  Real n  = n1 + n2;

  Matrix nu1 = t1(nuZ1);
  Matrix nu2 = t2(nuZ2);

  Matrix nu  = matLInv*(nu1<<nu2);

  Matrix error(Matrix x1)
  { 
    Matrix z1 = t1Inv(Tra(x1));
//Real Msg("z1","TGLB"<<z1);
//Real Msg("x1","TGLB"<<x1);
//Real Msg("matLInv","TGLB"<<matLInv);
//Real Msg("nu","TGLB"<<nu);

    Matrix errMat = matLInv*(t1(z1)<<t2(rel(z1, paramSet)))-nu;
//Real Msg("errMat","TGLB"<<errMat);
    errMat 
  };

  Matrix iniParam = Gaussian(1, n1, 0, 1);
  Real Show(show, "ALL");
  Set resultMarq  = Marquardt(n1, n, error, iniParam);
  Real Show(1, "ALL");
  Matrix x1 = Tra(resultMarq[1]);
  Matrix z1 = t1Inv(x1);
  Matrix z2 = rel(z1, paramSet);
  Matrix z = z1<<z2;
  z
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(I2("Returns de mlh vector for a problem:
 T1(z1) = T1(nuZ1)+E1
 T2(z2) = T2(nuZ2)+E2
and  (E1, E2) -> N(0, cov) y z2 = rel(z1). The rel function is 
Matrix (Matrix z1), a vectorial aplication rel:R^n1->R^m2, with Rows(z2)=m2 
and Rows(z1)=m1.",
"Retorna el vector maximo-verosimil de un modelo no lineal 
de la forma:
 T1(z1) = T1(nuZ1)+E1
 T2(z2) = T2(nuZ2)+E2
Con  (E1, E2) -> N(0, cov) y z2 = rel(z1). La funcion rel es una funcion 
Matrix (Matrix z1), es decir una aplicacion vectorial rel:R^n1->R^m2, con
Rows(z2)=m2 y Rows(z1)=m1."), 
MLH_Trans_Rel);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix MLH_Trans_LinRel
(
  Code t1,
  Code t1Inv,
  Code t2,
  Code t2Inv,
  Matrix nuZ1,
  Matrix nuZ2,
  Matrix cov,
  Matrix matA,
  Matrix a,
  Real show      // If it is TRUE show Marquardt Traces.
)
//////////////////////////////////////////////////////////////////////////////
{
  Matrix linRel(Matrix z1, Set paramSet)
  {
    Matrix A = paramSet[1];
    Matrix a = paramSet[2];
    A*z1+a
  };
  Set paramSet = SetOfMatrix(matA, a);
  MLH_Trans_Rel(t1, t1Inv, t2, t2Inv, nuZ1, nuZ2, cov, linRel, paramSet, show)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(I2("Returns de mlh vector for a problem:
 T1(z1) = T1(nuZ1)+E1
 T2(z2) = T2(nuZ2)+E2
and  (E1, E2) -> N(0, cov) y z2 = a+matA*z1",
"Retorna el vector maximo-verosimil de un modelo no lineal 
de la forma:
 T1(z1) = T1(nuZ1)+E1
 T2(z2) = T2(nuZ2)+E2
Con  (E1, E2) -> N(0, cov) y z2 = a+matA*z1"), 
MLH_Trans_LinRel);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set MLH_ARIMA_Rel
(
  Set forSet,
  Set maSet,
  Set ariSet,
  Set traSet,
  Set invTraSet,
  Matrix covMat,
  Set setRel,   // SetOfSet structured by MLHRelation
  Real show
)
//////////////////////////////////////////////////////////////////////////////
{
  Real Msg("MLH_ARIMA_Rel", "Loading data ..."); 
  Matrix forMat = SerSetMat(forSet);
  Real numFor   = Columns(forMat); 

  Serie oneSerie = forSet[1];
  TimeSet tms    = Dating(oneSerie);
  Date iniFor    = First(oneSerie);
 
  Code t1 = traSet->T1;
  Code t2 = traSet->T2;

  Code t1Inv = invTraSet->T1;
  Code t2Inv = invTraSet->T2;

  Real Msg("MLH_ARIMA_Rel", "Calculating expansion of ARIMA data ..."); 
  Set polMatSet = For(1, Columns(covMat), Matrix(Real k)
  {
    Polyn maPol  = maSet[k];
    Polyn ariPol = ariSet[k];
    PolMat(Expand(maPol/ariPol, numFor-1), numFor, 1) 
  });
  Matrix polMat = Group("ConcatColumns", polMatSet);

  Real Msg("MLH_ARIMA_Rel", "Calculating forecast combination ...");
  Set forComSet = For(1, numFor, Matrix(Real h)
  {
    Matrix forMath = SubCol(forMat,[[h]]);
    Matrix polMath = SubRow(polMat, Range(1, h, 1));
//Real Msg("polMath","TGLB"<<polMath);
//Real Msg("covMat","TGLB"<<covMat);
    Matrix covMath = WeightProd(Tra(polMath)*polMath, covMat);

    Set rel        = setRel[h];
    Code relation  = rel->Relation;
    Set paramSet   = rel->ParamSet; 

    Real m1        = rel->Dim1;
    Real m2        = rel->Dim2;
    Real m  = m1+m2;

    MLH_Trans_Rel
    (t1, t1Inv, t2, t2Inv, 
     SubRow(forMath,Range(1, m1, 1)),
     SubRow(forMath,Range(m1+1, m, 1)),
     covMath, relation, paramSet, show)
  });

  Real Msg("MLH_ARIMA_Rel", "Showing results");
  Matrix forComMat = Group("ConcatColumns",forComSet);
  Set forComSetSer = MatSerSet(forComMat,  Dating(oneSerie), iniFor);

  Real Msg("MLH_ARIMA_Rel", "Calculus finished");
  forComSetSer 
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(I2("Returns the mlh forecast time series for a set of ARIMA 
models which have relation gave by  rel(z1, paramSet)=z2.",
"Devuelve la combinacion de previsiones maximo verosimil para un conjunto de
modelos ARIMA con la relacion rel(z1, paramSet)=z2."),
MLH_ARIMA_Rel);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set MLH_ARIMA_LinRel
(
  Set forSet,
  Set maSet,
  Set ariSet,
  Set traSet,
  Set invTraSet,
  Matrix covMat,
  Set setLinRel, //SetOfSet structured by MLHConstrain
  Real show
)
//////////////////////////////////////////////////////////////////////////////
{
  Set setRel = EvalSet(setLinRel, Set(Set linRel)
  {
    Matrix aMat    = linRel->Mata;
    Matrix AMat    = linRel->MatA; 

    Matrix rel(Matrix z1, Set param)
    {
      Matrix A = param[1];
      Matrix a = param[2];
      A*z1+a
    };
    Set paramSet = SetOfMatrix(AMat, aMat);
    Real dim1 = Columns(AMat);
    Real dim2 = Rows(AMat); 

    MLHRelation
    (
      rel, 
      paramSet,
      dim1, 
      dim2 
    )
  });
  Set MLH_ARIMA_Rel
  (
    forSet,
    maSet,
    ariSet,
    traSet,
    invTraSet,
    covMat,
    setRel,
    show
  )
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(I2("Returns the mlh forecast time series for a set of ARIMA 
models which have a linear restriction gave by linTrans Az1+a = z2. z1 are 
the first Columns(A) time series and z2 are the last Rows(A) time series.",
"Devuelve la combinacion de previsiones maximo verosimil para un conjunto de
modelos ARIMA con restriccion lineal dada por lintrans con Az1+a = z2. z1 son
las primeras Columns(A) series y z2 las ultimas Rows(A) series."),
MLH_ARIMA_LinRel);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix MLH_Cov
(
  Set resSet,
  TimeSet tms
)
//////////////////////////////////////////////////////////////////////////////
{
  Date iniRes = SetMinDate(EvalSet(resSet, First));
  Date endRes = SetMaxDate(EvalSet(resSet, Last));

  Real n = DateDif(tms,iniRes, endRes)+1;
  Real m = Card(resSet);

  Set resSetFull = EvalSet(resSet, Serie(Serie res)
  { 
    Serie invResAdd = 
     (CalInd(W,tms)<<InvCh(res, CalInd(W, tms)))>>CalInd(W,tms);
    Serie invRes = SubSer(invResAdd, iniRes, endRes);
    Serie invResNotNull = IfSer(IsUnknown(invRes), CalInd(W, tms), invRes);
    invResNotNull
  });
  Matrix resMat = MatSetSeries(resSetFull);

  Matrix eResMat = 
   SetCol(EvalSet(resSetFull, Real(Serie ser){AvrS(ser, iniRes, endRes)}));

  Matrix eResMatFull = eResMat*Tra(eResMat);
  Set numbersSet = For(1, Card(resSet), Matrix (Real k)
  {
    Serie res = resSet[k];
    Serie resInv = InvCh(Not(IsUnknown(res)), CalInd(W, tms));
    Serie resInvAdd = (CalInd(W,tms)<<resInv)>>CalInd(W, tms);
    Serie resInvAddSub = SubSer(resInvAdd, iniRes, endRes);
    SerMat(resInvAddSub)
  });
  Matrix numbers = Group("ConcatRows", numbersSet);
  Matrix zero  = Rand(m, m, 0, 0); 
  Matrix Nxy   = numbers*Tra(numbers); 
  Matrix Nxy_1 = IfMat(EQ(Nxy, zero), zero, RPow(Nxy, -1));

  Matrix Nxx = SubDiag(Nxy, 0);

  Matrix NxNy   = Tra(Nxx)*Nxx;
  Matrix NxNy_1 = IfMat(EQ(NxNy, zero), zero, RPow(NxNy, -1));

  Matrix covMatFull  = Cov(resMat);
  Matrix nNxy_1      = RProd(Nxy_1,n); 
  Matrix nNxNy_1Nxy  = RProd(WeightProd(NxNy_1, Nxy),n); 
  Matrix covMatAux   =  
   covMatFull+eResMatFull-WeightProd(nNxNy_1Nxy, eResMatFull);
  Matrix covMat      = WeightProd(nNxy_1, covMatAux);
/*  SetOfSet(resSetFull,SetOfMatrix(numbers,zero,Nxy,Nxy_1,
    NxNy,covMatFull,covMatAux,covMat,eResMatFull,resMat))*/
  covMat
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(I2("Return the covarianze matrix of a set of series with
differents harmonic TimeSet between them but with a comon time lapsus in.

Note that:
Cov'(x,y) = (n/Nxy)*[Cov(x,y)+E[x]E[y]-Nxy*n*E[x]*E[y]/(Nx*Ny))

Con Cov'(x,y) = (1/Nxy)*Sum(x*y)-((1/Nx)*Sum(x))*((1/Ny)*Sum(x))
    E[x]      = (1/n)*Sum(x)
    E[y]      = (1/n)*Sum(y)   
    Cov(x,y)  = (1/n)*Sum(x*y)-((1/n)*Sum(x))*((1/n)*Sum(x))
",
"Retorna la matriz de covarianzas de un conjunto de series en 
diferentes fechados armonicos entre si y diferentes fechas entre ellos, pero
con algun solapamiento entre las fechas de máximo y minimo.

Observese que:
Cov'(x,y) = (n/Nxy)*[Cov(x,y)+E[x]E[y]-Nxy*n*E[x]*E[y]/(Nx*Ny))

Con Cov'(x,y) = (1/Nxy)*Suma(x*y)-((1/Nx)*Suma(x))*((1/Ny)*Suma(x))
    E[x]      = (1/n)*Suma(x)
    E[y]      = (1/n)*Suma(y)   
    Cov(x,y)  = (1/n)*Suma(x*y)-((1/n)*Suma(x))*((1/n)*Suma(x))
"),
MLH_Cov);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set MLH_ForComb_LinRel
(
  Set info,        // Set of information for cambination which is structured by
                   // MLHInfo Struct
  Set setLinTrans, // Set of linear information 
                   // structured by MLHConstrain struct or a SetOfSet with 
                   // MLHConstrain Struct
  Text tms,        // If "" all TimeSet are the same and the same dates otherwise
                   // is the greatest homogenic TimeSet 
  Real show        // If it is TRUE show Marquardt Traces.
)
//////////////////////////////////////////////////////////////////////////////
{
  Real Msg("MLH_ForComb_LinRel", "Loading data ...");
  Set resSet    = info->ResSet;
  Set forSet    = info->ForSet;
  Set maSet     = info->MASet;
  Set ariSet    = info->ARISet;
  Set traSet    = info->TraSet;
  Set invTraSet = info->InvTraSet;
 
  Real numFor = CountS(forSet[1]);

  Real Msg("MLH_ForComb_LinRel", "Calculating covariance Matrix ...");
  Matrix covMat = If(tms == "", CovMat(resSet), 
  MLH_Cov(resSet, Eval(tms)));

  Set linTranSet = If(StructName(setLinTrans)=="", setLinTrans, 
  NCopy(numFor, setLinTrans));

  MLH_ARIMA_LinRel
  (
    forSet,
    maSet,
    ariSet,
    traSet,
    invTraSet,
    covMat,
    linTranSet,
    show
  )
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(I2("Returns the MLH forecast combination with linear 
constraints.",
"Retorna la combinación de prevision maximo verosimil con restrecciones
lineales."),
MLH_ForComb_LinRel);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Real ChooseNotNullCoor(Set constrain, Set zFix)
//////////////////////////////////////////////////////////////////////////////
{
  Matrix A = constrain->MatA;
  Matrix a = constrain->Mata;
 
  Real dim1 = Columns(A);
  Real dim2 = Rows(a);

  Real dim = dim1+dim2;

  If(dim<:zFix,
  {
    Real i = 1;
    Real While(Or(EQ(MatDat(A, i, 1),0), i<:zFix),
    { Real i:=i+1 });
    i
  },0)
};

//////////////////////////////////////////////////////////////////////////////
Set MLH_AgMLHConstrainWithFixed
(
  Matrix z,      // A n+1-vector
  Set constrain, // MLHConstrain Struct with A a n-vector and a scalar 
  Set zFix,      // Fixed variables in agregative structure
  Real i         // i fixed coordinate
)
//////////////////////////////////////////////////////////////////////////////
{
  Matrix A = constrain->MatA;
  Matrix a = constrain->Mata;
 
  Real dim1 = Columns(A);
  Real dim2 = Rows(a);

  Real dim = dim1+dim2;

  Case
  (
    And(EQ(Card(zFix),1), dim<:zFix),
    {
      Real Ai = MatDat(A, 1, i);

      Set index  = Range(1, dim1, 1)-SetOfReal(i); 
      Matrix A_i = SubCol(A, index);
      
      Matrix Anew = RProd(A_i, -1/Ai);
      Matrix anew = RProd(SubRow(z, [[dim]])-a, 1/Ai);

      MLHConstrain(Anew, anew)
    },
    And(GT(Card(zFix),1), dim<:zFix),
    {
      Real Ai = MatDat(A, 1, i);

      Set index1 = Range(1, dim1, 1)-(zFix<<SetOfReal(i));
      Matrix A1  = SubCol(A, index1);
      Set index2 = zFix-SetOfReal(dim);
      Matrix A2  = SubCol(A, index2);

      Matrix z_ = SubRow(z, index2); 

      Matrix Anew = RProd(A1, -1/Ai);
      Matrix anew = RProd(SubRow(z, [[dim]])-a-A2*z_, 1/Ai);

      MLHConstrain(Anew, anew)  
    },
    1,
    {
      Set index1 = Range(1, dim1, 1)-zFix;
      Matrix A1  = SubCol(A, index1);
      Set index2 = zFix-SetOfReal(dim);
      Matrix A2  = SubCol(A, index2);

      Matrix z_ = SubRow(z, index2); 

      Matrix Anew = A1;
      Matrix anew = A2*z_+a;

      MLHConstrain(Anew, anew)      
    } 
  )
};

//////////////////////////////////////////////////////////////////////////////
Set MLH_ForComb_AgRelWithFixed
(
  Set info,        // Set of information for cambination which is structured by
                   // MLHInfo Struct
  Set constrain,   // Set of linear information 
                   // structured by MLHConstrain struct with agregative info
  Set forSetFix,   // Index with fixed forecast
  Real show        // If it is TRUE show Marquardt Traces.
)
//////////////////////////////////////////////////////////////////////////////
{
  Real Msg("MLH_ForComb_AgRelWithFixed", "Loading data ...");
  Set resSetAux    = info->ResSet;
  Set forSetAux    = info->ForSet;
  Set maSetAux     = info->MASet;
  Set ariSetAux    = info->ARISet;
  Set traSet       = info->TraSet;
  Set invTraSet    = info->InvTraSet;

  Set index = Range(1, Card(resSetAux), 1)-forSetFix;
 
  Real numFor = CountS(forSetAux[1]);

  Matrix A = constrain->MatA;
  Matrix a = constrain->Mata;

  Real i = ChooseNotNullCoor(constrain, forSetFix);

  Matrix forMat = SerSetMat(forSetAux);

  Set linTranSet = For(1, numFor, Set(Real k)
  {
    Matrix z = SubCol(forMat, SetOfReal(k));
    MLH_AgMLHConstrainWithFixed(z, constrain, forSetFix, i)
  });

  Set GetInfo(Set s, Real i, Set index)
  {
    If(EQ(i,0), ExtractByIndex(s, index),
    {
      Set reg = ExtractByIndex(s, [[i]]); 
      ExtractByIndex(s, index-SetOfReal(i))<<reg
    })
  };

  Set resSet    = GetInfo(resSetAux, i, index);
  Set forSet    = GetInfo(forSetAux, i, index);
  Set maSet     = GetInfo(maSetAux, i, index);
  Set ariSet    = GetInfo(ariSetAux, i, index);


  Real Msg("MLH_ForComb_AgRelWithFixed", "Calculating covariance Matrix ...");
  Matrix covMat = CovMat(resSet);

  Set forComSetAux = MLH_ARIMA_LinRel
  (
    forSet,
    maSet,
    ariSet,
    traSet,
    invTraSet,
    covMat,
    linTranSet,
    show
  );

  Set forComSet = If(EQ(i,0),
  {
    Set s1 = For(1, Card(forComSetAux), Set(Real k)
    {
      Serie ser = forComSetAux[k];
      Real idx  = index[k]; 
      SetOfAnything(idx, ser)
    }); 
    Set s2 = For(1, Card(forSetFix), Set(Real k)
    {
      Serie ser = ExtractByIndex(forSetAux, forSetFix)[k];
      Real idx  = forSetFix[k]; 
      SetOfAnything(idx, ser)
    }); 
    s1<<s2
  }, 
  {
    Set index1 = index-SetOfReal(i);
    Real c = Card(forComSetAux);
    Serie z2 = forComSetAux[c];
    
    Set s1 = For(1, c-1, Set(Real k)
    {
      Serie ser = forComSetAux[k];
      Real idx  = index1[k]; 
      SetOfAnything(idx, ser)
    }); 
    Set s2 = For(1, Card(forSetFix), Set(Real k)
    {
      Serie ser = ExtractByIndex(forSetAux, forSetFix)[k];
      Real idx  = forSetFix[k]; 
      SetOfAnything(idx, ser)
    }); 
    Set s3 = SetOfSet(SetOfAnything(i, z2));
    s1<<s2<<s3
  });

  Set forComSort = Sort(forComSet, Real(Set reg1, Set reg2)
  {
    Real i1 = reg1[1];
    Real i2 = reg2[1];
    Compare(i1, i2)
  });
  Set forCom = Traspose(forComSort)[2];
  forCom
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(I2("Returns the MLH forecast combination with linear 
constraints.",
"Retorna la combinación de prevision maximo verosimil con restrecciones
lineales."),
MLH_ForComb_AgRelWithFixed);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set MLH_ForComb_Rel
(
  Set info,    // Set of information for combination which is structured by
               // MLHInfo Struct. The residuals are not necessary complete 
               // with zero to greatest TimeSet
  Set setRel,  // Set of relation information 
               // structured by MLHRelation struct or a SetOfSet with 
               // MLHRelation Struct
  Text tms,    // If "" all TimeSet are the same and the same dates otherwise
               // is the greatest homogenic TimeSet 
  Real show    // If it is TRUE show Marquardt Traces.
)
//////////////////////////////////////////////////////////////////////////////
{
  Real Msg("MLH_ForComb_Rel", "Loading data ...");
  Set resSet    = info->ResSet;
  Set forSet    = info->ForSet;
  Set maSet     = info->MASet;
  Set ariSet    = info->ARISet;
  Set traSet    = info->TraSet;
  Set invTraSet = info->InvTraSet;
 
  Real numFor = CountS(forSet[1]);

  Real Msg("MLH_ForComb_Rel", "Calculating relations ...");
  Set setRelNew = If(StructName(setRel)=="", setRel, 
  NCopy(numFor, setRel));

  Real Msg("MLH_ForComb_Rel", "Calculating covariance Matrix ...");
  Matrix covMat = If(tms == "", CovMat(resSet), 
  MLH_Cov(resSet, Eval(tms)));

  Set result = MLH_ARIMA_Rel
  (
    forSet,
    maSet,
    ariSet,
    traSet,
    invTraSet,
    covMat,
    setRelNew,
    show
  );
  result
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(I2("Returns the MLH forecast combination with a relation 
between variables.",
"Retorna la combinación de prevision maximo verosimil con una relacion 
cualquiera entre las variables."),
MLH_ForComb_Rel);
//////////////////////////////////////////////////////////////////////////////




