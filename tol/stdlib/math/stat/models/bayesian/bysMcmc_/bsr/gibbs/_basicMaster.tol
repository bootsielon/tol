/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// FILE: _basicMaster.tol
// PURPOSE: Declares Class BysMcmc::Bsr::Gibbs::@MasterSamplerBasic
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
Class @MasterSamplerBasic : @MasterSampler
/////////////////////////////////////////////////////////////////////////////
{
  //--------------------------------------------------------------------------
  // Mandatory members
  //--------------------------------------------------------------------------
  //Internal reference to model definition
  Set _.modelDef;

  //Output after external filters
  VMatrix _.Y;
  //BSR basic blocks
  BysMcmc::Bsr::Gibbs::@BlockStdLin _.mln.blk;
  BysMcmc::Bsr::Gibbs::@BlockSigma  _.sig.blk;
  BysMcmc::Bsr::Gibbs::@BlockArima  _.arm.blk;
  BysMcmc::Bsr::Gibbs::@BlockStdLin _.mis.blk;
  //Non linear blocks
  Set _.nonLinBlk;

  //--------------------------------------------------------------------------
  //Auxiliar members
  //--------------------------------------------------------------------------
  //Output filtered by missing values
  VMatrix _.YplusV = Rand(0,0,0,0);
  //Linear input filtered by missing values
  VMatrix _.XplusU = Rand(0,0,0,0);
  //Linear input filter
  VMatrix _.filter = Rand(0,0,0,0);
  //ARIMA noise
  VMatrix _.noise = Rand(0,0,0,0);
  //residuals
  VMatrix _.residuals = Rand(0,0,0,0);
  //Linear block values
  VMatrix _.beta = Rand(0,1,0,0);
  //Non linear filter of output
  Set _.nonLinOutputFilter = Copy(Empty);
  //Non linear filters with parameters to be drawn
  Set _.nonLinDrawFilter = Copy(Empty);

  //--------------------------------------------------------------------------
  //Methods
  //--------------------------------------------------------------------------

  ////////////////////////////////////////////////////////////////////////////
  Text get.session(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    _.modelDef->DocInfo->Session.Name
  }; 

  ////////////////////////////////////////////////////////////////////////////
  Text get.path(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    _.modelDef->DocInfo->Path 
  }; 

  ////////////////////////////////////////////////////////////////////////////
  Real DoNonLinOutputFilter(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+"DoNonLinOutputFilter 1");
    VMatrix _.Y := _.modelDef->Y;
  //WriteLn("TRACE"+_MID+"DoNonLinOutputFilter 2");
    If(!Card(_.nonLinOutputFilter), 1,
    {
    //WriteLn("TRACE"+_MID+"DoNonLinOutputFilter 3");
      Real filter.blk(BysMcmc::@BlockSampler extFlt)
      {
        Real ok = extFlt::do.filter(_.Y);
      //WriteLn("TRACE"+_MID+"DoNonLinOutputFilter 4 _.Y=\n"<<VMat2Mat(_.Y,1));
        ok
      };
      SetMin(EvalSet(_.nonLinOutputFilter,filter.blk))
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix findMatchingBeta(VMatrix givenInitVal)
  //Assigning initial values to linear block variables
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::@Config cfg = _.config;
    If(!VRows(_.modelDef->a), givenInitVal,
    {
    //WriteLn("TRACESearching valid initial values");
      Set try = SetOfNameBlock
      (
        {[[Text name="givenByUser",  Real order=cfg::bsr.iniVal.try.givenByUser]]},
        {[[Text name="zero",         Real order=cfg::bsr.iniVal.try.zero]]},
        {[[Text name="findFeasible", Real order=cfg::bsr.iniVal.try.findFeasible]]},
        {[[Text name="cnstrMinNorm", Real order=cfg::bsr.iniVal.try.cnstrMinNorm]]},
        {[[Text name="cnstrMLE",     Real order=cfg::bsr.iniVal.try.cnstrMLE]]}
      );
      Set try.sel = Select(try,Real(NameBlock method) 
      { method::order });
      Set try.sort = Sort(try.sel,Real(NameBlock a, NameBlock b) 
      { Compare(a::order,b::order) });
      Real method.num = 1;
      Real method.ok = False;
      Real n = VColumns(_.modelDef->X);
      VMatrix beta = Rand(n,1,?,?);
      While(And(!method.ok,method.num<=Card(try.sort)),
      {
        Text method.name = (try.sort[method.num])::name;
        Do WriteLn(_MID+"Trying feasible initial values for MCM by method "+
          method.name+" ...", "");
        VMatrix beta := Case(
        method.name=="givenByUser", 
        {
          givenInitVal
        },
        method.name=="zero", 
        {
          Rand(n,1,0,0)
        },
        method.name=="findFeasible", 
        {
          Polytope::FindFeasible(
           _.modelDef->A, _.modelDef->a, givenInitVal, n*10, TRUE)
        },
        method.name=="cnstrMinNorm", 
        {
          Polytope::FindFeasible.QP.MinNorm(
            _.modelDef->A, _.modelDef->a, TRUE)
        },
        method.name=="cnstrMLE", 
        {
          Polytope::FindFeasible.QP.MLE(
            _.modelDef->A,_.modelDef->a, _.XplusU, _.YplusV, TRUE)
        });
        Real method.ok :=  VMatMax(_.modelDef->A*beta-_.modelDef->a)<=0;
        If(method.ok,
          WriteLn(_MID+"Method "+method.name+" matches constraints."),
          WriteLn(_MID+"Method "+method.name+" DOESN'T match constraints."));
        Real method.num := method.num+1
      });
      beta
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real define.all(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" define.all 0");
    Set _.nonLinBlk := 
    {
      Set aux.nlb = EvalSet(_.modelDef->NoiseDistrib,Set(@BSR.NoiseDistrib seg)
      {
        seg->NonLinFilters
      });
      Set nonLinFilter = SetConcat(aux.nlb);
      Real nextCol = _.mis.blk::_.lastCol+1;
      @MasterSamplerBasic T = _this;
      For(1,Card(nonLinFilter), NameBlock(Real numBlk)
      {
        NameBlock nlf = nonLinFilter[numBlk];
        BysMcmc::Bsr::Gibbs::@BlockNonLin nlb = 
        BysMcmc::Bsr::Gibbs::@BlockNonLin::New
        (
          nlf, 
          _this,
          5+numBlock, 
          nextCol,
          config
        );
        Real If(ObjectExist("Set","nlf::_.externalInfo"),
        {
          Set nlf::_.externalInfo := [[ _this, nlb ]];
          1
        });
        Real nextCol := nlb::_.lastCol+1;
        Eval(ToName(nlb::_.name)+"=nlb")
      })
    };

    Set _.blocks :=
    [[
      _.mln.blk,
      _.sig.blk,
      _.arm.blk,
      _.mis.blk
    ]]
    << _.nonLinBlk;
    Real _defined := define(
        name,
        get.colNames(0),
        _.mcmcPartialHandler,
        numBlock,
        firstCol,
        config)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize_with_linear_block(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    Matrix givenBeta=
    SetCol(EvalSet(_.modelDef->LinearBlock,Real(@BSR.LinearBlock b)
    { b->InitialValue }));
    VMatrix beta0 = findMatchingBeta(Mat2VMat(givenBeta));
    VMatrix _.filter := _.modelDef->X*beta0;
    Real initialize.blocks(unused);
  //WriteLn("TRACE"+_MID+"initialize _.filter=\n"<<Matrix VMat2Mat(_.filter,1));
    Real sel.extFlt (BysMcmc::@BlockSampler nlb) { !(nlb::_.isInputFilter) };
    Set _.nonLinOutputFilter := Select(_.nonLinBlk, sel.extFlt);

    Real sel.drwFlt (BysMcmc::@BlockSampler nlb) { nlb::_.N>0 };
    Set _.nonLinDrawFilter := Select(_.nonLinBlk, sel.drwFlt);

  //WriteLn("TRACE"+_MID+" initialize 1");
    VMatrix _.YplusV := _.mis.blk::filter.output(_.Y);
  //WriteLn("TRACE"+_MID+" initialize 1.1 _.YplusV("<<VRows(_.YplusV)+"x"<<VColumns(_.YplusV)+")");
    VMatrix _.XplusU := _.mis.blk::filter.input(_.modelDef->X);
  //WriteLn("TRACE"+_MID+" initialize 1.2 _.XplusU("<<VRows(_.XplusU)+"x"<<VColumns(_.XplusU)+")");
  //WriteLn("TRACE"+_MID+" initialize 3 beta0("<<VRows(beta0)+"x"<<VColumns(beta0)+")");
    Real ok = _.mln.blk::matchConstrains(beta0, _.modelDef->A, _.modelDef->a);
    If(ok,
    {
    //WriteLn("TRACE"+_MID+" initialize 4");
      VMatrix _.beta   := _.mln.blk::_.store;
    //WriteLn("TRACE"+_MID+" initialize 5 _.beta("<<VRows(_.beta)+"x"<<VColumns(_.beta)+")");
      Real DoNonLinOutputFilter(0);
    //WriteLn("TRACE"+_MID+" initialize 6 ");
      Real If(_.sig.blk::_.partialSampler::_.freeParamNum,
      {
      //WriteLn("TRACE"+_MID+" initialize 6.1 ");
        _.sig.blk::buildWorkSpace(@WorkSpace.Sigma::New(
          _.YplusV-_.XplusU*_.beta))
      });
      VMatrix sig_0 = _.sig.blk::get.draw(0, True);
    //WriteLn("TRACE"+_MID+" initialize 7");
    //WriteLn("TRACE"+_MID+" _.XplusU "<<_.XplusU);
    //WriteLn("TRACE"+_MID+" _.beta "<<_.beta);
      VMatrix _.filter := _.XplusU*_.beta;
    //WriteLn("TRACE"+_MID+" _.filter "<<_.filter);
      VMatrix _.noise := _.YplusV-_.filter;
    //WriteLn("TRACE"+_MID+" _.noise "<<_.noise);
    //WriteLn("TRACE"+_MID+" init 8");
      VMatrix _.residuals := _.arm.blk::filter(_.noise);
    //WriteLn("TRACE"+_MID+" _.residuals "<<_.residuals);
    //WriteLn("TRACE"+_MID+" init 9");
      Real If(_.sig.blk::_.partialSampler::_.freeParamNum,
      {
        _.sig.blk::buildWorkSpace(@WorkSpace.Sigma::New(_.residuals))
      });
    //WriteLn("TRACE"+_MID+" init 10");
      VMatrix sig_1 = _.sig.blk::get.draw(0, True);
    //WriteLn("TRACE"+_MID+" init 11");
      1  
    });
    ok
  };
  ////////////////////////////////////////////////////////////////////////////
  Real initialize_without_linear_block(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix _.filter := _.modelDef->Y*0;
    Real initialize.blocks(unused);
    Real sel.extFlt (BysMcmc::@BlockSampler nlb) { !(nlb::_.isInputFilter) };
    Set _.nonLinOutputFilter := Select(_.nonLinBlk, sel.extFlt);

    Real sel.drwFlt (BysMcmc::@BlockSampler nlb) { nlb::_.N>0 };
    Set _.nonLinDrawFilter := Select(_.nonLinBlk, sel.drwFlt);

    VMatrix _.YplusV := _.mis.blk::filter.output(_.Y);
    VMatrix _.XplusU := _.filter;
    VMatrix _.beta   := _.mln.blk::_.store;
    Real DoNonLinOutputFilter(0);
    Real If(_.sig.blk::_.partialSampler::_.freeParamNum,
    {
      _.sig.blk::buildWorkSpace(@WorkSpace.Sigma::New(
        _.YplusV))
    });
    VMatrix sig_0 = _.sig.blk::get.draw(0, True);
    VMatrix _.noise := _.YplusV;
    VMatrix _.residuals := _.arm.blk::filter(_.noise);
    Real If(_.sig.blk::_.partialSampler::_.freeParamNum,
    {
      _.sig.blk::buildWorkSpace(@WorkSpace.Sigma::New(_.residuals))
    });
    VMatrix sig_1 = _.sig.blk::get.draw(0, True);
    True  
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" initialize 0");
    If(_.mln.blk::_.N,
      initialize_with_linear_block   (unused),
      initialize_without_linear_block(unused))
  };

  ////////////////////////////////////////////////////////////////////////////
  Real resume_with_linear_block(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" resume 0");
    Real initialize.blocks(unused);
    VMatrix _.YplusV := _.mis.blk::filter.output(_.Y);
    VMatrix _.XplusU := _.mis.blk::filter.input(_.modelDef->X);
    VMatrix _.beta   := _.mln.blk::_.store;
    Real ok = _.mln.blk::matchConstrains(_.beta, _.modelDef->A, _.modelDef->a);
    If(ok,
    {
      VMatrix _.beta   := _.mln.blk::_.store;
      Real DoNonLinOutputFilter(0);
      VMatrix _.filter := _.XplusU*_.beta;
      VMatrix _.noise := _.YplusV-_.filter;
      VMatrix _.residuals := _.arm.blk::filter(_.noise);
      Real If(_.sig.blk::_.partialSampler::_.freeParamNum,
      {
        _.sig.blk::buildWorkSpace(@WorkSpace.Sigma::New(_.residuals))
      });
      VMatrix sig_1 = _.sig.blk::get.draw(0, True);
      ok
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real resume_without_linear_block(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" resume 0");
    Real initialize.blocks(unused);
    VMatrix _.YplusV := _.mis.blk::filter.output(_.Y);
    VMatrix _.XplusU := _.modelDef->Y*0;
    VMatrix _.beta   := _.mln.blk::_.store;
    Real DoNonLinOutputFilter(0);
    VMatrix _.filter := _.modelDef->Y*0;
    VMatrix _.noise := _.YplusV;
    VMatrix _.residuals := _.arm.blk::filter(_.noise);
    Real If(_.sig.blk::_.partialSampler::_.freeParamNum,
    {
      _.sig.blk::buildWorkSpace(@WorkSpace.Sigma::New(_.residuals))
    });
    VMatrix sig_1 = _.sig.blk::get.draw(0, True);
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real resume(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.mln.blk::_.N,
      resume_with_linear_block   (unused),
      resume_without_linear_block(unused))
  };

  ////////////////////////////////////////////////////////////////////////////
  Real setStore(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_.name+"::setStore("<<Rows(values)+"x"<<Columns(values)+")");   
    putStore(values);
    setStore.blocks(values) 
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw_with_linear_block =
  "Converts the original regression to standarized noise N(0,I) and "
  "solves it";
  VMatrix draw_with_linear_block(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" @MasterSamplerBasic::draw 1");
    Real DoNonLinOutputFilter(0);

    VMatrix mis = 
    {
      Real If(_.mis.blk::_.partialSampler::_.freeParamNum,
      {
        _.mis.blk::buildWorkSpace(@WorkSpace.Missing::New(
          _.arm.blk,
          _.sig.blk::_.sigmaInv,
          _.modelDef->Y-_.modelDef->X*_.beta,
          _.beta))
      });
      VMatrix aux = _.mis.blk::get.draw(numSim, False);
      VMatrix _.YplusV := _.mis.blk::filter.output(_.Y);
      VMatrix _.XplusU := _.mis.blk::filter.input(_.modelDef->X);
      aux
    };

  //WriteLn("TRACE"+_MID+" @MasterSamplerBasic::draw 3 im="<<im);
    VMatrix _.filter :=  _.XplusU*_.beta;
    VMatrix _.noise := _.YplusV - _.filter;
    VMatrix arm = 
    {
      Real If(_.arm.blk::_.partialSampler::_.freeParamNum,
      {
        _.arm.blk::buildWorkSpace(@WorkSpace.Arima::New(
          _.noise,_.sig.blk::_.store))
      });
      _.arm.blk::get.draw(numSim, False)
    };
    VMatrix _.residuals := _.arm.blk::filter(_.noise);
  //WriteLn("TRACE"+_MID+" @MasterSamplerBasic::draw 4 arm="<<arm);
    VMatrix _Y = _.YplusV;
    VMatrix _X = _.XplusU;
    VMatrix sig = If(Not(_.sig.blk::_.N),
    { 
       Rand(0,1,0,0)
    },
    {
      Real If(_.sig.blk::_.partialSampler::_.freeParamNum,
      {
        _.sig.blk::buildWorkSpace(@WorkSpace.Sigma::New(_.residuals))
      });
      _.sig.blk::get.draw(numSim, False)
    });
    VMatrix si = _.sig.blk::_.sigmaInv;
    VMatrix _Y := si*_Y;
    VMatrix _X := si*_X;
  //WriteLn("TRACE"+_MID+" @MasterSamplerBasic::draw 5 sig="<<sig);
    VMatrix _.beta := 
    {
    //WriteLn("TRACE"+_MID+" @MasterSamplerBasic::draw 5.1 _.mln.blk::_.partialSampler::_.freeParamNum="<<_.mln.blk::_.partialSampler::_.freeParamNum);
      Real If(_.mln.blk::_.partialSampler::_.freeParamNum,
      {
        _.mln.blk::buildWorkSpace(@WorkSpace.MainLinear::New(
          _Y,_X,_.arm.blk))
      });
      _.mln.blk::get.draw(numSim, False)
    };
    VMatrix nlb = If(!Card(_.nonLinBlk),Rand(0,1,0,0),
    {
      Set nlb.aux = EvalSet(_.nonLinBlk, VMatrix(@BlockNonLin nlb)
      {
        nlb::get.draw(numSim,False)
      });
      Group("ConcatRows", nlb.aux)
    }); 
  //WriteLn("TRACE"+_MID+" @MasterSamplerBasic::draw 6 _.beta="<<_.beta);
    VMatrix param = _.beta << sig << arm << mis << nlb;
  //WriteLn("TRACE"+_MID+" @MasterSamplerBasic::draw 7 param="<<VRows(param)+"x"<<VColumns(param)+")");
    Real putStoreV(param);
    param
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw_without_linear_block =
  "Converts the original regression to standarized noise N(0,I) and "
  "solves it";
  VMatrix draw_without_linear_block(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" @MasterSamplerBasic::draw 1");
    Real DoNonLinOutputFilter(0);
    VMatrix mis = 
    {
      Real If(_.mis.blk::_.partialSampler::_.freeParamNum,
      {
        _.mis.blk::buildWorkSpace(@WorkSpace.Missing::New(
          _.arm.blk,
          _.sig.blk::_.sigmaInv,
          _.modelDef->Y,
          _.beta))
      });
      VMatrix aux = _.mis.blk::get.draw(numSim, False);
      VMatrix _.YplusV := _.mis.blk::filter.output(_.Y);
      aux
    };
    VMatrix _.noise := _.YplusV;
    VMatrix arm = If(Not(_.arm.blk::_.N),
    {
      VMatrix _.residuals := _.noise;
      Rand(0,1,0,0)
    },
    {
      Real If(_.arm.blk::_.partialSampler::_.freeParamNum,
      {
        _.arm.blk::buildWorkSpace(@WorkSpace.Arima::New(
          _.noise,_.sig.blk::_.store))
      });
      _.arm.blk::get.draw(numSim, False)
    });
    VMatrix _.residuals := _.arm.blk::filter(_.noise);
  //WriteLn("TRACE"+_MID+" @MasterSamplerBasic::draw 4 arm="<<arm);
    VMatrix sig = If(Not(_.sig.blk::_.N),
    { 
       Rand(0,1,0,0)
    },
    {
      Real If(_.sig.blk::_.partialSampler::_.freeParamNum,
      {
        _.sig.blk::buildWorkSpace(@WorkSpace.Sigma::New(_.residuals))
      });
      _.sig.blk::get.draw(numSim, False)
    });
    VMatrix nlb = If(!Card(_.nonLinBlk),Rand(0,1,0,0),
    {
      Set nlb.aux = EvalSet(_.nonLinBlk, VMatrix(@BlockNonLin nlb)
      {
        nlb::get.draw(numSim,False)
      });
      Group("ConcatRows", nlb.aux)
    }); 
  //WriteLn("TRACE"+_MID+" @MasterSamplerBasic::draw 6 _.beta="<<_.beta);
    VMatrix param = sig << arm << mis << nlb;
  //WriteLn("TRACE"+_MID+" @MasterSamplerBasic::draw 7 param="<<VRows(param)+"x"<<VColumns(param)+")");
    Real putStoreV(param);
    param
  };


  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw =
  "Converts the original regression to standarized noise N(0,I) and "
  "solves it";
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.mln.blk::_.N,
      draw_with_linear_block   (numSim),
      draw_without_linear_block(numSim))
  };



  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setMcmcRow =
  "Set values of all blocks from a given row of a Markov Chain";
  Real setMcmcRow(Matrix mcmc, Real row) 
  ////////////////////////////////////////////////////////////////////////////
  {
    setStore(SubRow(mcmc, [[row]]))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setSegmentInputCol =
  "";
  Real setSegmentInputCol(Matrix Xj, Real segmentNum, Real column)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set equIdx = (_.modelDef->NoiseDistrib)[segmentNum]->EquIdx;
    //VBR: Se asume que las ecuaciones de un segmento son consecutivas!
    PutVMatBlock(_.modelDef->X, equIdx[1], column, Xj)
  };


  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member._eval =
  "Set values of all blocks from a given row vector of values";
  Set _eval(Matrix values, Real useTimeInfo, Real justWithTimeInfo) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" eval 1");
    Real setStore(values);
    Real DoNonLinOutputFilter(0);
  //WriteLn("TRACE"+_MID+" eval 2");
    VMatrix _.YplusV := _.mis.blk::filter.output(_.Y);
    VMatrix fullOutput.mis = _.mis.blk::filter.output(_.Y*0);
  //WriteLn("TRACE"+_MID+" eval 3");
    VMatrix _.XplusU := _.mis.blk::filter.input(_.modelDef->X);
  //WriteLn("TRACE"+_MID+" eval 4");
    VMatrix _.beta := _.mln.blk::_.store;
    VMatrix fullFilter = If(_.mln.blk::_.N, _.modelDef->X*_.beta, _.modelDef->Y*0);
    VMatrix fullFilter.full = If(_.mln.blk::_.N, _.XplusU*_.beta, fullFilter);
    VMatrix fullFilter.mis = fullFilter.full - fullFilter;
    VMatrix fullNoise  = _.YplusV - fullFilter.full;
  //WriteLn("TRACE"+_MID+" eval 5");
  //WriteLn("TRACE"+_MID+" eval 6");
    Set all.segments = Range(1,Card(_.arm.blk::_.NoiseDistrib),1);
    Set select = If(!justWithTimeInfo, all.segments, 
      Select(all.segments, Real(Real k)
      {
        Set segment = (_.arm.blk::_.NoiseDistrib)[k];
        Card(segment->TimeInfo)
      }));
    EvalSet(select, Set(Real k)
    {
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].1");
      Set segment = (_.arm.blk::_.NoiseDistrib)[k];
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].2");
      Text name = Replace(segment->Name,"::Noise","");
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].2.1");
      Matrix output_ = VMat2Mat(SubRow(_.modelDef->Y,segment->EquIdx));
      Matrix output.mis_ = VMat2Mat(SubRow(fullOutput.mis,segment->EquIdx));
      Matrix output.extFil = VMat2Mat(SubRow(_.modelDef->Y-_.Y,segment->EquIdx));
      Matrix output.full = output_+output.mis_;
      Matrix output = IfMat(output.mis_,RProd(output_,?),output_);
      Matrix output.mis  = IfMat(output.mis_,output.mis_,RProd(output.mis_,?));
      Matrix filter_ = VMat2Mat(SubRow(fullFilter,segment->EquIdx));
      Matrix filter.mis_ = VMat2Mat(SubRow(fullFilter.mis,segment->EquIdx));
      Matrix filter.full = filter_+filter.mis_;
      Matrix filter = IfMat(filter.mis_,RProd(filter_,?),filter_);
      Matrix filter.mis  = IfMat(filter.mis_,filter.mis_,RProd(filter.mis_,?));
      VMatrix noise.v = SubRow(fullNoise,segment->EquIdx);
      Matrix noise = VMat2Mat(noise.v);
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].2.2 segment->SigmaIndex="<<segment->SigmaIndex);
      Real L.det = 
      {
        //The determinant of a triangular matrix is the product of its diagonal
        VMatrix L.diag = SubRow(Tra(SubDiag(segment->L,0)),segment->EquIdx);
        Exp(VMatAvr(Log(L.diag)))
      };
      Real sigma  = If(segment->SigmaIndex<=0, 1,
       Sqrt(VMatDat(_.sig.blk::_.store,segment->SigmaIndex,1)));
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].2.3");
      Set ti = If(useTimeInfo, segment->TimeInfo, Copy(Empty));
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].3");
      Set arima = segment->Arima;
      Real hasArima = Card(arima)>0;

      Matrix difNoise = noise;
      VMatrix Li = SubRow(SubCol(segment->Li,segment->EquIdx),segment->EquIdx);
      Matrix residuals = VMat2Mat(Li * noise.v);
      Matrix forecast = output.full - noise;
      Real difDeg = 0;
      Real If(hasArima,
      {
        Set aux = segment->ArimaAuxInfo;
        Real m = aux::m;
        Real d = aux::difDegree;
        Real difDeg:=d;
        Real n = m - d;
        Polyn dif  = ARIMAGetDIF(arima);
        Matrix difNoise := Sub(DifEq(dif/1,noise),d+1,1,n,1);
        NameBlock almagro = ARMAProcess::Eval.Almagro(
          aux::ar,aux::ma,Mat2VMat(difNoise),sigma);
        Matrix residuals := VMat2Mat(almagro::_.a);
        Matrix forecast := Sub(output.full,d+1,1,n,1)-residuals;
        1
      });
      Real avr = MatAvr(residuals);
      Real stdErr = Sqrt(MatDat(MtMSqr(residuals),1,1)/Rows(residuals));       

      Set aux = If(Card(ti),
      { 
      //WriteLn("TRACE"+_MID+" eval 7["<<k+"].4");
        Date first = ti->FirstDate;
        Date difFirst = Succ(first, ti->Dating, difDeg);
        Serie serOutput        = MatSerSet(Tra(output),        ti->Dating, first)[1];
        Serie serOutput.extFil = MatSerSet(Tra(output.extFil), ti->Dating, first)[1];
        Serie serOutput.mis    = MatSerSet(Tra(output.mis),    ti->Dating, first)[1];
        Serie serOutput.full   = MatSerSet(Tra(output.full),   ti->Dating, first)[1];
        Serie serFilter        = MatSerSet(Tra(filter),        ti->Dating, first)[1];
        Serie serFilter.mis    = MatSerSet(Tra(filter.mis),    ti->Dating, first)[1];
        Serie serFilter.full   = MatSerSet(Tra(filter.full),   ti->Dating, first)[1];
        Serie serNoise         = MatSerSet(Tra(noise),         ti->Dating, first)[1];
        If(hasArima,
        { 
          Serie serDifNoise  = MatSerSet(Tra(difNoise), ti->Dating, difFirst)[1];
          Serie serResiduals = MatSerSet(Tra(residuals),ti->Dating, difFirst)[1];
          Serie serForecast  = MatSerSet(Tra(forecast), ti->Dating, difFirst)[1];
          [[sigma, stdErr, avr, serOutput, serOutput.mis, serOutput.extFil, serOutput.full, 
            serFilter, serFilter.mis, serFilter.full, serNoise, serForecast,
            serDifNoise, serResiduals, arima]]
        },
        {
          Serie serForecast = MatSerSet(Tra(forecast), ti->Dating, first)[1];
          [[sigma, stdErr, avr, serOutput, serOutput.mis, serOutput.extFil, serOutput.full,
            serFilter, serFilter.mis, serFilter.full, serNoise, serForecast]]
        })
      },
      {
        If(hasArima,
        { 
          [[sigma, stdErr, avr, output, output.extFil, output.mis, output.full, 
            filter, filter.mis, filter.full, noise, forecast,
            difNoise, residuals, arima]]
        },
        {
          [[sigma, stdErr, avr, output, output.extFil, output.mis, output.full, 
            filter, filter.mis, filter.full, noise, forecast]]
        })
      });
      Real SetIndexByName(aux);
      Eval(name+"=aux")
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.eval =
  "Set values of all blocks from a given row vector of values";
  Set eval(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Real setStore(values);
    _eval(values, True, False)
  };
/*
  VBR: no está acabada aún.
  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.forecast.bands =
  "";
  Set forecast.bands(Matrix param.mcmc, Real confidence) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Real q = (1-confidence)/2;
    Set evals = Traspose(For(1,Rows(param.mcmc),Set(Real r)
    {
      _eval(SubRow(param.mcmc,[[r]]), True, True)
    }));
    For(1,Card(_.arm.blk::_.NoiseDistrib), Set(Real k)
    {
      Set segment = (_.arm.blk::_.NoiseDistrib)[k];
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].2");
      Text name = Replace(segment->Name,"::Noise","");
      Matrix forecast = SerMat((evals[k])::serForecast);
      Matrix bands = Group("ConcatColumns",
      For(1,Columns(forecast.mcmc),Matrix(Real c)
      {
        Matrix C = SubCol(forecast.mcmc,[[c]]);
        Real q1  = MatQuantile(C,  q);
        Real avg = MatAvg(C);
        Real q2  = MatQuantile(C,1-q);
        Col(q1,avg,q2)
      }));
      Set series = MatSerSet(bands,Dating())
      Set aux = 
      [[
        (evals[k])::serOutput.full,
        (evals[k])::serForecast
      Eval()
    })
  };
*/
  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getRegEquBlock =
  "Gets the index of a regression equation block specified by its name or "
  "position.\n"
  "If the specified name is not found or the position is out of range no "
  "block will be referenced and an error message will be shown";
  Real getRegEquBlock(Anything resBlock)
  ////////////////////////////////////////////////////////////////////////////
  {
    Text g = Grammar(resBlock);
    Case
    (
      g=="Real", 
      {
        Real n = Card(_.modelDef->NoiseDistrib);
        If(And(resBlock<=n,resBlock>=1), resBlock, 
        {
          Real CMsg::Coded::show(BysMcmc::_.cmsg::_.indexOutOfRange,
            [[_MID+"::getRegEquBlock", resBlock, 1, n]]),
          -1
        })
      },
      g=="Text", 
      {
        Real f = FindIndexByName(_.modelDef->NoiseDistrib,resBlock);
        If(f, f, 
        {
          Real CMsg::Coded::show(BysMcmc::_.cmsg::_.notFoundName,
            [[_MID+"::getRegEquBlock",resBlock]]),
          -1
        })
      },
      1==1,      
      {
        Real CMsg::Coded::show(BysMcmc::_.cmsg::_.invalidType,
            [[_MID+"::getRegEquBlock",resBlock]]),
        -2
      }
    )
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.subRegEquBlockV =
  "Extracts from a matrix A the rows corresponding to a block of regression "
  "equations specified by resBlock as is described in method getRegEquBlock";
  VMatrix subRegEquBlockV(Anything resBlock, VMatrix A)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real blk = getRegEquBlock(resBlock);
    SubRow(A,(_.modelDef->NoiseDistrib)[blk]->EquIdx)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.subDifRegEquBlockV =
  "Extracts from a matrix A the rows corresponding to a block of regression "
  "equations specified by resBlock as is described in method getRegEquBlock, "
  "and applys the corresponding ARIMA difference filter if exists.";
  VMatrix subDifRegEquBlockV(Anything resBlock, VMatrix A)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real blk = getRegEquBlock(resBlock);
    Set segment = (_.modelDef->NoiseDistrib)[blk];
    Set aux = segment->ArimaAuxInfo;
    If(Not(aux::difDegree), SubRow(A,segment->EquIdx),
    {
      VMatrix D  = (segment->ArimaAuxInfo)::D;
      VMatrix A_ = SubRow(A,segment->EquIdx); 
      VMatrix DA = D*A_;
      SubRow(DA,Range(aux::difDegree+1,aux::m,1))
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.subRegEquBlock =
  "Extracts from a matrix A the rows corresponding to a block of regression "
  "equations specified by resBlock as is described in method getRegEquBlock";
  Matrix subRegEquBlock(Anything resBlock, Matrix A)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real blk = getRegEquBlock(resBlock);
    SubRow(A,(_.modelDef->NoiseDistrib)[blk]->EquIdx)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.subDifRegEquBlock =
  "Extracts from a matrix A the rows corresponding to a block of regression "
  "equations specified by resBlock as is described in method getRegEquBlock, "
  "and applys the corresponding ARIMA difference filter if exists.";
  Matrix subDifRegEquBlock(Anything resBlock, Matrix A)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real blk = getRegEquBlock(resBlock);
    Set segment = (_.modelDef->NoiseDistrib)[blk];
    Set aux = segment->ArimaAuxInfo;
    DifEq(aux::dif/1,SubRow(A,segment->EquIdx))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getInput =
  "Returns original input matrix filtered by current missing block values "
  "for a block of regression equations specified by resBlock as is described "
  "in method getRegEquBlock";
  Matrix getInput(Anything resBlock, Set beta.index)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix X_U = _.mis.blk::filter.input(_.modelDef->X);
    VMatrix X = SubCol(X_U,beta.index);
    VMat2Mat(subRegEquBlockV(resBlock, X))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getOutput =
  "Returns original output matrix filtered by current missing block values "
  "for a block of regression equations specified by resBlock as is described "
  "in method getRegEquBlock";
  Matrix getOutput(Anything resBlock)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix Y = _.mis.blk::filter.output(_.modelDef->Y);
    VMat2Mat(subRegEquBlockV(resBlock, Y))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getNoise =
  "Returns integrated noise for a given vector of linear block parameters "
  "Y-X*b for a block of regression equations specified by resBlock as is "
  "described in method getRegEquBlock";
  Matrix getNoise(Anything resBlock, Set beta.index, Matrix beta)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real blk = getRegEquBlock(resBlock);
    Matrix X = getInput(blk, beta.index);
    Matrix Y = getOutput(blk);
    Y-X*beta
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getDifInputFull =
  "Returns differenced input matrix filtered by current missing block "
  "values D(B)*X for full block of regression equations specified by resBlock "
  "as is described in method getRegEquBlock";
  Matrix getDifInputFull(Anything resBlock)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix X_U = _.mis.blk::filter.input(_.modelDef->X);
    VMat2Mat(subDifRegEquBlockV(resBlock, X_U))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getDifInput =
  "Returns differenced input matrix filtered by current missing block "
  "values D(B)*X for a block of regression equations specified by resBlock "
  "as is described in method getRegEquBlock";
  Matrix getDifInput(Anything resBlock, Set beta.index)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix X_U = _.mis.blk::filter.input(_.modelDef->X);
    VMatrix X = SubCol(X_U,beta.index);
    VMat2Mat(subDifRegEquBlockV(resBlock, X))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getDifOutput =
  "Returns differenced output matrix filtered by current missing block "
  "values D(B)*Y for a block of regression equations specified by resBlock "
  "as is described in method getRegEquBlock";
  Matrix getDifOutput(Anything resBlock)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix Y_V = _.mis.blk::filter.output(_.modelDef->Y);
    VMat2Mat(subDifRegEquBlockV(resBlock, Y_V))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getDifNoise =
  "Returns differenced noise for a given vector of linear block parameters "
  "D(B)*Y - D(B)*X*b for a block of regression equations specified by "
  "resBlock as is described in method getRegEquBlock";
  Matrix getDifNoise(Anything resBlock, Set beta.index, Matrix beta)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real blk = getRegEquBlock(resBlock);
    Matrix X = getDifInput(blk, beta.index);
    Matrix Y = getDifOutput(blk);
    Y-X*beta
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getResiduals =
  "Returns residuals for a given vector of linear block parameters "
  "(D(B)*phi(B)/theta(B))*(Y-X*b) for a block of regression equations "
  "specified by resBlock as is described in method getRegEquBlock";
  Matrix getResiduals(Anything resBlock, Set beta.index, Matrix beta)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real    blk = getRegEquBlock(resBlock);
    Set     segment  = (_.modelDef->NoiseDistrib)[blk];
    Matrix  Z   = getNoise(blk, beta.index, beta);
    Set     ev  = ARIMALevinsonEval(segment->Arima, Z);
    ev::a
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.timeForecast.mcmc =
  "Returns time forecast for a block of regression equations representing a "
  "time series with unknown sigma and optional ARIMA structure.\n"
  "The block of equations is the specified by resBlock as is described "
  "in method getRegEquBlock.";
  Matrix timeForecast.mcmc(Matrix   mcmc, 
                           Anything resBlock, 
                           Set      beta.idx,
                           Matrix   inputForecast)
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::@BlockSampler lin = _.mln.blk;
    BysMcmc::@BlockSampler sig = _.sig.blk;

    Real blk = getRegEquBlock(resBlock);
    Real T = Rows(inputForecast);
    Real N = Rows(mcmc);
    Set  segment = (_.modelDef->NoiseDistrib)[blk];
    Set aux = segment->ArimaAuxInfo;
    Real sigmaIndex = segment->SigmaIndex;
    Set sigma.names = [[segment->SigmaName]];
    Set sigma.idx = sig::getMcmcColIndexes(sigma.names);
    Matrix s.mcmc = Sqrt(SubCol(mcmc,sigma.idx));
    Matrix beta.mcmc = SubCol(mcmc,beta.idx);
    Matrix X_b.mcmc = beta.mcmc*Tra(inputForecast);
    Matrix noise_.mcmc = If(Or(aux::difDegree,aux::p,aux::q),
    {
      Real pd = aux::p+aux::difDegree;
      Real m  = aux::m;
      Set pdEquIdx = ExtractByIndex(segment->EquIdx, Range(m-pd+1,m,1));

      Matrix X0 = VMat2Mat(SubCol(SubRow(_.modelDef->X, pdEquIdx),beta.idx));
      Matrix Y0 = VMat2Mat(       SubRow(_.modelDef->Y, pdEquIdx));
      Group("ConcatRows",For(1,N,Matrix(Real numSim)
      {
        Real   s  = MatDat(s.mcmc,numSim,1);
        Matrix E0 = Gaussian(aux::q,1,0,s);
        Matrix E  = Gaussian(T,     1,0,s);
        Matrix Z0 = Y0-X0*Tra(SubRow(beta.mcmc,[[numSim]]));
        Matrix Z  = _.arm.blk::difEq.ARI.MA(blk,E,E0,Z0);
        Tra(Z)
      }))
    },
    {
      Group("ConcatColumns",For(1,T,Matrix(Real t)
      {
        Gaussian(N,1,0,1) $* s.mcmc
      }))
    });
    X_b.mcmc + noise_.mcmc
  };

  //////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.New =
  "Builds a NameBlock that can draw a Gibbs sample of a Bayesian Sparse "
  "Regression model";
  Static @MasterSamplerBasic New(
    @BSR.ModelDef modelDef, 
    BysMcmc::@McmcPartialHandler mcmcPartialHandler,
    Real numBlock, 
    Real firstCol,
    BysMcmc::@Config config)
  //////////////////////////////////////////////////////////////////////////////
  {
    Text name = modelDef->DocInfo->Model.Name; 
    BysMcmc::Bsr::Gibbs::@MasterSamplerBasic master = [[
      //Internal reference to model definition
      Set _.modelDef = modelDef;
      //Output after external filters
      VMatrix _.Y = _.modelDef->Y;

      BysMcmc::@McmcPartialHandler _.mcmcPartialHandler = mcmcPartialHandler;

      //Setting NameBlock description
      Text _.autodoc.description="Gibbs sampler for model "+name;
      BysMcmc::Bsr::Gibbs::@BlockStdLin _.mln.blk = 
      BysMcmc::Bsr::Gibbs::@BlockMainLinear::New
      (
        "@BSR.MainLinBlock."+name,
        EvalSet(_.modelDef->LinearBlock, Text(@BSR.LinearBlock b){ b->Name }),
        mcmcPartialHandler,
        1,
        firstCol,
        config
      );
      BysMcmc::Bsr::Gibbs::@BlockSigma _.sig.blk = 
      BysMcmc::Bsr::Gibbs::@BlockSigma::New
      (
        "@BSR.SigmaBlock."+name,
        _.modelDef->NoiseDistrib,
        mcmcPartialHandler,
        2,
        _.mln.blk::_.lastCol+1,
        config
      );
      BysMcmc::Bsr::Gibbs::@BlockArima _.arm.blk = 
      BysMcmc::Bsr::Gibbs::@BlockArima::New
      (
        "@BSR.ArimaBlock."+name,
        _.modelDef->NoiseDistrib,
        mcmcPartialHandler,
        3, 
        _.sig.blk::_.lastCol+1,
        config
      );

      BysMcmc::Bsr::Gibbs::@BlockStdLin _.mis.blk = 
      BysMcmc::Bsr::Gibbs::@BlockMissing::New
      (
        "@BSR.MissingBlock."+name,
        _.modelDef->OutputMissingBlock,
        _.modelDef->InputMissingBlock,
        VRows(_.modelDef->Y),
        mcmcPartialHandler,
        4,
        _.arm.blk::_.lastCol+1,
        config
      );
      Set _.nonLinBlk = Copy(Empty);
      Set _.blocks = Copy(Empty);
      Real _defined = False
    ]];
    Real master::define.all(0);
    master
  }
};

