//////////////////////////////////////////////////////////////////////////////
// FILE   : _blrc_kernel.tol
// PURPOSE: Bayesian Linear Regression with Linnear Constraint sampling
//          and prior information in sigma blocks.
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BLRC ofrece tres métodos de simulación de una regresión lineal normal:
//
//  1) FACT_ICHOL: Es el método más rápido pero el menos estable numericamente
//                 pues la descomposición de Choleski es muy sensible a la
//                 estructura de los menores principales de la matriz
//  2) FACT_ISVD:  Es bastante más lento que el anterior pero muy estable
//                 pues introduce una ortogonalización completa en cada
//                 simulación.
//  3) FULL_SVD:   Es el doble de lento que el anterior e igualmente estable
//                 y se ofrece sólo por razones de compatibilidad hacia atrás
//
// Si el método elegido es FACT_ICHOL y se detecta un error numérico, entonces
// se intenta el método FACT_ISVD sólo en esa iteración. Si esto ocurre más
// del 80% de las veces tras 100 iteraciones entonces se adopta FACT_ISVD en
// el resto de iteraciones.
//
// Esta estrategia ofrece una buena eficiencia sin pérdida alguna de
// precisión numérica ni robustez
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// CONSTANT
//////////////////////////////////////////////////////////////////////////////
//Contador del número total de simulaciones realizadas
Real BLR_NumSim = 0;
//Error máximo permitido en el chequeo de los sistemas lineales (choleski,...)
Real BLR_Epsilon = 1.E-15;
//Constantes de selección del método utilizado en la simulación
Real BLR_Method_FACT_ICHOL = 1;
Real BLR_Method_FACT_ISVD  = 2;
Real BLR_Method_FULL_SVD   = 3;
//Variable de control del usuario para determinar el método deseado
Real BLR_Method = BLR_Method_FACT_ICHOL;
//Variable de control del usuario del ratio maximo de fracasos admisibles del
//metodo BLR_Method_FACT_ICHOL antes de cambiar automaticamente al metodo
//BLR_Method_FACT_ISVD
Real BLR_ICHOL2ISVD_MaxRatio = 0.50;
//Variable de control del usuario sobre el número de subiteraciones de Gibbs
//a usar en la simulación de la multinormal truncada. Se recomienda no tocar
//si no se conoce a fondo el tema.
Real BLR_GibbsConstrainedMNormal_Size = 20;
 
//////////////////////////////////////////////////////////////////////////////
// FUNCTIONS
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set BLRC_StandarizedRegression
(
  Set sXX,
  Set sXY,
  Set sigma2Set
)
//Multiplica los pares XtX,XtY de cada bloque por su varianza correspondiente
//////////////////////////////////////////////////////////////////////////////
{
  Set covBetaSet = For(1, Card(sigma2Set), Set(Real k)
  {
    Real sk_i = 1/sigma2Set[k];
    SetOfMatrix(sXX[k] * sk_i, sXY[k] * sk_i)
  });
  Set traCovBetaSet = Traspose(covBetaSet);
  Matrix XtX = SetSum(traCovBetaSet[1]);
  Matrix XtY = SetSum(traCovBetaSet[2]);
  [[XtX,XtY]]
};


Real BLRC_SMNP_FACT_ICHOL_WARN_COUNT = 0;
Text BLRC_SMNP_FACT_ICHOL_WARN_FIRST = I2(
"Method BLR_Method_FACT_ICHOL has failed. BLRC will use "
"BLR_Method_FACT_ISVD at this simulation, to avoid numerical problems. If "
"problem persists after a large number of simulations then may be that "
"your model was non well defined and you should revise it. If this "
"message appears for a high percent of simulations then you should use "
"singular value decomposition by using next code:\n",
"El método BLR_Method_FACT_ICHOL ha fracasado. BLRC utilizará "
"BLR_Method_FACT_ISVD en esta simulación, para evitar problemas numéricos"
". Si el problema persiste después de un gran número de simulaciones "
"entonces puede ser que su modelo no esté bien definido y debe revisarlo, "
"Si este mensaje aparece en un alto porcentaje de simulaciones sería "
"mejor usar la descomposición de valor singular mediante el código:\n")+
"  Real BLR_Method := BLR_Method_FACT_ISVD;";

Text BLRC_SMNP_FACT_ICHOL_WARN_NEXT = I2(
"Method BLR_Method_FACT_ICHOL has failed: calling BLR_Method_FACT_ISVD ...",
"El método BLR_Method_FACT_ICHOL ha fracasado: llamando a BLR_Method_FACT_ISVD");

Text BLRC_SMNP_FACT_ICHOL_WARN_TOO = I2(
"Method BLR_Method_FACT_ICHOL has failed too times. "
"Changing method to BLR_Method_FACT_ISVD for rest of simulations",
"El método BLR_Method_FACT_ICHOL ha fracasado demasiadas veces. "
"Se cambia el método a BLR_Method_FACT_ISVD para el resto de simulaciones.")+
"  Real BLR_Method := BLR_Method_FACT_ISVD;";

//////////////////////////////////////////////////////////////////////////////
Set BLRC_SMNP_FACT_ICHOL
(
  Set sX,
  Set sY,
  Set sXY,
  Set sXX,
  Set sigma2Set,
  Set sigma2Num
)
//Devuelve el manejador de varianza del método de simulación multinormal
//truncada correspondiente a la factorización de Choleski de la matriz
//de información, que es la inversa de la de covarianzas
//Este método es el más rápido de los propuestos y es el recomendado por
//defecto. A veces puede fallar puntualmente por problemas numéricos y en tal
//caso se utiliza momentáneamente el método BLRC_SMNP_FACT_ISVD
//////////////////////////////////////////////////////////////////////////////
{
//Real t0= Copy(Time);
// La entrada de sX es un triplet y cada uno de los bloques
// han de ser matrices
  Set sr = BLRC_StandarizedRegression(sXX,sXY,sigma2Set);
  Matrix XtX = sr[1];
  Matrix XtY = sr[2];
//Real t1= Copy(Time);
  Matrix L = Choleski(XtX);
  Real n = Rows(XtX);
  //Checks if Choleski decomposition is all right
  Real ok = If(Or(Rows(L)!=n,HasUnknown(L)), False,
  {
    Matrix r      = Gaussian(n,1,0,1);
    Real   rtSr   = MatDat(Tra(r)*XtX*r,1,1);
    Real   rtLLtr = MatDat(MtMSqr(Tra(L)*r),1,1);
    Real   err    = Abs(rtSr-rtLLtr)/rtSr;
    err < BLR_Epsilon
  });
  If(!ok,
  {
    Real BLRC_SMNP_FACT_ICHOL_WARN_COUNT := BLRC_SMNP_FACT_ICHOL_WARN_COUNT+1;
    //If Choleski is wrong then notify it to the user and call SVD
    Real fail_ratio = BLRC_SMNP_FACT_ICHOL_WARN_COUNT/BLR_NumSim;
    WriteLn(Case
    (
      BLRC_SMNP_FACT_ICHOL_WARN_COUNT==1,
      {
        BLRC_SMNP_FACT_ICHOL_WARN_FIRST
      },
      Or(BLR_NumSim<100, fail_ratio<=BLR_ICHOL2ISVD_MaxRatio),
      {
        BLRC_SMNP_FACT_ICHOL_WARN_NEXT
      },
      1==1,
      {
        Real BLR_Method := BLR_Method_FACT_ISVD;
        BLRC_SMNP_FACT_ICHOL_WARN_TOO
      }
    )+
    " (FAIL RATIO = "+FormatReal(fail_ratio,"%.2lf")+">"+
    "BLR_ICHOL2ISVD_MaxRatio="+FormatReal(BLR_ICHOL2ISVD_MaxRatio,"%.2lf")+
    ")","W");
    BLRC_SMNP_FACT_ISVD(sX,sY,sXY,sXX,sigma2Set,sigma2Num)
  },
  {
  //Real t2= Copy(Time);
    //Using TrSolve two times to solve nu in normal equations XtX*nu=XtY
    Matrix nu = TrSolve(L,TrSolve(L,XtY,1,0,1),1,1,1);
  //Real t3= Copy(Time);
  //WriteLn("TRACE BLRC_SMNP_FACT_ICHOL iteration "+IntText(BLR_NumSim)+" t1 ="<<Real(t1-t0)+" t2 ="<<Real(t2-t1)+" t3 ="<<Real(t3-t2)+" t  ="<<Real(t3-t0));
    Set covHandler = [["FACT_ICHOL", L]];
    [[nu, covHandler]]
  })
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("",BLRC_SMNP_FACT_ICHOL);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set BLRC_SMNP_FACT_ISVD
(
  Set sX,
  Set sY,
  Set sXY,
  Set sXX,
  Set sigma2Set,
  Set sigma2Num
)
//Devuelve el manejador de varianza del método de simulación multinormal
//truncada correspondiente a la factorización de valor singular de la matriz
//de información, que es la inversa de la de covarianzas
//////////////////////////////////////////////////////////////////////////////
{
//Real t0= Copy(Time);
// La entrada de sX es un triplet y cada uno de los bloques
// han de ser matrices
  Set sr = BLRC_StandarizedRegression(sXX,sXY,sigma2Set);
  Matrix XtX = sr[1];
  Matrix XtY = sr[2];
//Real t1= Copy(Time);
  Set svd = SVD(XtX);
  Matrix D2 = svd[2];
  Matrix V  = svd[3];
  Matrix D  = RPow(D2,0.5);
  Real n = Rows(XtX);
  //XtX Condition number
  Real   cn = MatDat(D,n,n)/MatDat(D,1,1);
  If(1/cn<BLR_Epsilon, WriteLn(I2(
    "BLRC: Ill conditioned linear regression model.\n"
    "XtX has a too large condition number ("
    <<cn+") for current variance set:\n"<<sigma2Set,
    "BLRC: El modelo de regresión lineal está mal condicionado.\n"
    "XtX tiene un número de condición demasiado grande ("
    <<cn+") para el conjunto actual de varianzas:\n"<<sigma2Set),
    "W"));
  Matrix D2i =PseudoInverseDiag(D2,BLR_Epsilon);
//Real t2= Copy(Time);
  Matrix nu = V*(D2i*(Tra(Tra(XtY)*V)));
//Matrix nu = Tra(V)*(D2i*(V*XtY));
//Real t3= Copy(Time);
//WriteLn("TRACE BLRC_SMNP_FACT_ISVD iteration "+IntText(BLR_NumSim)+" t1 ="<<Real(t1-t0)+" t2 ="<<Real(t2-t1)+" t3 ="<<Real(t3-t2)+" t  ="<<Real(t3-t0));
  Set covHandler = [["FACT_ISVD", V, Matrix Tra(SubDiag(D,0))]];
  [[nu, covHandler]]
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("",BLRC_SMNP_FACT_ISVD);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Set BLRC_SMNP_FULL_SVD
(
  Set sX,
  Set sY,
  Set sXY,
  Set sXX,
  Set sigma2Set,
  Set sigma2Num
)
//Devuelve el manejador de varianza del método de simulación multinormal
//truncada correspondiente a la inversión de valor singular de la matriz
//de información, que es la inversa de la de covarianzas.
//Este método es el más lento y sólo se ofrece a efectos de compatibilidad
//hacia atrás por si aparecen problemas con versiones de TOL antiguas.
//////////////////////////////////////////////////////////////////////////////
{
//Real t0= Copy(Time);
// La entrada de sX es un triplet y cada uno de los bloques
// han de ser matrices
  Set sr = BLRC_SMNP_StandarizedRegression(sXX,sXY,sigma2Set);
  Matrix XtX = sr[1];
  Matrix XtY = sr[2];
//Real t1= Copy(Time);
  Matrix covBeta    = SVDInverse(XtX);
//Real t2= Copy(Time);
  Matrix beta     = covBeta*XtY;
//Real t3= Copy(Time);
//WriteLn("TRACE BLR_SMNP_SVD iteration "+IntText(BLR_NumSim)+" t1 ="<<Real(t1-t0)+" t2 ="<<Real(t2-t1)+" t3 ="<<Real(t3-t2)+" t  ="<<Real(t3-t0));
  Set covHandler = [["FULL_SVD", covBeta]];
  [[beta, covHandler]]
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("",BLRC_SMNP_FULL_SVD);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//Used method will be BLRC_SMNP[BLR_Method]
Set BLRC_SMNP =
{[[
  Code BLRC_SMNP_FACT_ICHOL; //Real BLR_Method_FACT_ICHOL = 1;
  Code BLRC_SMNP_FACT_ISVD;  //Real BLR_Method_FACT_ISVD  = 2;
  Code BLRC_SMNP_FULL_SVD    //Real BLR_Method_FULL_SVD   = 3;
]]};

//////////////////////////////////////////////////////////////////////////////
 
Text CheckConstraint(Matrix B, Matrix b, Matrix x)
{
  Matrix check = LE(B*x,b);
  Text If(Real MatSum(check)==Rows(check), "OK", "FAIL")
};

//////////////////////////////////////////////////////////////////////////////
Matrix BLRC_MHGenBetaBlock
(
  Matrix BMat, // Beta actuales
  Matrix SMat, // Sigma
  Matrix JMat, // Beta y Sigma
  Set data,    // Datos para el bloque
  Real idWs    // Indicador del WS
)
//////////////////////////////////////////////////////////////////////////////
{
  Real BLR_NumSim := BLR_NumSim+1;
//Real t0 = Copy(Time);
  // Acceso a la informacion de datos del bloque
  Set sX           = data["sX"];
  Set sY           = data["sY"];
  Set sXX          = data["sXX"];
  Set sXY          = data["sXY"];
  Set sYY          = data["sYY"];
  Set blockSizeSet = data["blockSizeSet"];
  Matrix B         = data["BMat"];
  Matrix b         = data["bMat"];

//Text WriteLn("SMat"<<SMat);
  // Generacion de la muestra
  Set sigma2Set = MatSet(Tra(SMat))[1];
//Text WriteLn("sigma2Set"<<sigma2Set);
  Code blrc_fun = BLRC_SMNP[BLR_Method];
  Set paramSet  = blrc_fun(sX, sY, sXY, sXX, sigma2Set, blockSizeSet);

  Matrix nu          = paramSet[1];
  Set    covHandler  = paramSet[2];

  //WriteLn("Generando con RandConstrainedMNormal");
  //Text WriteLn("Restricciones iniciales = "+CheckConstraint(B, b, BMat));

//Real t1 = Copy(Time);
 
  Matrix beta = Tra(RandConstrainedMNormal
  (
    nu,covHandler, B, b, 1.0, 1, BLR_GibbsConstrainedMNormal_Size, BMat
  ));
//Real t2 = Copy(Time);

  // Actualizacion de la informacion del WS
  Set e2Set = For(1, Card(sigma2Set), Matrix(Real k)
  {
    Matrix yk2  = sYY[k];
    Matrix xk2  = sXX[k];
    Matrix xkyk = sXY[k];

    Matrix ek2  = yk2 - RProd(Tra(beta)*xkyk, 2)+Tra(beta)*xk2*beta;
    ek2
  });

  Real nCall       = MHWSGet(idWs, 2)[1];
  Real newCall     = nCall+1;
  Anything PutDeepCopy(idWs, 1, e2Set);
  Anything PutDeepCopy(idWs, 2, SetOfReal(newCall));
//Real t3 = Copy(Time);
//WriteLn("TRACE BLRC_MHGenBetaBlock iteration "+IntText(BLR_NumSim)+" TIME: "+Time+" t1 ="<<Real(t1-t0)+" t2 ="<<Real(t2-t1)+  " t3 ="<<Real(t3-t2)+  " t  ="<<Real(t3-t0));
  // Vector de salida
  beta
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("",BLRC_MHGenBetaBlock);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix BLRC_MHGenSigma2Block
(
  Matrix SMat, // Sigma2 actuales
  Matrix BMat, // Beta
  Matrix JMat, // Beta y Sigma
  Set data,    // Datos para el bloque
  Real idWs    // Indicador del WS
)
//////////////////////////////////////////////////////////////////////////////
{
  // Acceso a la informacion del WS
  Set e2Set   = MHWSGet(idWs, 1);
  Real nCall  = MHWSGet(idWs, 2)[1];

  Real If(EQ(nCall%100,0),
   Msg("BLR", "Iteration number "+IntText(nCall)), False);

  // Acceso a la informacion de datos del bloque
  Set priorSet      = data["sigma2.PriorSet"];
  Set blockSizeSet  = data["blockSizeSet"];
 
  // Generacion de la muestra
  Set sigma2Set = For(1, Card(e2Set), Real(Real k)
  {
    Real doSigma = priorSet[k];
    If(IsUnknown(doSigma),
    {
      Matrix ek2 = e2Set[k];
      Real mk    = MatDat(ek2, 1, 1);
      Real nk    = blockSizeSet[k];
 
      Real chi2Inv = mk/RandChisq(nk-1);
      chi2Inv
    }, doSigma^2)
  });

  // Actualizacion de la informacion del WS
  Matrix sigma2 = SetCol(sigma2Set);

  // Vector de salida
  sigma2
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("",BLRC_MHGenSigma2Block);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Matrix BLRC
(
  Set modelC,
  Real calls,
  Real burning,
  Text fileSample
)
//////////////////////////////////////////////////////////////////////////////
{
  Real BLR_Method_Old = BLR_Method;

  Real BLR_NumSim := 0;
 
  Set model     = modelC[1];
  Matrix BMat   = modelC[2];
  Matrix bMat   = modelC[3];
  Matrix beta0  = modelC[4];
 
  Set sY        = model->SY;
  Set sX        = model->SX;
  Set sS        = model->SS;

  Set inputDef  = model->InputDefinition;
  Set sigmaDef  = model->SigmaDefinition;

  // Datos generales
  Set blockSizeSet = EvalSet(sY, Rows);

  // Definicion de informacion para el bloque de las varianzas
  Real    sigma2.Size        = Card(sigmaDef);
  Real    sigma2.ModeSampler = 0;
  Matrix  sigma2.IniValue    = SetCol(EvalSet(sigmaDef, Real(Set reg)
  { reg->IniValue }));
  Set sigma2.BlockData    =
  {
    Set  sigma2.PriorSet = EvalSet(sigmaDef, Real(Set reg)
    {
      Set priorInfo   = reg->PriorInfo;
      Real priorValue = If(IsEmpty(priorInfo), ?,
      {
        Text class = ToUpper(priorInfo->ClassName);
        Case
        (
          class == "FIXED", priorInfo->Parameters->Value,
          1, ?
        )
      });
      priorValue
    });
    SetOfAnything(sigma2.PriorSet, blockSizeSet)
  };
  Code sigma2.BlockGen = BLRC_MHGenSigma2Block;

  Set sigma2.BlockDef = MHBlockDef
  (
    sigma2.Size,
    sigma2.ModeSampler,
    sigma2.IniValue,
    sigma2.BlockData,
    sigma2.BlockGen
  );

  // Definicion de informacion para el bloque de los parametros
  Real   beta.Size        = Card(inputDef);
  Real   beta.ModeSampler = 0;
  Matrix beta.IniValue    = beta0;
//   Matrix beta.IniValue    = SetCol(EvalSet(inputDef, Real(Set reg)
//   { reg->IniValue }));
  Set beta.BlockData      =
  {
    Set sXXY = For(1, sigma2.Size, Set(Real k)
    {
      Set bk     = sX[k+1];
      Real colk  = bk[2];
      Matrix xk  = bk[3];
      Matrix yk  = sY[k];

      Matrix xk2Aux = Case
      (
        IsEmpty(sS), Tra(xk)*xk,
        IsEmpty(sS[k]), Tra(xk)*xk,
        1, { Matrix s_1 = sS[k][3]; Tra(xk)*s_1*xk}
      );

      Matrix xkykAux = Case
      (
        IsEmpty(sS), Tra(xk)*yk,
        IsEmpty(sS[k]), Tra(xk)*yk,
        1, { Matrix s_1 = sS[k][3]; Tra(xk)*s_1*yk}
      );

      Matrix yk2     = Case
      (
        IsEmpty(sS), Tra(yk)*yk,
        IsEmpty(sS[k]), Tra(yk)*yk,
        1, { Matrix s_1 = sS[k][3]; Tra(yk)*s_1*yk}
      );

      Matrix xk2  = FullWithZeroSquare(xk2Aux, colk, beta.Size);
      Matrix xkyk = FullWithZeroRow(xkykAux, colk, beta.Size);
      SetOfMatrix(xk2, xkyk, yk2)
    });
    Set sXX = Traspose(sXXY)[1];
    Set sXY = Traspose(sXXY)[2];
    Set sYY = Traspose(sXXY)[3];
    SetOfAnything(sX, sY, sXX, sXY, sYY, BMat, bMat, blockSizeSet)
  };
  Code beta.BlockGen = BLRC_MHGenBetaBlock;

  Set beta.BlockDef = MHBlockDef
  (
    beta.Size,
    beta.ModeSampler,
    beta.IniValue,
    beta.BlockData,
    beta.BlockGen
  );

  // Definicion de los parametros de entrada y WS
  Set defMH     = SetOfSet(beta.BlockDef, sigma2.BlockDef);
  Set defWSMH   = SetOfAnything(Copy(Empty),SetOfReal(0));
  Real t0 = Copy(Time);
  Matrix mhRes = If(fileSample == "",
    MetropolisHastings(defMH, burning, calls, defWSMH),
  {
    Text ext    = GetFileExtension(fileSample);
    Text name   = GetFilePath(fileSample)+GetFileName(fileSample);
    Set monitor = SetOfAnything(ext, name, 1, 0);
    MetropolisHastings(defMH, burning, calls, defWSMH, monitor)
  });
  Real t1 = Copy(Time)-t0;
  WriteLn("Total time for "+IntText(burning+calls)+" simulations = "<<t1+" seconds");
  WriteLn("Time by simulation = "<<Real(t1/(burning+calls))+" seconds");
  Real If(BLR_Method != BLR_Method_Old,
  {
    Real BLR_Method := BLR_Method_Old;
    WriteLn("Restoring old BLR_Method");
    BLR_Method
  });
  mhRes
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("", BLRC);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Real BLRC_ParamMultInConst(Set const, Text param)
//////////////////////////////////////////////////////////////////////////////
{
  Set paramMult = const->ParamMult;
  Set paramMult.Sel = Select(paramMult, Real(Set s) { s->Param == param });
  If(IsEmpty(paramMult.Sel),
     0,
     paramMult.Sel[1]->Mult)
};
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


/* */






