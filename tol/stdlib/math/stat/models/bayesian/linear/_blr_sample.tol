//////////////////////////////////////////////////////////////////////////////
// FILE   : blr_test.tol
// PURPOSE: Testing processes for blr.tol
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// INCLUDES
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// FUNCTIONS
//////////////////////////////////////////////////////////////////////////////
Date GetRandDate(Date ini, Date end, TimeSet dating)
{
  Real size = DateDif(Mensual, ini, end);
  Real k = Round(Rand(0,size));
  Succ(ini, dating, k)
};

Serie RandPulse(Date ini, Date end, TimeSet dating)
{
  Date d = GetRandDate(ini, end, dating);  
  Serie ser = SubSer(Pulse(d, dating), ini, end);
  Eval("Serie Pulse"+FormatDate(d, "%c%Y%m%d")+" = ser;")
};

Serie RandStep(Date ini, Date end, TimeSet dating)
{
  Date d = GetRandDate(ini, end, dating);  
  Serie ser = SubSer(Step(d, dating), ini, end);
  Eval("Serie Step"+FormatDate(d, "%c%Y%m%d")+" = ser;")
};

Serie RandCompens(Date ini, Date end, TimeSet dating)
{
  Date d = GetRandDate(ini, end, dating);  
  Serie ser = SubSer(Compens(d, dating), ini, end);
  Eval("Serie Compens"+FormatDate(d, "%c%Y%m%d")+" = ser;")
};

Set EffectSet = SetOfCode(RandPulse, RandStep, RandCompens);

Set SimInfo
(
  Real numOut, 
  Real minNumData, 
  Real minNumInputHier, 
  Real minNumHier, 
  Set effectSet
)
{
  Set seriesOutput = For(1, numOut, Set(Real k)
  {
     Real sigma    = Rand(0, 1);
     Real sigma2   = sigma^2;  
     Real numData  = Round(Rand(minNumData, 2*minNumData));
     Date iniDate  = y1990m01d01; 
     Date endDate  = Succ(iniDate, Mensual, numData); 
     Serie error   = SubSer(Gaussian(0, sigma, Mensual), iniDate, endDate);
  
     
     Real numHier  = Round(Rand(minNumHier, 2*minNumHier)); 
  //Text WriteLn("numInput "<<numInput);
     Set treeParam = For(1, numHier, Set(Real j)
     {
       Real root = Rand(-10, 10);
       Real sigma = Rand(0, 2); 
       Real numInput = Round(Rand(minNumInputHier, 2*minNumInputHier)); 
       For(1, numInput, Set(Real k)
       {  SetOfReal(root, sigma, Gaussian(root,sigma))  })
     });
     Set parameters = Group("Concat",treeParam);
  
     Set inputs = For(1, Card(parameters), Serie(Real k)
     {
       Real c = Round(Rand(0, Card(effectSet))+0.5);
  
       Code genSer = effectSet[c];
  //Text WriteLn("effectSet "<<c);
       genSer(iniDate, endDate, Mensual) 
     });
     Set effects = For(1, Card(parameters), Serie(Real k)
     {
       Real coef = parameters[k][3];
       Serie input = inputs[k];
       coef*input 
     });
     Serie filter = SetSum(effects);
     Serie output = filter+error;
     Set inputDef = 
     SetOfAnything
     (
       output, 
       filter, 
       error, 
       inputs, 
       effects, 
       parameters, 
       sigma2, 
       treeParam
     )
  });
  Set traSerOut = Traspose(seriesOutput);  
  Real numData  = SetSum(EvalSet(traSerOut[1], Real(Serie ser){CountS(ser)}));
  Real numInput = SetSum(EvalSet(traSerOut[4],Card));
  Real numPar   = numInput+numOut;  
  Set inputParam = Group("Concat", traSerOut[6]);
  Set sigmaParam = traSerOut[7];
  Set treeParam  = traSerOut[6]; 
  Set allParameters = (Traspose(inputParam)[3])<<sigmaParam;
  Set info = SetOfReal(numOut, numData, numInput, numPar);
  SetOfSet
  (
    seriesOutput, 
    info, 
    allParameters, 
    inputParam, 
    sigmaParam, 
    treeParam
  )
};

Set GenRandomModel
(
  Real numOut, 
  Real minNumData, 
  Real minNumInputHier,
  Real numHier, 
  Real calls, 
  Set effectSet
)
{
  Set simInfo = 
   SimInfo(numOut, minNumData, minNumInputHier, numHier, EffectSet);
  Set seriesOutput  = simInfo["seriesOutput"];
  Set info          = simInfo["info"];
  Set allParameters = simInfo["allParameters"];
  Set treeParam     = simInfo["treeParam"];

  Set sY = EvalSet(seriesOutput, Matrix(Set reg)
  {
    Serie output = reg["output"];
    Matrix y = Tra(SerMat(output));
    y
  });
  
  Set sXMat = EvalSet(seriesOutput, Set(Set  reg)
  {
    Set inputs = reg["inputs"];
    Matrix x = Tra(SerSetMat(inputs));
    Real i = Rows(x);
    Real j = Columns(x);
    SetOfAnything(x, i, j)
  });
  
  Set sX = SetOfText("TRIPLET")<<
  {
    Set traXMat = Traspose(sXMat);
    Set dims = Traspose(SetOfSet(traXMat[2], traXMat[3]));
    Set coor = CoorTriplet(dims, 1, 1);
    For(1, Card(coor), Set(Real k)
    {
      coor[k]<<SetOfMatrix(sXMat[k][1])
    })
  }; 
  Set inputDefinitionOut = For(1, numOut, Set(Real k)
  {
    Set reg = seriesOutput[k];
    Text nameOut = "Output"+IntText(k);

    Set inputs        = reg["inputs"];
    Set inpParameters = reg["parameters"];

    Real cInp = Card(inputs);
    For(1, cInp, Set(Real k)
    {
      Serie ser      = inputs[k];
      Real realValue = inpParameters[k][3];
      Text name = nameOut+"_"+Name(inputs[k]);
      Real iniValue = 0.1;
      Set priorInfo = If(GT(Rand(0,1),0.5), Copy(Empty),
      {
        Text class     = "Normal";
        Real priorNu    = realValue-Rand(-2, 2);
        Real priorSigma = Rand(0, 1)/4;
        Set parameters = BLRPriorInfo.Normal(priorNu,  priorSigma);
        BLRPriorInfo(class, parameters)  
      });
      Set limInfo   = Copy(Empty);
      BLRParamDef(name, iniValue, priorInfo, limInfo)
    })
  });
  Set hierDefinitionOut  = For(1, numOut, Set(Real k)
  {
    Set hier = treeParam[k];
    Set paramInput = inputDefinitionOut[k];
    Set info = For(1, Card(paramInput), Set(Real j)
    {
      Set reg = paramInput[j];
      Text nameInp = reg->Name;
      Text nameOut = Tokenizer(nameInp, "_")[1]; 
      Real valueHp = hier[j][1];
      Real sigmaBlockHp = 0.1;//hier[j][2];
      Text nameHp = nameOut+"_Hp"+FormatReal(valueHp);
      Set treeReg = BLRHierTree(nameHp, nameInp);
      Set parDef  = BLRParamDef(nameHp, valueHp, Copy(Empty), Copy(Empty)); 
      Set sigmaBlockDef =  BLRHierSigmaBlock(nameHp, sigmaBlockHp);
      SetOfSet(parDef, sigmaBlockDef, treeReg)
    });
    info
  });
  Set hierDefinitionTra = Traspose(Group("Concat", hierDefinitionOut));
  Set paramSet  = Unique(hierDefinitionTra[1]);
  Set sigmaBlock = Unique(hierDefinitionTra[2]);
  Set tree = hierDefinitionTra[3];
  Set hierDefinition =  BLRHierDef
   (paramSet, sigmaBlock,tree);


  Set inputDefinition = Group("Concat", inputDefinitionOut);
  
  Set sigmaDefinition =  For(1, numOut, Set(Real k)
  {
    Set reg = seriesOutput[k];
    Text nameOut = "Output"+IntText(k);
    Text name = nameOut+"_Sigma";
    Real iniValue = 0.1;
    Set priorInfo = Copy(Empty); 
    Set limInfo   = Copy(Empty);
    BLRParamDef(name, iniValue, priorInfo, limInfo)
  }); 
  

  Set modelSet  = BLRModelDef(sY, sX, inputDefinition, sigmaDefinition);
  Set modelPSet = BLR_AddPrior(modelSet);
  Set modelHSet = BLR_AddHierarchy(modelSet, hierDefinition); 
  Set modelHPSet = BLR_AddPrior(modelHSet);

  SetOfSet
  (
    modelSet,
    modelPSet,
    modelHSet,
    modelHPSet,
    simInfo,
    seriesOutput,
    info,
    allParameters,
    modelHSet,
    hierDefinition,
    hierDefinitionTra
  )
};

Set ResultBLR
(
  Set modelSet,
  Matrix mhRes,
  Set allParameters,
  Set info,
  Real lapse,
  Real calls  
)
{
  Set inputDefinition = modelSet->InputDefinition; 
  Set sigmaDefinition = modelSet->SigmaDefinition; 
 
  Set names     = Traspose(inputDefinition)[1]<<Traspose(sigmaDefinition)[1] ;

  Set result    = MHResult(Tra(mhRes), names, inputDefinition<<sigmaDefinition);
 
  Set compRes = For(1, Card(allParameters), Set(Real k)
  {
    Set reg = result[k];
    Text name = reg->Name;
    Real med = reg->Median;
    Real avg = reg->Average;
    Real val = allParameters[k];
    Real perMed = (val-med)/val;
    Real perAvg = (val-avg)/val;
    SetOfAnything(name, med, avg, val, perMed, perAvg)
  });

  Real perMed2 = SetAvr(EvalSet(Traspose(compRes)[5], Real(Real err){err^2}));
  Real perAvg2 = SetAvr(EvalSet(Traspose(compRes)[6], Real(Real err){err^2}));
  Real allCalls = calls+0.10*calls;
  Set dataRes = info<<SetOfReal(lapse, allCalls, perMed2, perAvg2);
  SetOfSet(dataRes, result, inputDefinition, sigmaDefinition, compRes)
};

//////////////////////////////////////////////////////////////////////////////
// PROCEDURES
//////////////////////////////////////////////////////////////////////////////
// BLR con informacion a priori

Real numOut      = 1; //Round(Rand(1, 1)); 
Real minNumData  = 310;//Round(Rand(100, 200));
Real minNumHier  = 1;//Round(Rand(1,7));
Real minNumInputHier = 30;// Round(Rand(1, 1));
Real numCalls    = 100;//Round(Rand(50, 100));

Set randomModel = GenRandomModel 
(
  numOut, 
  minNumData, 
  minNumInputHier,
  minNumHier, 
  numCalls, 	
  EffectSet
);

Set modelSet1      = randomModel["modelHPSet"];
Real numInp        = Card( modelSet1["inputDef"]);
Real numData       = SetSum(EvalSet( modelSet1[1], Rows));

Real ini = Time;
Matrix mhRes = BLR(modelSet1, numCalls, 0.1*numCalls, "");
Real lapse = Copy(Time)-ini;

Text BLR_SMNP_Mode := "NSVD"; // Inversion via SVD
Real iniNSVD = Time;
Matrix mhResNSVD = BLR(modelSet1, numCalls, 0.1*numCalls, "");
Real lapseNSVD = Copy(Time)-iniNSVD;

/*

Set result = ResultBLR(modelSet, mhRes, allParameters, info, lapse, numCalls);


/*
Text BLR_SMNP_Mode := "NSVD"; // Inversion via SVD
Real iniNSVD = Time;
Matrix mhResNSVD = BLR(modelSet, numCalls, 0.1*numCalls, "");
Real lapseNSVD = Copy(Time)-iniNSVD;
*/

//
/*Set resultNSVD = ResultBLR(modelSet, mhResNSVD, 
 allParameters, info, lapse, numCalls);
*/




/*
Set CheckBLR
(
  Real numOut, 
  Real minNumData, 
  Real minNumInput, 
  Real calls, 
  Set effectSet
)
{
  Set inputDefinition = randomModelSet[3]; 
  Set sigmaDefinition = randomModelSet[4]; 

  Set names     = Traspose(inputDefinition)[1]<<Traspose(sigmaDefinition)[1] ;
  Set result    = MHResult(Tra(mhRes), names, inputDefinition); 
  Set compRes = For(1, Card(result), Set(Real k)
  {
    Set reg = result[k];
    Text name = reg->Name;
    Real med = reg->Median;
    Real avg = reg->Average;
    Real val = allParameters[k];
    Real perMed = (val-med)/val;
    Real perAvg = (val-avg)/val;
    SetOfAnything(name, med, avg, val, perMed, perAvg)
  });
  Real perMed2 = SetAvr(EvalSet(Traspose(compRes)[5], Real(Real err){err^2}));
  Real perAvg2 = SetAvr(EvalSet(Traspose(compRes)[6], Real(Real err){err^2}));
  Real allCalls = calls+0.10*calls;
  Set dataRes = info<<SetOfReal(lapse, allCalls, perMed2, perAvg2);
 

  Set dos = SetOfSet(
  Set randomModelSet = GenRandomModelBLR
  (
    numOut, 
    minNumData, 
    minNumInput, 
    calls, 
    effectSet
  );
  Matrix mhRes        = randomModelSet[1];
  Real lapse          = randomModelSet[2];
  Set inputDefinition = randomModelSet[3]; 
  Set sigmaDefinition = randomModelSet[4]; 
  Set allParameters   = randomModelSet[5]; 
  Set info            = randomModelSet[6]; 

  Set names     = Traspose(inputDefinition)[1]<<Traspose(sigmaDefinition)[1] ;
  Set result    = MHResult(Tra(mhRes), names, inputDefinition); 
  Set compRes = For(1, Card(result), Set(Real k)
  {
    Set reg = result[k];
    Text name = reg->Name;
    Real med = reg->Median;
    Real avg = reg->Average;
    Real val = allParameters[k];
    Real perMed = (val-med)/val;
    Real perAvg = (val-avg)/val;
    SetOfAnything(name, med, avg, val, perMed, perAvg)
  });
  Real perMed2 = SetAvr(EvalSet(Traspose(compRes)[5], Real(Real err){err^2}));
  Real perAvg2 = SetAvr(EvalSet(Traspose(compRes)[6], Real(Real err){err^2}));
  Real allCalls = calls+0.10*calls;
  Set dataRes = info<<SetOfReal(lapse, allCalls, perMed2, perAvg2);
  SetOfSet(compRes, dataRes))
  
   SetOfSet(SetOfSet(compRes, dataRes), dos[Card(dos)])
};
//////////////////////////////////////////////////////////////////////////////
// PROCEDURES
//////////////////////////////////////////////////////////////////////////////

Real NumExper = 10;
Text header = 
"numOut; numData; numInput; numPar; lapse; allCalls; perMed2; perAvg2";
Text If(FileExist("blr2_test.bmt"), "", WriteFile("blr2_test.bmt", ""));

/*
Set dataRes = For(1, NumExper, Text(Real k)
{
  Real numOut      = Round(Rand(1, 1)); 
  Real minNumData  = Round(Rand(500, 1000));
  Real minNumInput = Round(Rand(30, 300));
  Real numCalls    = Round(Rand(5, 10));
  
  Set checkBLR = CheckBLR 
  (
    numOut, 
    minNumData, 
    minNumInput, 
    numCalls, 
    EffectSet
  );
  Text WriteLn("Iteracion "+IntText(k)+":"<<checkBLR[2]);
  Text line = 
  Replace(Replace(Replace(""<<checkBLR[2], "[[  ", ""), "]]",""), ",", ";")+";"+NL;
  Text AppendFile("blr2_test.bmt", line)
});
*/
/*
  Real numOut      = Round(Rand(1, 1)); 
  Real minNumData  = Round(Rand(50, 100));
  Real minNumInput = Round(Rand(3, 30));
  Real numCalls    = Round(Rand(50, 100));
  
  Set checkBLR = CheckBLR 
  (
    numOut, 
    minNumData, 
    minNumInput, 
    numCalls, 	
    EffectSet
  );
*/

/*
Set aMat = Include("blr2_test.bmt");
Matrix data = aMat[1];
Matrix y = SubCol(data, SetOfReal(5));
Matrix numInp = SubCol(data, SetOfReal(3));
Matrix numCalls = SubCol(data, SetOfReal(6));
Matrix numData = SubCol(data, SetOfReal(2));
Matrix x = WeightProd(numCalls, numData)
  |WeightProd(numCalls, WeightProd(numInp, numInp));
//     |SetCol(NCopy(Rows(y),1));

Set res = LinReg(y, x);
Matrix frq = FreqRel(res[1], 100, 0,0);
Matrix adj = y-res[1];
Matrix view = y|adj;
*/

/*


*/
