//////////////////////////////////////////////////////////////////////////////
// FILE    : _multiTryMetropolis.tol
// PURPOSE : Implementation of multi-try Metropolis related methods
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Class @MultiTryMetropolis
//Default behaviour is a normal random walk:
// * candidate generator is simmetric standard multinormal
//      Q(x,y) ~ Normal(x, s^2*COV)
// * If COV is an aproximation of target covariance matrix then method will
//   be more efficient
// * Number s is called dispersion factor and must be tunned to have a good
//   acceptance ratio
// * methodsprodLinvVector, Q_logDens and logLambda are defined to serve as 
//   examples to be inherited, but they will not be evaluated in basic class
//////////////////////////////////////////////////////////////////////////////
{
  //Current number of tries by iteration
  Real _.k = 0;
  //Minimum number of tries by iteration
  Real _.kMin = 2;
  //Maximum number of tries by iteration
  Real _.kMax = 100;
  //Don't use multiple try (force _.k = 1)
  Real useOnlySingleTry = False;
  //True if current drawn is accepted
  Real _.accept = ?;
  //Current rejection limit
  Real _.rejectLimit = ?;
  //Current dispersion factor of random walk
  Real _.s = 1;
  //Minimum number of tries by iteration
  Real _.sMin = 1.E-3;
  //Maximum number of tries by iteration
  Real _.sMax = 1.E+3;
  //Modification coefficient of _.s along tunning process
  Real _.sFactor = 1.01;
  //Current acceptance ratio
  Real _.acceptRatio = ?;
  //Desired acceptance ratio
  Real _.acceptRatioTarget = ?;
  Real _.simetricQ = True;
  Real _.maxDomainSearchIter = 100;
  Real _.num_draw = 0;
  Real _.num_Q_draw = 0;
  Real _.num_accept = 0;
  Real _.num_logWeight = 0;

  ////////////////////////////////////////////////////////////////////////////
  //Data access are virtual member to avoid overhead and excessive copying
  ////////////////////////////////////////////////////////////////////////////
  //Number of variables to be simulated
  Real get.n(Real void);
  //Returns current drawn values
  VMatrix get.x(Real void);
  //Sets current drawn values
  Real set.x(VMatrix x);

  ////////////////////////////////////////////////////////////////////////////
  Real setDefault(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real n = get.n(0);
    Real _.acceptRatioTarget := 0.234  + (0.5-0.234)*Exp(1-n);
    Real _.k := Max(_.kMin, Min(_.kMax, Ceil(Sqrt(n))));
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  //If L is Cholesky decomposition of Covariance matrix (COV = L * L') then
  //this function returns L * vector
  VMatrix prodLVector (VMatrix vector)
  ////////////////////////////////////////////////////////////////////////////
  { vector };

  ////////////////////////////////////////////////////////////////////////////
  //If L is Cholesky decomposition of Covariance matrix (COV = L * L') then
  //this function returns L^-1 * vector
  VMatrix prodLinvVector (VMatrix vector)
  ////////////////////////////////////////////////////////////////////////////
  { vector };

  ////////////////////////////////////////////////////////////////////////////
  //candidate drawer
  VMatrix Q_draw(VMatrix z) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    VMatrix e = Gaussian(get.n(0),1,0,_.s);
    z + prodLVector(e) 
  };

  ////////////////////////////////////////////////////////////////////////////
  //Log-density of candidate generator
  Real Q_logDens(VMatrix u, VMatrix v) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    VMatrix e = prodLinvVector((v-u)/_.s);
    -0.5*VMatDat(MtMSqr(e),1,1)
  };

  ////////////////////////////////////////////////////////////////////////////
  //Target log-density
  Real pi_logDens(VMatrix z);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  //Symmetric log factor
  Real logLambda(VMatrix u, VMatrix v) 
  ////////////////////////////////////////////////////////////////////////////
  { -Q_logDens(u,v) };

  ////////////////////////////////////////////////////////////////////////////
  //Log-Weight function
  Real logWeight(VMatrix u, VMatrix v) 
  ////////////////////////////////////////////////////////////////////////////
  { pi_logDens(u) };

  ////////////////////////////////////////////////////////////////////////////
  //Will be called after each accepted or rejected simulation
  Real doAfterDraw(Real void)
  ////////////////////////////////////////////////////////////////////////////
  { True };

  ////////////////////////////////////////////////////////////////////////////
  //Accepts or rejects using current rejection limit and tries to tunne 
  //parameters to get a good acceptance ratio
  Real acceptRejectTunner(VMatrix y)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.accept := GE(_.rejectLimit,Rand(0,1));
    Real If(_.accept, 
    {
      Real set.x(y);
      Real _.num_accept := _.num_accept +1
    });
    Real _.acceptRatio := _.num_accept / _.num_draw; 
    Real If(useOnlySingleTry, Case(
    _.k>1, { False },
    _.acceptRatio<_.acceptRatioTarget/1.01,
    {
      If(_.s>_.sMin, _.s := _.s/_.sFactor)
    },
    _.acceptRatio>_.acceptRatioTarget*1.01,
    {
      If(_.s<_.sMax, _.s := _.s*_.sFactor)
    }),
    Case(
    _.acceptRatio<0.50,
    {
      If(_.k<_.kMax, _.k := _.k+1);
      If(_.s>_.sMin, _.s := _.s/_.sFactor)
    },
    _.acceptRatio>0.75,
    {
      If(_.k>_.kMin, _.k := _.k-1);
      If(_.s<_.sMax, _.s := _.s*_.sFactor)
    }));
    Real doAfterDraw(0);
    _.accept
  };

  ////////////////////////////////////////////////////////////////////////////
  //Draws a simulation with single try (standard Metropolis-Hastings)
  //When _.k = 1 is equivalent and faster than drawMultipleTry
  VMatrix drawSingleTry(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.num_draw := _.num_draw + 1;
    Real _.num_Q_draw := _.num_Q_draw +1;
    VMatrix x = get.x(0);
    VMatrix y = Q_draw(x);
    Real pi_logDens_y = pi_logDens(y);
    Real pi_logDens_x = pi_logDens(x);
    Real _.rejectLimit := Min(1,Exp(logWeight(y,x)-logWeight(x,y)));
    Real acceptRejectTunner(y);
    get.x(0)
  };

  ////////////////////////////////////////////////////////////////////////////
  //Draws a simulation by multiple try Metropolis method
  VMatrix drawMultipleTry(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.k==1, drawSingleTry(void), {
    VMatrix x = get.x(0);
    VMatrix y = x;
  //WriteLn("TRACE draw x=\n"<<Matrix Tra(VMat2Mat(x)));
    VMatrix lwYjx = Rand(0,0,0,0);
    VMatrix gYjx = Rand(0,0,0,0);
    Real lwYjx_max = ?;
    Real gYjx_sum  = ?;
    VMatrix lwXjy = Rand(0,0,0,0);
    Real lwXjy_max = ?;
    Real gXjy_sum = ?;
    Real _.num_draw := _.num_draw + 1;
    VMatrix J = DifEq(1/(1-B),Constant(_.k,1,1)); 
    Set Y = For(1,_.k, VMatrix Y_Q_draw(Real j) { Q_draw(x) });
 
    Real calc_numerator_Yjx(Real void)
    {
      VMatrix lwYjx := Mat2VMat(SetCol(For(1,_.k, Real(Real j)
      {
        Real _.num_logWeight := _.num_logWeight+1;
        logWeight(Y[j],x)
      })));
    //WriteLn("TRACE draw lwYjx=\n"<<Matrix Tra(VMat2Mat(lwYjx)));
      Real lwYjx_max := VMatMax(lwYjx);
    //WriteLn("TRACE draw lwYjx_max=\n"<<lwYjx_max);
      VMatrix gYjx := Exp(lwYjx-lwYjx_max);
    //WriteLn("TRACE draw gYjx=\n"<<Matrix Tra(VMat2Mat(gYjx)));
      Real gYjx_sum := VMatSum(gYjx);
    //WriteLn("TRACE draw gYjx_sum=\n"<<gYjx_sum);
      True
    };
    VMatrix draw_y(Real void)
    {
      Matrix fYjx = VMat2Mat(gYjx / gYjx_sum);
    //WriteLn("TRACE draw fYjx=\n"<<Matrix Tra(fYjx));
      Matrix perm = Sort(VMat2Mat(lwYjx),[[1]]);
    //WriteLn("TRACE draw perm=\n"<<Matrix Tra(perm));
      Matrix fxYp = PivotByRows(fYjx,perm);
    //WriteLn("TRACE draw fxYp=\n"<<Matrix Tra(fxYp));
      Matrix FxYp = DifEq(1/(1-B),fxYp);
    //WriteLn("TRACE draw FxYp=\n"<<Matrix Tra(FxYp));
      Real u = Rand(0,1);
      Matrix FLTu = LT(FxYp,Constant(_.k,1,u));
    //WriteLn("TRACE draw FLTu=\n"<<Matrix Tra(FLTu));
      Real sFLTu = MatSum(FLTu);
      Real h = Min(_.k,1+sFLTu);
      Real j = MatDat(perm,h,1);
    //WriteLn("TRACE draw u="<<u+" sFLTu="<<sFLTu+" h="<<h+" j="<<j);
      Y[j]
    };
    Real calc_numerator_Yjx(0);
    Real _.rejectLimit := If(!gYjx_sum, 0,
    {
      VMatrix y := If(_.k==1,Y[1],draw_y(0));
    //WriteLn("TRACE draw pi_matchesDomain(y)="<<pi_matchesDomain(y));
      Set X = For(1,_.k-1, VMatrix X_Q_draw(Real j) { Q_draw(y) }) << [[x]];
      Real _.num_Q_draw := _.num_Q_draw + 2*_.k-1;
      Real calc_denominator_Xjy(Real void)
      {
        VMatrix lwXjy := Mat2VMat(SetCol(For(1,_.k, Real(Real j)
        {
          Real _.num_logWeight := _.num_logWeight+1;
          logWeight(X[j],y)
        })));
      //WriteLn("TRACE draw lwXjy=\n"<<Matrix Tra(VMat2Mat(lwXjy)));
        Real lwXjy_max := VMatMax(lwXjy);
      //WriteLn("TRACE draw lwXjy_max=\n"<<lwXjy_max);
        VMatrix gXjy = Exp(lwXjy-lwXjy_max);
        Real gXjy_sum := VMatSum(gXjy);
      //WriteLn("TRACE draw gXjy_sum=\n"<<gXjy_sum);
        True
      };
      Real calc_denominator_Xjy(0);
      Min(1,Exp(lwYjx_max-lwXjy_max)*(gYjx_sum/gXjy_sum))
    });
  //WriteLn("TRACE draw _.rejectLimit=\n"<<_.rejectLimit);
    Real acceptRejectTunner(y);
    get.x(0)
  }) }
};


//////////////////////////////////////////////////////////////////////////////
Class @MultiTryMetropolis_ARIMA : @MultiTryMetropolis
//Implementation of multiple try Metropolis to an ARIMA model.
//Initial values of ARIMA difference equation are treated as a complementary 
//Gibbs block that will be simulated after each simulation or ARMA parameters
//////////////////////////////////////////////////////////////////////////////
{
  //ARIMA noise
  VMatrix _.z;
  //ARMA parameters
  VMatrix _.x;
  //Nuber of ARMA parameters
  Real _.n;
  //Standard deviation 
  Real _.sigma;
  //Set of ARIMAStruct elements
  Set _.arima = Copy(Empty);
  //Aggregated autoregressive polynomial
  Polyn  _.ar = 1;
  //Aggregated moving-average polynomial
  Polyn  _.ma = 1;
  //Internal representation of ARMA parameters used in conversions
  Set _.arma = Copy(Empty);
  //Internal ARIMA evaluation handler
  NameBlock _.almagro = [[ Real void=? ]];
  //Initial values of ARIMA difference equation
  VMatrix _.u0 = Rand(0,0,0,0);
  VMatrix _.z0 = Rand(0,0,0,0);
  VMatrix _.a0 = Rand(0,0,0,0);
  
  ////////////////////////////////////////////////////////////////////////////
  //Converts a Set of ARIMAStruct elements in a column vector
  VMatrix arima2col(Set arima)
  ////////////////////////////////////////////////////////////////////////////
  {
  //Mat2VMat(SetCol(ARIMAToParam(arima)))
    Set arma = EvalSet(arima, Set(ARIMAStruct f)
    {
      SetOfPolyn(1-f->AR, 1-f->MA)
    });
    Mat2VMat(Tra(GetNumeric(arma)))
  };
  
  ////////////////////////////////////////////////////////////////////////////
  //Converts a column vector in a Set of ARIMAStruct elements with the same
  //structure than initial definition of member _.arima
  Set col2arima(VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
//  ParamToARIMA(_.arima, MatSet(Tra(VMat2Mat(x)))[1])
    Set arma = DeepCopy(_.arma, VMat2Mat(x));
    Set arima =  DeepCopy(_.arima); 
    Set For(1,Card(_.arima), Real(Real k)
    {
      Polyn arima[k]->AR := 1-arma[k][1];
      Polyn arima[k]->MA := 1-arma[k][2];
      True
    });
    arima
  };

  ////////////////////////////////////////////////////////////////////////////
  //Draws Gibbs block of ARMA initial values
  Real drawArmaInitValues(Real recalcHandler)
  ////////////////////////////////////////////////////////////////////////////
  {
    //Evaluation handler must be recalculated just when parameters has changed
    Real If(recalcHandler,
    {
      Polyn  _.ar := ARIMAGetAR(_.arima);
      Polyn  _.ma := ARIMAGetMA(_.arima);
      NameBlock _.almagro := ARMAProcess::Eval.Almagro(_.ar,_.ma,_.z,_.sigma);
      True
    });
    VMatrix _.u0 := _.almagro::Draw.U_cond_Z(0);
    VMatrix _.z0 := _.almagro::Get.Z0(_.u0);
    VMatrix _.a0 := _.almagro::Get.A0(_.u0);
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  //Initialize all members to be congruent with a given ARIMA model
  Real initialize(Set arima)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set _.arima := DeepCopy(arima);
    Set _.arma := EvalSet(_.arima, Set(ARIMAStruct f)
    {
      SetOfPolyn(1-f->AR, 1-f->MA)
    });
    VMatrix _.x := arima2col(_.arima);
    Real ok = drawArmaInitValues(Real _.accept := True);
    Real _.n := VRows(_.x);
    //This is the theorical acceptance ratio for single-try
    Real setDefault(0);
    ok
  };
  
  ////////////////////////////////////////////////////////////////////////////
  //Creates a new instance
  Static @MultiTryMetropolis_ARIMA New(
     VMatrix z, 
     Real sigma, 
     Set arima)
  ////////////////////////////////////////////////////////////////////////////
  {
    @MultiTryMetropolis_ARIMA new = 
    [[
      VMatrix _.z = z;
      Real _.sigma = sigma
    ]];
    Real new::initialize(arima);
    new
  };
  
  ////////////////////////////////////////////////////////////////////////////
  //MEMEBERS AND METHODS INHERITED FROM @MultiTryMetropolis
  ////////////////////////////////////////////////////////////////////////////

  //Number of variables to be simulated
  Real get.n(Real void) { Copy(_.n) };
  //Returns current drawn values
  VMatrix get.x(Real void) { Copy(_.x) };
  //Sets current drawn values
  Real set.x(VMatrix x) { VMatrix _.x := Copy(x); True };

  ////////////////////////////////////////////////////////////////////////////
  //After each simulation does conversion to ARIMA if needed, and draws the 
  //Gibbs block of ARMA initial values
  Real doAfterDraw(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set If(_.accept, _.arima := col2arima(_.x));
    Real drawArmaInitValues(_.accept)
  };

  ////////////////////////////////////////////////////////////////////////////
  //If L is Cholesky decomposition of Covariance matrix (COV = L * L') then
  //this function returns L * vector
  VMatrix _.L = Rand(0,0,0,0);
  VMatrix prodLVector (VMatrix vector)
  ////////////////////////////////////////////////////////////////////////////
  { _.L*vector };


  ////////////////////////////////////////////////////////////////////////////
  //Internal representation of target log-density of an ARIMA model
  Real pi_logDens_(Set arima)
  ////////////////////////////////////////////////////////////////////////////
  {
    Polyn ar = ARIMAGetAR(arima);
    Polyn ma = ARIMAGetMA(arima);
    If(Or(!IsStationary(ar), !IsStationary(ma)), -TheMaxAbsValue,
      _.almagro::LogLH.Z_cond_U(ar,ma,_.z0,_.a0) )
  };
  
  ////////////////////////////////////////////////////////////////////////////
  //target log-density (black-box)
  Real pi_logDens(VMatrix z)
  ////////////////////////////////////////////////////////////////////////////
  {
    pi_logDens_(col2arima(z))
  }

};

