////////////////////////////////////////////////////////////////////////////////
// FILE: _rcoda.tol
// PURPOSE: TOL API for R package CODA
////////////////////////////////////////////////////////////////////////////////

NameBlock RCODA =
[[
  //Acknowledgements
  Text _R_citation(Real void) {
  "R Development Core Team (2007). R: A language and environment for "
  "statistical computing. R Foundation for Statistical Computing, "
  "Vienna, Austria. ISBN 3-900051-07-0, \n"
  "URL http://www.R-project.org.\n"};
  Text _coda_citation(Real void) {
  "Martyn Plummer, Nicky Best, Kate Cowles and Karen Vines (2006). coda:"
  "Output analysis and diagnostics for MCMC. R package version 0.10-7.\n"
  "URL http://www-fis.iarc.fr/coda/\n"};
  Text _article_citation(Real void) {
  "@ARTICLE{Rnews:Plummer+Best+Cowles+Vines:2006,\n"
  "  AUTHOR = {Martyn Plummer and Nicky Best and Kate Cowles and Karen Vines},\n"
  "  TITLE = {{CODA}: Convergence Diagnosis and Output Analysis for {MCMC}},\n"
  "  JOURNAL = {R News},\n"
  "  YEAR = 2006,\n"
  "  VOLUME = 6,\n"
  "  NUMBER = 1,\n"
  "  PAGES = {7--11},\n"
  "  MONTH = {March},\n"
  "  URL = {http://CRAN.R-project.org/doc/Rnews/},\n"
  "  PDF = {http://CRAN.R-project.org/doc/Rnews/Rnews_2006-1.pdf}\n"
  "}\n"};
  //read only autodoc
  Text _.autodoc.description =
  "TOL API for R package CODA\n"+
  "External requirements:\n"
  " 1. Installing R and ensure that is added to system path environment\n"
  " 2. Installing R CODA package\n"
  "Acknowledgements:\n"+
     _R_citation(0)+"\n"+
     _coda_citation(0)+"\n"+
     _article_citation(0);
  Set _.autodoc.authors = [[
  "josp@tol-project.org",
  "vdebuen@tol-project.org"]];
  
  Text _cwd = GetAbsolutePath(".");
  Text _tmpdir = Replace(TmpDir, "\\", "/");
  Text _tolcoda.R = _cwd+"/"+ "_tolcoda.R";
  Text _tmp.mcmc.bbm = _tmpdir+"/"+"mcmc%S.bbm";
  Text _tmp.raftery.bbm = _tmpdir+"/"+"raftery%S.bbm";
  Text _tmp.gelman.bbm = _tmpdir+"/"+"gelman%S.bbm";
  Text _tmp.varstat.bbm = _tmpdir+"/"+"varstat%S.bbm";
  Text _tmp.varquant.bbm = _tmpdir+"/"+"varquant%S.bbm";

  //////////////////////////////////////////////////////////////////////////////
  Set _mat.in(Anything sample)
  //If sample is a text then return it as the path
  //If sample is a Matrix then return a pair [[ _tmp.mcmc.bbm, sample ]] which
  //   will be used by Rapi to generate a temporary matrix in bbm format
  //////////////////////////////////////////////////////////////////////////////
  {
    Text type = Grammar(sample);
    Case
    (
      type=="Text", 
      {
        Set [[ Text sample ]]
      }, 
      type=="Matrix", 
      {
        Set [[ [[ _tmp.mcmc.bbm, sample ]] ]]
      }, 
      type=="Set", 
      {
        For(1,Card(sample),Anything(Real k)
        {
          Text type.k = Grammar(sample[k]);
          Case
          (
            type.k=="Text", 
            {
              Text sample[k]
            }, 
            type.k=="Matrix", 
            {
              Set [[ _tmp.mcmc.bbm+"_"+IntText(k), sample[k] ]]
            }, 
            1==1,
            {
              WriteLn("[RCODA::_mat.in] Invalid object type for sample argument, "
                      "must be Text (path to the bbm matrix), Matrix or Set of matrices","E");
              Real Stop;
              ""
            }
          )
        })
      }, 
      1==1,
      {
        WriteLn("[RCODA::_mat.in] Invalid object type for sample argument, "
                "must be Text (path to the bbm matrix), Matrix or Set of matrices","E");
        Real Stop;
        ""
      }
    )
  };

  //////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.raftery.diag = 
  "Function RCODA::raftery.diag is a TOL port to R function "
  "raftery.diag {coda} \n"
  "\n"
  "URL: http://cran.r-project.org/doc/packages/coda.pdf\n"
  "\n"          
  "Description\n"
  "raftery.diag is a run length control diagnostic based on a criterion of "
  "accuracy of estimation of the quantile q. It is intended for use on a short "
  "pilot run of a Markov chain. The number of iterations required to estimate "
  "the quantile q to within an accuracy of +/- r with probability p is "
  "calculated. Separate calculations are performed for each variable within "
  "each chain.\n"
  "If the number of iterations in data is too small, an error message is "
  "printed indicating the minimum length of pilot run. The minimum length is "
  "the required sample size for a chain with no correlation between "
  "consecutive samples. Positive autocorrelation will increase the required "
  "sample size above this minimum value. An estimate I (the `dependence "
  "factor') of the extent to which autocorrelation inflates the required "
  "sample size is also provided. Values of I larger than 5 indicate strong "
  "autocorrelation which may be due to a poor choice of starting value, high "
  "posterior correlations or `stickiness' of the MCMC algorithm.\n"
  "The number of `burn in' iterations to be discarded at the beginning of the "
  "chain is also calculated.\n"  
  "\n"          
  "Usage examples\n"
  "\n"
  "  Matrix RCODA::raftery.diag(data, {[[\n"
  "    Real verbose=FALSE, \n"
  "    Real varByCol=TRUE, \n"
  "    Real q=0.030, \n"
  "    Real r=0.006, \n"
  "    Real s=0.99, \n"
  "    Real eps=0.001]]})\n"
  "\n"
  "  Matrix RCODA::raftery.diag(data, {[[\n"
  "    Real varByCol=FALSE, \n"
  "    Real eps=0.0003]]})\n"
  "\n"
  "  Matrix RCODA::raftery.diag(data,Empty)\n"
  "\n"
  "Arguments\n"
  "  data: an mcmc object that could be a Matrix variable or a Text one with "
          "the path to a BBM file\n"
  "  optArgs: supplies optional arguments:\n" 
  "    Real verbose: If TRUE some traces will be send to standard output"
  "    Real varByCol: If TRUE then each column contains the Markov Chain of a "
                     "variable and each row has a simulation. In other case "
                     "each row is a variable and each column is a simulation"
                     "Default value is TRUE\n"
  "    Real q: the quantile to be estimated. Default value is 0.025\n"
  "    Real r: the desired margin of error of the estimate.Default value is "
              "0.005\n"
  "    Real s: the probability of obtaining an estimate in the interval "
              "(q-r,q+r). Default value is 0.95\n"
  "    Real eps: Precision required for estimate of time to convergence."
                "Default value is 0.001\n"
  "\n"          
  "Returns a matrix containing in each row the next information about each "
  "variable: \n"
  "  M the length of burn in, \n"
  "  N the required sample size, \n"
  "  Nmin the minimum sample size based on zero autocorrelation, \n"
  "  I = (M+N)/Nmin the dependence factor\n"
  "\n"
  "Acknowledgements:\n"+ _coda_citation(0);
  Matrix raftery.diag(Anything data, Set optArgs)
  //////////////////////////////////////////////////////////////////////////////
  {
    Real verbose  = getOptArg(optArgs,"verbose",  FALSE);
    Real varByCol = getOptArg(optArgs,"varByCol", TRUE);
    Real q        = getOptArg(optArgs,"q",        0.025);
    Real r        = getOptArg(optArgs,"r",        0.005);
    Real s        = getOptArg(optArgs,"s",        0.950);
    Real eps      = getOptArg(optArgs,"eps",      0.001);

    Set args.bbm = _mat.in(data);
    Set result.names = [[ _tmp.raftery.bbm ]];
    
    Text script = 
      "source('"+_tolcoda.R+"'); raftery.bbm('"+args.bbm[1][1]+"','"
      +_tmp.raftery.bbm+"',"
      <<FormatReal(verbose,"%.0lg")+","
      <<FormatReal(varByCol,"%.0lg")+","
      <<FormatReal(q,"%.15lg")+","
      <<FormatReal(r,"%.15lg")+","
      <<FormatReal(s,"%.15lg")+","
      <<FormatReal(eps,"%.15lg")
      <<")";
    Set rrs = Rapi::RunRScript(script, args.bbm, "",result.names,verbose);
    If(Card(rrs), rrs[1],
    {
      WriteLn("[raftery.diag] Cannot run R script");
      Rand(0,0,0,0)
    })
  };
  
  //////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.gelman.diag = 
  "Function RCODA::gelman.diag is a TOL port to R function "
  "gelman.diag {coda} \n"
  "\n"
  "URL: http://cran.r-project.org/doc/packages/coda.pdf\n"
  "\n"          
  "Description\n"
  "The ‘potential scale reduction factor’ is calculated for each variable in "
  "x, together with upper and lower confidence limits. Approximate convergence "
  "is diagnosed when the upper limit is close to 1. For multivariate chains, "
  "a multivariate value is calculated that bounds above the potential scale "
  "reduction factor for any linear combination of the (possibly transformed) "
  "variables.\n"
  "The confidence limits are based on the assumption that the stationary "
  "distribution of the variable under examination is normal. Hence the "
  "‘transform’ parameter may be used to improve the normal approximation.\n"  
  "\n"          
  "Usage examples\n"
  "\n"
  "  Matrix RCODA::gelman.diag(data, {[[\n"
  "    Real verbose=FALSE, \n"
  "    Real varByCol=TRUE, \n"
  "    Real confidence=0.95, \n"
  "    Real transform=FALSE, \n"
  "    Real autoburnin=TRUE]]})\n"
  "\n"
  "  Matrix RCODA::gelman.diag(data, {[[\n"
  "    Real varByCol=FALSE, \n"
  "    Real confidence=0.95]]})\n"
  "\n"
  "  Matrix RCODA::gelman.diag(data,Empty)\n"
  "\n"
  "Arguments\n"
  "  data: an mcmc object that could be a Set variable wich two or more "
          "elements are Matrix or a Text one with the path to a BBM file\n"
  "  optArgs: supplies optional arguments:\n" 
  "    Real verbose: If TRUE some traces will be send to standard output"
  "    Real varByCol: If TRUE then each column contains the Markov Chain of a "
                     "variable and each row has a simulation. In other case "
                     "each row is a variable and each column is a simulation"
                     "Default value is TRUE\n"
  "    Real confidence: the coverage probability of the confidence interval "
                        "for the potential scale reduction factor\n"
  "    Real transform: a logical flag indicating whether variables in x "
                      "should be transformed to improve the normality of "
                      "the distribution. If set to TRUE, a log transform or "
                      "logit transform, as appropriate, will be applied.\n"
  "    Real autoburnin: a logical flag indicating whether only the second half "
                       "of the series should be used in the computation. If set "
                       "to TRUE (default) and start(x) is less than end(x)/2 "
                       "then start of series will be adjusted so that only "
                       "second half of series is used.\n"
  "\n"          
  "Returns ? (Uncompleted)"
  "\n"
  "Acknowledgements:\n"+ _coda_citation(0);
  Set gelman.diag(Set data, Set optArgs)
  //////////////////////////////////////////////////////////////////////////////
  {
    Real verbose    = getOptArg(optArgs,"verbose",    FALSE);
    Real varByCol   = getOptArg(optArgs,"varByCol",   TRUE);
    Real confidence = getOptArg(optArgs,"confidence", 0.95);
    Real transform  = getOptArg(optArgs,"transform",  FALSE);
    Real autoburnin = getOptArg(optArgs,"autoburnin", TRUE);

    Set args.bbm = _mat.in(data);
    Set result.names = [[ _tmp.gelman.bbm+"_psrf",
                          _tmp.gelman.bbm+"_mpsrf" ]];
    Text args.bbm.list = "c("+SetSum(For(1,Card(args.bbm),Text(Real k)
    {
      If(k>1,", ","") + "'"+args.bbm[k][1]+"'"
    }))+")";
    Text script = 
      "source('"+_tolcoda.R+"'); gelman.bbm("+args.bbm.list+",'"
      +_tmp.gelman.bbm+"',"
      <<FormatReal(verbose,     "%.0lg")+","
      <<FormatReal(varByCol,    "%.0lg")+","
      <<FormatReal(confidence,  "%.15lg")+","
      <<FormatReal(transform,   "%.0lg")+","
      <<FormatReal(autoburnin,  "%.0lg")
      <<")";
    Set rrs = Rapi::RunRScript(script, args.bbm, "",
                     result.names,
                     verbose);
    If(Card(rrs), 
    {[[
      Matrix psrf=rrs[1]; 
      Real mpsrf = MatDat(rrs[2],1,1)
    ]]},
    {
      WriteLn("[gelman.diag] Cannot run R script");
      Copy(Empty)
    })
  };
    
  Set _def.quantiles = [[0.025, 0.25, 0.5, 0.75, 0.975]];
  //////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.summary = 
  "Function RCODA::summary is a TOL port to R function "
  "summary sometimes called summary.mcmc {coda} \n"
  "\n"
  "URL: http://cran.r-project.org/doc/packages/coda.pdf\n"
  "\n"          
  "Description\n"
  "summary.mcmc produces two sets of summary statistics for each variable: "
  "varstats: Mean, standard deviation, naive standard error of the mean (ignoring "
  "autocorrelation of the chain) and time-series standard error based on an "
  "estimate of the spectral density at 0. \n"
  "varquant: Quantiles of the sample distribution using the quantiles argument"
  ".\n"  
  "\n"          
  "Usage examples\n"
  "\n"
  "  Set RCODA::summary(data, {[[\n"
  "    Real verbose=FALSE, \n"
  "    Real varByCol=TRUE, \n"
  "    Set quantiles=[[0.02,0.04,0.06,0.08] ]]})\n"
  "\n"
  "  Matrix RCODA::summary(data,Empty)\n"
  "\n"
  "Arguments\n"
  "  data: an mcmc object that could be a Matrix variable or a Text one with "
          "the path to a BBM file\n"
  "  optArgs: supplies optional arguments as these:\n" 
  "    Real verbose: If TRUE some traces will be send to standard output"
  "    Real varByCol: If TRUE then each column contains the Markov Chain of a "
                     "variable and each row has a simulation. In other case "
                     "each row is a variable and each column is a simulation"
                     "Default value is TRUE\n"
  "    Set quantiles: a vector of quantiles to evaluate for each variable is "
                     "[[0.025, 0.25, 0.5, 0.75, 0.975]]\n"
  "\n"          
  "Returns a set with two matrices containing in each row the information "
  "about each variable \n"
  "\n"
  "Acknowledgements:\n"+ _coda_citation(0);
  Set summary(Anything data, Set optArgs)
  //////////////////////////////////////////////////////////////////////////////
  {
    Real verbose   = getOptArg(optArgs,"verbose",   FALSE);
    Real varByCol  = getOptArg(optArgs,"varByCol",  TRUE);
    Set  quantiles = getOptArg(optArgs,"quantiles", _def.quantiles);
    Text qTxt = "c("+SetSum(For(1,Card(quantiles),Text(Real k)
    {
      If(k>1,",","")+
      FormatReal(quantiles[k],"%.15lg")
    }))+")";

    Set args.bbm = _mat.in(data);
    Set result.names = [[ _tmp.varstat.bbm, _tmp.varquant.bbm ]];
    
     Text script = 
       "source('"+_tolcoda.R+"'); summary.mcmc.bbm('"+args.bbm[1][1]+"','"
       +_tmp.varstat.bbm+"','"+_tmp.varquant.bbm+"',"
       <<FormatReal(verbose,"%.0lg")+","
       <<FormatReal(varByCol,"%.0lg")+","
       <<qTxt
       <<")";
    Set rrs= Rapi::RunRScript(script, args.bbm, "", result.names, verbose);
    If(Card(rrs), 
    {
      rrs
    },
    {
      WriteLn("[summary] Cannot run R script");
      Copy(Empty)
    })

  }

]];
