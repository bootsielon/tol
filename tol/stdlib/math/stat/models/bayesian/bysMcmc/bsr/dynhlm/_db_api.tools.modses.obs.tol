//////////////////////////////////////////////////////////////////////////////
// FILE    : _db_api.tools.obs.tol
// PURPOSE : Implements database tools related methods of NameBlock 
//           BysMcmc::Bsr::DynHlm::DBApi
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//Inserts a new observational output register
Real ModSes.Obs.Output.Create(Text dbName, 
                              Text model, 
                              Text session,
                              Text node, 
                              Text serie, 
                              Real mis_pri_sig_fac,
                              Real mis_pri_min,
                              Real mis_pri_max,
                              Date start,
                              Date end,
                              Real sigma)
//////////////////////////////////////////////////////////////////////////////
{
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  Real ok = BysMcmc::Bsr::DynHlm::DBApi::SqlCachedInsert(
  dbName+"."+_table::ObsOutput,
  "'"+model+"','"+session+"','"+node+"','"+serie+"',"+
  SqlFormatReal(mis_pri_sig_fac)+","+
  SqlFormatReal(mis_pri_min)+","+
  SqlFormatReal(mis_pri_max)+","+
  SqlFormatDate(start)+","+
  SqlFormatDate(end)+","+
  SqlFormatReal(sigma)+")");
  Eval("ModSes.Obs.Output.Create.ok=ok")
};

//////////////////////////////////////////////////////////////////////////////
//Inserts a new observational input register
Real ModSes.Obs.Input.Create(Text dbName, 
                             Text model, 
                             Text session,
                             Text node, 
                             Text serie, 
                             Text parameter, 
                             Real mis_pri_sig_fac,
                             Real mis_pri_min,
                             Real mis_pri_max)
//////////////////////////////////////////////////////////////////////////////
{
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  Real ok = BysMcmc::Bsr::DynHlm::DBApi::SqlCachedInsert(
  dbName+"."+_table::ObsInput,
  "'"+model+"','"+session+"','"+node+"','"+serie+"','"+parameter+"',"+
  SqlFormatReal(mis_pri_sig_fac)+","+
  SqlFormatReal(mis_pri_min)+","+
  SqlFormatReal(mis_pri_max));
  Eval("ModSes.Obs.Input.Create.ok=ok")
};

//////////////////////////////////////////////////////////////////////////////
//Inserts a new observational input register
Real ModSes.Obs.TransFun.Create(Text dbName, 
                                Text model, 
                                Text session,
                                Text node, 
                                Text transferFun, 
                                Polyn omega, 
                                Polyn delta, 
                                Text serie, 
                                Real mis_pri_sig_fac,
                                Real mis_pri_min,
                                Real mis_pri_max)
//////////////////////////////////////////////////////////////////////////////
{
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  Real ok = BysMcmc::Bsr::DynHlm::DBApi::SqlCachedInsert(
  dbName+"."+_table::ObsTransFun,
  "'"+model+"','"+session+"','"+node+"',"+
  "'"+transferFun+"',"+
  "'"<<omega+"',"+
  "'"<<delta+"',"+
  "'"+serie+"',"+
  SqlFormatReal(mis_pri_sig_fac)+","+
  SqlFormatReal(mis_pri_min)+","+
  SqlFormatReal(mis_pri_max));
  Eval("ModSes.Obs.Input.Create.ok=ok")
};

//////////////////////////////////////////////////////////////////////////////
//Inserts a new latent sigma block register
Real ModSes.Obs.SigBlk.Create(Text dbName, 
                              Text model, 
                              Text session,
                              Text node, 
                              Real sigma)
//////////////////////////////////////////////////////////////////////////////
{
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  Real ok = BysMcmc::Bsr::DynHlm::DBApi::SqlExecTrace(
  "INSERT INTO "+dbName+"."+_table::ObsSigBlk+"\n"+
  "VALUES('"+model+"','"+session+"','"+node+"',"+
  If(IsUnknown(sigma),"NULL",BysMcmc::Bsr::Import::RealTextS(sigma))+")");
  Eval("ModSes.Lat.SigBlk.Create.ok=ok")
};


//////////////////////////////////////////////////////////////////////////////
//Inserts ARIMA structure for a observational node
Real ModSes.Obs.SetArima(Text dbName, 
                          Text model, 
                          Text session,
                          Text node, 
                          Set  arima)
//////////////////////////////////////////////////////////////////////////////
{
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  Real ok = SetMin(For(1,Card(arima),Real insert.arima(Real f)
  {
    Real BysMcmc::Bsr::DynHlm::DBApi::SqlCachedInsert(
    dbName+"."+_table::ObsArimaBlk,
    "'"+model+"','"+session+"','"+node+"',"+
    IntText(f)+","+
    IntText(arima[f]->Periodicity)+","+
    "'"<<arima[f]->AR+"',"+
    "'"<<arima[f]->MA+"',"+
    "'"<<arima[f]->DIF+"'")
  }));
  Eval("ModSes.Obs.SetArima.ok=ok")
};

//////////////////////////////////////////////////////////////////////////////
//Creates an observational node given a NameBlock with this minimum API:
//
//  NameBlock node =
//  [[
//    Text _.id_node;
//    Text _.description;
//    NameBlock _.output =
//    [[
//      Text _.name;
//      Set  _.arima;
//      Real _.mis_pri_sig_fac;
//      Real _.mis_pri_min;
//      Real _.mis_pri_max;
//      Date _.firstDate;
//      Date _.lastDate
//    ]];
//    Set _.input = SetOfNameBlock(
//      NameBlock input.1 = 
//      [[
//        Real _.enabled;
//        //One of these three options to define observations  
//        Serie     _.serie;     //option 1: for time series
//        Matrix    _.data;      //option 2: for vectors
//        NameBlock _.nonLinFlt; //option 3: for linear filters
//
//        Ratio _.transferFunction; //Optional with default value 1/1 only 
//                                  //for time series 
//
//        Real  _.mis_pri_sig_fac;
//        Real  _.mis_pri_min;
//        Real  _.mis_pri_max
//      ]],
//      ...)
//  ]];
//
Real ModSes.Obs.Create(Text dbName, Text model, Text session,
                       NameBlock node)
//////////////////////////////////////////////////////////////////////////////
{
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  Text id_node = node::_.id_node;
  NameBlock out = node::_.output;
  Real ok.1 = ModSes.Node.Create
  (
    dbName, id_model, id_session, id_node, 
    "OBS",
    0,
    k,
    node::_.description
  );
  //WriteLn("TRACE ModSes.Obs.Create ok.1="<<ok.1);
  Real outIsATimeSerie = ObjectExist("Serie",  "out::_.serie");
  Real outIsAVector    = ObjectExist("Matrix", "out::_.vector");

  Real ok.2 = Case(
  outIsATimeSerie,
  {
  //WriteLn("TRACE Time series output "+out::_.name);
    BysMcmc::Bsr::DynHlm::DBApi::ModSes.Obs.Output.Create
    (
      dbName, id_model, id_session, id_node, 
      out::_.name, 
      out::_.mis_pri_sig_fac,
      out::_.mis_pri_min,
      out::_.mis_pri_max,
      out::_.firstDate,
      out::_.lastDate,
      out::_.sigma
    )
  },
  outIsAVector,
  {
  //WriteLn("TRACE Vector output "+out::_.name);
    BysMcmc::Bsr::DynHlm::DBApi::ModSes.Obs.Output.Create
    (
      dbName, id_model, id_session, id_node, 
      out::_.name, 
      out::_.mis_pri_sig_fac,
      out::_.mis_pri_min,
      out::_.mis_pri_max,
      UnknownDate,
      UnknownDate
    )
  },
  1==1,
  {
    WriteLn("[ModSes.Obs.Create] Invalid output "+out::_.name,"E");
    0
  });
  //WriteLn("TRACE ModSes.Obs.Create ok.2="<<ok.2);
  Real ok.3 = BysMcmc::Bsr::DynHlm::DBApi::ModSes.Obs.SetArima(
    dbName, id_model, id_session, id_node, 
    out::_.arima );
  //WriteLn("TRACE ModSes.Obs.Create ok.3="<<ok.3);
  Real ok.4 = If(!Card(node::_.input), 0 ,
  SetMin(For(1,Card(node::_.input), Real create.node(Real j)
  {
    NameBlock inp = (node::_.input)[j];
    Text inpName = Name((node::_.input)[j]);
    Real isNonLinearFilter = 
      If(!ObjectExist("Real","inp::_.isNonLinearFilter"), False,
      inp::_.isNonLinearFilter);
    Real isNonLinearFilterInput = If(!isNonLinearFilter,False,
    {
      If(!FunctionExist("Set","inp::get.linBlkNames"), False,
      Card(inp::get.linBlkNames(0)) > 0)
    });
    Real isNonLinearFilterOutput = And(isNonLinearFilter,!isNonLinearFilterInput);
    Real ok.4.j = Case(Not(inp::_.enabled), 
    {
    //WriteLn("TRACE Disabled input "+inpName);
      1
    }, 
    isNonLinearFilterOutput,
    {
    //WriteLn("TRACE Non linear filter output "+inpName);
      NameBlock nlf = inp;
      Text nlfDesc = "Block for user defined non linear filter of output "+inpName;
      Text id_gibbs_lin_blk = "NonLinearFilterBlk"; 
      Text clean.nlf.param.name(Text param)
      {
        Text aux = Replace(param,id_gibbs_lin_blk+"::"+id_node+"::","");
        WriteLn("Replace('"+aux+"','"+id_gibbs_lin_blk+"::"+id_node+"::','')="+
         aux);
        aux
      };
      Set colNames = EvalSet(nlf::get.colNames(0),clean.nlf.param.name);
      Matrix u = nlf::get.parameter(0);
      Real ok.4.2 = BysMcmc::Bsr::DynHlm::DBApi::SqlCachedInsert(
        _table::NonLinFlt,
        "'"+id_model+"','"+id_session+"','"+
                   id_node+"','"+inpName+"',"+
                   IntText(0)+","+
                   IntText(Card(colNames)));
      Real ok.4.3 = SetSum(For(1,Card(colNames),Real nlf.param(Real k)
      {
      //WriteLn("TRACE Inserting param "+colNames[k]+" <-"<<MatDat(u,k,1));
        BysMcmc::Bsr::DynHlm::DBApi::ModSes.Mix.Param.Create(
          dbName, model, session, id_node, 
          colNames[k], 
          id_gibbs_lin_blk,
          MatDat(u,k,1),-1/0,1/0)
      }));
      And(ok.4.2, ok.4.3) 
    },
    isNonLinearFilterInput,
    {
    //WriteLn("TRACE Non linear filter input "+inpName);
      NameBlock nlf = inp;
      Text nlfDesc = "Block for user defined non linear filter of input "+inpName;
      Text id_gibbs_lin_blk = "NonLinearFilterBlk"; 
      Text clean.nlf.param.name(Text param)
      {
        Text aux = Replace(param,id_gibbs_lin_blk+"::"+id_node+"::","");
        WriteLn("Replace('"+aux+"','"+id_gibbs_lin_blk+"::"+id_node+"::','')="+
         aux);
        aux
      };
      Text clean.lin.param.name(Text param)
      {
        Text aux = Replace(param,"LinearBlk::"+id_node+"::","");
        WriteLn("Replace('"+aux+"','"+id_gibbs_lin_blk+"::"+id_node+"::','')="+
         aux);
        aux
      };
      Set colNames = EvalSet(nlf::get.colNames(0),clean.nlf.param.name);
      Matrix u = nlf::get.parameter(0);
      Set linBlkNames = If(
        FunctionExist("Set","nlf::get.linBlkNames"),
        EvalSet(nlf::get.linBlkNames(0),clean.lin.param.name),
        Copy(Empty));
      Real ok.4.2 = BysMcmc::Bsr::DynHlm::DBApi::SqlCachedInsert(
        _table::NonLinFlt,
        "'"+id_model+"','"+id_session+"','"+
                   id_node+"','"+inpName+"',"+
                   IntText(Card(linBlkNames))+","+
                   IntText(Card(colNames)));
      Real ok.4.3 = SetSum(For(1,Card(colNames),Real nlf.param(Real k)
      {
        BysMcmc::Bsr::DynHlm::DBApi::ModSes.Mix.Param.Create(
          dbName, model, session, id_node, 
          colNames[k], 
          id_gibbs_lin_blk,
          MatDat(u,k,1),-1/0,1/0)
      }));
      Real ok.4.4 = If(!Card(linBlkNames),1,
      SetMin(For(1,Card(linBlkNames),Real nlf.lin(Real k)
      {
        Real ok.4.3.1 = BysMcmc::Bsr::DynHlm::DBApi::ModSes.Mix.Param.Create(
          dbName, model, session, id_node, 
          linBlkNames[k], 
          id_gibbs_lin_blk,
          nlf::get.linBlkIniValue(1),
          nlf::get.linBlkMinValue(1),
          nlf::get.linBlkMaxValue(1) );
        Real ok.4.3.2 = BysMcmc::Bsr::DynHlm::DBApi::ModSes.Obs.Input.Create(
          dbName, id_model, id_session, id_node, 
          linBlkNames[k], 
          nlf::_.inputName,
           1/0,
          -1/0,
           1/0
        );
        And(ok.4.3.1,ok.4.3.2)
      })));
      And(ok.4.2, ok.4.3, ok.4.4) 
    },
    ObjectExist("Serie","inp::_.serie"),
    {
      Ratio tf = If(!ObjectExist("Ratio","inp::_.transferFunction"),1/1,
        inp::_.transferFunction);
      Polyn omega = Numerator  (tf);
      Polyn delta = Denominator(tf);
      Real p = Degree(omega);
      Real q = Degree(delta);
      Real h = Max(p,q);
      Case(h==0, 
      {
      //WriteLn("TRACE Time series input "+inpName);
        Real ok.4.1 = BysMcmc::Bsr::DynHlm::DBApi::ModSes.Mix.Param.Create
        (
          dbName, id_model, id_session, id_node, 
          inpName+"::Coef",
          "LinearBlk",
          inp::_.initValue,
          inp::_.minimum,
          inp::_.maximum
        );
        //WriteLn("TRACE ModSes.Obs.Create ok.4.1="<<ok.4.1);
        Real ok.4.2 = BysMcmc::Bsr::DynHlm::DBApi::ModSes.Obs.Input.Create
        (
          dbName, id_model, id_session, id_node, 
          inpName+"::Coef", 
          inpName,
          inp::_.mis_pri_sig_fac,
          inp::_.mis_pri_min,
          inp::_.mis_pri_max
        );
        //WriteLn("TRACE ModSes.Obs.Create ok.4.2="<<ok.4.2);
        And(ok.4.1,ok.4.2)
      },
      1==1, 
      {
      //WriteLn("TRACE Time series input with transfer function "+inpName);
        Real ok.4.1 = SetMin(EvalSet(Monomes(omega),Real tf.numDeg(Polyn mon)
        {
          BysMcmc::Bsr::DynHlm::DBApi::ModSes.Mix.Param.Create
          (
            dbName, id_model, id_session, id_node, 
            inpName+"::NumDeg."+IntText(Degree(mon)),
            "OmegaBlk",
            inp::_.initValue,
            inp::_.minimum,
            inp::_.maximum
          )
        }));
        Real ok.4.2 = SetMin(EvalSet(Monomes(1-delta),Real tf.denDeg(Polyn mon)
        {
          BysMcmc::Bsr::DynHlm::DBApi::ModSes.Mix.Param.Create
          (
            dbName, id_model, id_session, id_node, 
            inpName+"::DenDeg."+IntText(Degree(mon)),
            "DeltaBlk",
            inp::_.initValue,
            inp::_.minimum,
            inp::_.maximum
          )
        }));
        Real ok.4.3 = SetMin(For(1,h,Real denIni.param(Real lag)
        {
          BysMcmc::Bsr::DynHlm::DBApi::ModSes.Mix.Param.Create
          (
            dbName, id_model, id_session, id_node, 
            inpName+"::DenIni."+IntText(h-lag),
            "DeltaBlk",
            inp::_.initValue,
            inp::_.minimum,
            inp::_.maximum
          )
        }));
        //WriteLn("TRACE ModSes.Obs.Create ok.4.1="<<ok.4.1);
        Real ok.4.4 = BysMcmc::Bsr::DynHlm::DBApi::ModSes.Obs.TransFun.Create
        (
          dbName, id_model, id_session, id_node, 
          inpName, 
          omega,
          delta,
          inpName,
          inp::_.mis_pri_sig_fac,
          inp::_.mis_pri_min,
          inp::_.mis_pri_max
        );
        //WriteLn("TRACE ModSes.Obs.Create ok.4.2="<<ok.4.2);
        And(ok.4.1,ok.4.2,ok.4.3,ok.4.4)
      })
    },
    ObjectExist("Matrix","inp::_.vector"),
    {
    //WriteLn("TRACE Vector input "+inpName);
      Real ok.4.1 = BysMcmc::Bsr::DynHlm::DBApi::ModSes.Mix.Param.Create
      (
        dbName, id_model, id_session, id_node, 
        inpName+"::Coef",
        "LinearBlk",
        inp::_.initValue,
        inp::_.minimum,
        inp::_.maximum
      );
      //WriteLn("TRACE ModSes.Obs.Create ok.4.1="<<ok.4.1);
      Real ok.4.2 = BysMcmc::Bsr::DynHlm::DBApi::ModSes.Obs.Input.Create
      (
        dbName, id_model, id_session, id_node, 
        inpName+"::Coef", 
        inpName,
        inp::_.mis_pri_sig_fac,
        inp::_.mis_pri_min,
        inp::_.mis_pri_max
      );
      //WriteLn("TRACE ModSes.Obs.Create ok.4.2="<<ok.4.2);
      And(ok.4.1,ok.4.2)
    },
    1==1,
    {
      WriteLn("[ModSes.Obs.Create] Invalid input "+inpName,"E");
      0
    })
  })));
  Real ok = And(ok.1,ok.2,ok.3,ok.4);
  //WriteLn("TRACE ModSes.Obs.Create ok="<<ok);
  Eval("ModSes.Obs.Create."+id_node+".ok=ok")
};

//////////////////////////////////////////////////////////////////////////////
//Creates all observational nodes
Real ModSes.Obs.CreateAll(Text dbName, Text model, Text session,Set nodes)
//////////////////////////////////////////////////////////////////////////////
{
  Real ok.1 = SqlStartCachedInsert(0);
  Real ok.2 = SetMin(For(1, Card(nodes), Real create.obs(Real k)
  {
    NameBlock node = nodes[k];
    Text id_node = node::_.id_node;
    WriteLn("Creating observational node "+id_node);
    Real ok.2.k =BysMcmc::Bsr::DynHlm::DBApi::ModSes.Obs.Create
    (
      DBConnection::BsrHlm::_.defaultDB, id_model, id_session, node
    );
    Eval("ModSes.Obs.CreateAll.ok."<<+k+"=ok.2.k");
    ok.2.k
  }));
  Real ok.3 = SqlStopCachedInsert(0);
  Real ok = And(ok.1,ok.2,ok.3);
  //WriteLn("TRACE ModSes.Obs.CreateAll ok="<<ok);
  Eval("ModSes.Obs.CreateAll.ok=ok")
};

//////////////////////////////////////////////////////////////////////////////
//Renames all registers related to a given output serie into a specified 
//model-session-node with a new identification serie name among all affected 
//bsrhlm_ tables
Real ModSes.Obs.Output.Serie.Rename(Text dbName, 
                                    Text model, 
                                    Text session,
                                    Text from_serie, 
                                    Text to_serie)
//////////////////////////////////////////////////////////////////////////////
{
  Real BysMcmc::Bsr::DynHlm::DBApi::ModSes.CheckBlocked(
    dbName, model, session, true);
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  Real BysMcmc::Bsr::DynHlm::DBApi::SqlExecTrace(
  "UPDATE "+dbName+"."+_table::ObsOutput+"\n"+
  "SET id_series = '"+to_serie+"' \n"+
  "WHERE id_model='"+model+"' AND id_session='"+session+
  "' AND id_series='"+from_serie+"';");
  1
};

//////////////////////////////////////////////////////////////////////////////
Real ModSes.Obs.Input.Serie.Rename(Text dbName, 
                                   Text model, 
                                   Text session,
                                   Text id_node,
                                   Text from_serie,
                                   Text to_serie)
//Renames all registers related to a given input serie into a specified 
//model-session-node with a new identification serie name among all affected 
//bsrhlm_ tables
//////////////////////////////////////////////////////////////////////////////
{
  Real BysMcmc::Bsr::DynHlm::DBApi::ModSes.CheckBlocked(
    dbName, model, session, true);
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  Real BysMcmc::Bsr::DynHlm::DBApi::SqlExecTrace(
  "UPDATE "+dbName+"."+_table::ObsInput+"\n"+
  "SET id_series = '"+to_serie+"' \n"+
  "WHERE id_model='"+model+"' AND id_session='"+session+"' AND id_series='"+from_serie+"';");
  1
};
