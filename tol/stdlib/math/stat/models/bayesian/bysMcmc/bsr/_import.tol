/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// FILE: _import.tol
// PURPOSE: Declares method BysMcmc::Bsr::Import and related methods
/////////////////////////////////////////////////////////////////////////////


NameBlock Import = [[

Text _MID = "[Bsr::Import] ";

//////////////////////////////////////////////////////////////////////////////
//Returns the NameBlock needed to build BSR information about constraining 
//inequations.
NameBlock Constraints(
  //A list of sets with structure of Bsr.OrderRelation.Info
  Set order.relations,
  //A list of sets with structure of Bsr.GenericConstraint.Info
  Set generic.constraints,
  //A list of formated texts in one of this ways
  // "lowerValue <= coef_1*parameter_1 + coef_2*parameter_2 + ... "
  // "upperValue >= coef_1*parameter_1 + coef_2*parameter_2 + ... "
  Set explicit.constraints)
//////////////////////////////////////////////////////////////////////////////
{[[
  Set _order.relations      = order.relations;
  Set _generic.constraints  = generic.constraints;
  Set _explicit.constraints = explicit.constraints;
  //Returns the total number of generic constraints 
  Real Get.OrderRelation.Size     (Real unused) { Card(_order.relations) };
  Real Get.GenericConstraint.Size (Real unused) { Card(_generic.constraints) };
  Real Get.ExplicitConstraint.Size(Real unused) { Card(_explicit.constraints) };

  Set  Get.OrderRelation     (Real r) { _order.relations     [r] };
  Set  Get.GenericConstraint (Real r) { _generic.constraints [r] };
  Text Get.ExplicitConstraint(Real r) { _explicit.constraints[r] }

]]};

//////////////////////////////////////////////////////////////////////////////
NameBlock Order.Relations(Set order.relations)
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::Bsr::Import::Constraints
  (order.relations, Copy(Empty), Copy(Empty))
};

//////////////////////////////////////////////////////////////////////////////
NameBlock Generic.Constraints(Set generic.constraints)
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::Bsr::Import::Constraints
  (Copy(Empty), Copy(Empty), generic.constraints)
};

//////////////////////////////////////////////////////////////////////////////
NameBlock Explicit.Constraints(Set explicit.constraints)
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::Bsr::Import::Constraints
  (Copy(Empty), Copy(Empty), explicit.constraints)
};

NameBlock _unconstrained = Constraints(Copy(Empty),Copy(Empty),Copy(Empty));
//////////////////////////////////////////////////////////////////////////////
NameBlock Unconstrained(Real unused)
//////////////////////////////////////////////////////////////////////////////
{
  _unconstrained
};

///////////////////////////////////////////////////////////////////////////
  Text RealTextS(Real x)
///////////////////////////////////////////////////////////////////////////
{
  FormatReal(x,"%+.16g")
};


Text _comment =  "///////////////////////////////////////////////////////"
                 "//////////////////////\n";

///////////////////////////////////////////////////////////////////////////
Real Write.Header(NameBlock model, Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  Text model.name = model::Get.Doc.Model.Name(0);
  Text model.desc = model::Get.Doc.Model.Description(0);
  Text session.name = model::Get.Doc.Session.Name(0);
  Text session.desc = model::Get.Doc.Session.Description(0);
  Text session.authors = model::Get.Doc.Session.Authors(0);
  WriteLn(_MID+"Writing header ...");
  Real FPutText(fileHandler,
    _comment+
    "// Bayesian Sparse Regression \n"+
    _comment+
    "\n"+
    "$BEGIN\n"
    "\n"+
    "Model.Name = \""+model.name+"\";\n"
    "Model.Description = \""+Replace(model.desc,"\n","\\n\"\n\"")+"\";\n"
    "Session.Name = \""+session.name+"\";\n"
    "Session.Description = \""+Replace(session.desc,"\n","\\n\"\n\"")+"\";\n"
    "Session.Authors = \""+session.authors+"\";\n"
    "\n");
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Data.MainLinearBlock(NameBlock segment,
                                Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  WriteLn(_MID+" segment "+segment::Get.Name(0));
  Set For(1,segment::Get.Param.Size(0), Real(Real k) 
  {
    Set P = segment::Get.Param(k);
    Real iv = If(IsUnknown(P->InitValue),
      Rand(P->LowerBound, P->UpperBound),
      P->InitValue);
    FPutText(fileHandler, P->Name+" <- "+ RealTextS(iv)+";\n");
    Real 0
  });
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Data.MissingBlock(NameBlock segment,
                             Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  Set For(1,segment::Get.Missing.Size(0), Real(Real k) 
  {
    Set P = segment::Get.Missing(k);
    Real nr = LT(P->Prior.Sigma,+1/0);
    Real lb = GT(P->Prior.LowerBound,-1/0);
    Real ub = LT(P->Prior.UpperBound,+1/0);
    Case(!nr & !lb & !ub,
    {
      FPutText(fileHandler, 
        P->Name+" ? <- "+RealTextS(P->Prior.Average)+";\n")
    },
    !lb & !ub,
    {
      FPutText(fileHandler, P->Name+" ? ~ Normal("+ 
        RealTextS(P->Prior.Average)+","+
        RealTextS(P->Prior.Sigma)+");\n")
    },
    1==1,
    {
      FPutText(fileHandler, P->Name+" ? ~ TruncatedNormal("+ 
        RealTextS(P->Prior.Average)+","+
        RealTextS(P->Prior.Sigma)+","+
        RealTextS(P->Prior.LowerBound)+","+
        RealTextS(P->Prior.UpperBound)+");\n")
    });
    Real 0
  });
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Data.NoiseDistribution(NameBlock segment,
                                  Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  Set timeInfo = segment::Get.TimeInfo(0);
  Text timeExpr = If(!Card(timeInfo),"",
  {
    " dating "+Identify(timeInfo->Dating) +
    " from "+FormatDate(timeInfo->FirstDate,"%cy%Ym%md%dh%hi%is%s") +
    " until "+FormatDate(timeInfo->LastDate,"%cy%Ym%md%dh%hi%is%s") 
  });
  FPutText(fileHandler, segment::Get.Name(0)+"::Noise"
    "["+IntText(segment::Get.Equation.Size(0))+timeExpr+"]"+
    " ~ Normal(0,"<<segment::Get.Sigma2(0));
  Real arima.size = segment::Get.ARIMA.Size(0);
  Real If(arima.size, 
  {
    FPutText(fileHandler, "*ARIMA.COV([[");
    Set For(1, arima.size, Real(Real af)
    {
      Set fac = segment::Get.ARIMA.Factor(af);
      FPutText(fileHandler, If(af>1,",","")+"\n  ARIMAStruct("<<
        fac->Periodicity+","<<
        fac->AR+","<<
        fac->MA+","<<
        fac->DIF+")")
    });
    FPutText(fileHandler, "]])")
  });
  FPutText(fileHandler, ");\n");
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Data.RegressionEquations(NameBlock segment,
                                    Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  Text ResName = segment::Get.Name(0)+"::Noise";
  Real nEqu = segment::Get.Equation.Size(0);
  WriteLn(_MID+"Escribiendo ecuaciones para el segmento "<<
          ResName<<"["<<nEqu<<"]");
  Real iE = 1;
  Real fefz = FunctionExist("Real", "segment::Get.Param.ForceZero");
  Real While(iE<=nEqu, Real 
  {
    Real inpSiz = segment::Get.Equation.Input.Size(iE);
    Text txt = "" << 
      segment::Get.Equation.Output(iE) + 
      " == " + 
      ResName+"["+IntText(iE)+"]" +
      If(!inpSiz,"", SetSum(For(1, inpSiz, Text(Real term)
      {
        Anything x = segment::Get.Equation.Input.Coef(iE,term);
        Text g = Grammar(x);
        Real forceZero = If(!fefz,0, segment::Get.Param.ForceZero(term));
        Text v = If(g=="Real", If(And(!forceZero,!x), Text "", RealTextS(x)), 
                 If(And(!forceZero,Or(x=="+0",x=="0",x=="-0")),"",x));
        Text txt = If(v=="","", v+"*"+segment::Get.Equation.Input.Param(iE,term));
        txt
      })))+";\n";
    FPutText(fileHandler,txt);
    Real iE := iE + 1
  });
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Data.Constraints(NameBlock segmentOrFullModel, 
                            Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  NameBlock handler = segmentOrFullModel::Get.Constraints.Handler(0);
  WriteLn(_MID+"Escribiendo restricciones de orden ");
  Set For(1, handler::Get.OrderRelation.Size(0), Real(Real r) 
  {
    Set or = handler::Get.OrderRelation(r);
    Real FPutText(fileHandler, "0>=+1.0*"+or->Lower+"-1.0*"+or->Upper+";\n");
    Real 0
  });
  WriteLn(_MID+"Escribiendo restricciones lineales generales ");
  Set For(1, handler::Get.GenericConstraint.Size(0), Real(Real r) 
  {
    Set gc = handler::Get.GenericConstraint(r);
    Real lb = And(!IsUnknown(gc->LowerBound),GT(gc->LowerBound,-1/0));
    //WriteLn("TRACE gc->LowerBound ="<<gc->LowerBound);
    Real ub = And(!IsUnknown(gc->UpperBound),LT(gc->UpperBound,+1/0));
    //WriteLn("TRACE gc->UpperBound ="<<gc->UpperBound);
    //WriteLn("TRACE lb ="<<lb+" ub="<<ub);
    Text expr =  If(!Card(gc->LinearComb),"", SetSum(
      EvalSet(gc->LinearComb, Text(Bsr.LinearCombTerm term)
      {
        If(term->Coefficient==0,"",
          RealTextS(term->Coefficient)+"*"<<term->Parameter)
      })));
    If(lb, FPutText(fileHandler, 
      RealTextS(gc->LowerBound)+"<="+expr+";\n"));
    If(ub, FPutText(fileHandler, 
      RealTextS(gc->UpperBound)+">="+expr+";\n"));
    Real 0
  });
  WriteLn(_MID+"Escribiendo restricciones lineales explicitas ");
  Set For(1, handler::Get.ExplicitConstraint.Size(0), Real(Real r) 
  {
    Text inequ = handler::Get.ExplicitConstraint(r);
    FPutText(fileHandler, inequ + ";\n");
    Real 0
  });
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Header.MainLinearBlock(NameBlock model, Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  //Escribo valores iniciales de los parametros. Se asume que cada
  //segmento es "owner" de los parametros que solo aparecen en el y que
  //cada parametro aparece en algun segmento que lo posee.
  WriteLn(_MID+"Writing definition of main linear block parameters");
  Real FPutText(fileHandler,
    "\n\n"+_comment+
    "// Defining header of Regression Variables\n"+
    _comment+
    "\n");
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Header.MissingBlock(NameBlock model, Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  WriteLn(_MID+"Writing definition of missing block parameters");
  Real FPutText(fileHandler,
    "\n\n"+_comment+
    "// Defining header of Regression Missing Values\n"+
    _comment+
    "\n");
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Header.NoiseDistribution(NameBlock model, Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  WriteLn(_MID+"Writing noise distribution");
  Real FPutText(fileHandler,
    "\n\n"+_comment+
    "// Defining header of noise distribution\n"+
    _comment+
    "\n"
    );
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Header.RegressionEquations(NameBlock model, Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  //Escribo las ecuaciones que aporta cada segmento.
  WriteLn(_MID+"Writing header of regression equations");
  Real FPutText(fileHandler,
    "\n\n"+_comment+
    "// Defining regression equations\n"+
    _comment+
    "\n"
    );
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Header.Constraints(NameBlock model, Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  //Escribo las restricciones que involucran los parametros de cada
  //segmento. Estas restricciones pueden ser:
  // 
  //- Restricciones de dominio: lo <= p <= hi
  // 
  //- restricciones de orden, solo parametros del mismo bloque: b_i <= b_k
  // 
  //- restricciones arbitrarias, solo para parametros del mismo bloque:
  // 
  //a1*b1 + a2*b2 + ... + ak*bk <= c
  
  WriteLn(_MID+"Writing header of constrains");
  Real FPutText(fileHandler,
    "\n\n"+_comment+
    "// Defining Parameter Constraints\n"+
    _comment+
    "\n"
    );
  0
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Write =
"Imports data from a model defined by a NameBlock having a set of mandatory "
"methods to get all needed information to write an ASCII file with BSR "
"format that will can be readed by function BSR.Parse ";
  Text Write(NameBlock model)
//////////////////////////////////////////////////////////////////////////////
{
  Text model.name = model::Get.Doc.Model.Name(0);
  Text session.name = model::Get.Doc.Session.Name(0);
  Text path = model::Get.Doc.Path(0);
  Real Do OSDirMake(path);

  Text file.bsr = path+model.name+"."+session.name+".bsr";
  Real f.bsr = FOpen(file.bsr,"w");
  Real If(!f.bsr, Real{
      WriteLn(_MID+"Cannot open "+file.bsr+" for writing.","E");
      Real Stop
    });
  WriteLn(_MID+"File "+file.bsr+" was open successfully.");
  Real FClose(f.bsr);
  Real f.head = FOpen(file.bsr+".head","w");
  Real f.lin  = FOpen(file.bsr+".lin", "w");
  Real f.mis  = FOpen(file.bsr+".mis", "w");
  Real f.dis  = FOpen(file.bsr+".dis", "w");
  Real f.reg  = FOpen(file.bsr+".reg", "w");
  Real f.con  = FOpen(file.bsr+".con", "w");

  Real Write.Header                    (model, f.head);
  Real Write.Header.MainLinearBlock    (model, f.lin);
  Real Write.Header.MissingBlock       (model, f.mis);
  Real Write.Header.NoiseDistribution  (model, f.dis);
  Real Write.Header.RegressionEquations(model, f.reg);
  Real Write.Header.Constraints        (model, f.con);

  Real iB = 1;
  Real numSegment = model::Get.LinReg.Size(0);
  Real While(iB<=numSegment, Real 
  {
    NameBlock segment = model::Get.LinReg.Segment(iB);
    WriteLn(_MID+" Writing segment "+segment::Get.Name(0));
    Real Write.Data.MainLinearBlock    (segment, f.lin);
    Real Write.Data.MissingBlock       (segment, f.mis);
    Real Write.Data.NoiseDistribution  (segment, f.dis);
    Real Write.Data.RegressionEquations(segment, f.reg);
    Real Write.Data.Constraints        (segment, f.con);
    Real iB := iB+1
  });
  Real Write.Data.Constraints(model, f.con);
  Real FPutText(f.con,"\n$END\n");
  Real FClose(f.head);
  Real FClose(f.lin);
  Real FClose(f.mis);
  Real FClose(f.dis);
  Real FClose(f.reg);
  Real FClose(f.con);
  Real OSFilCat([[
    file.bsr+".head",
    file.bsr+".lin",
    file.bsr+".mis",
    file.bsr+".dis",
    file.bsr+".reg",
    file.bsr+".con"]],
    file.bsr);
  Real OSFilRemove(file.bsr+".head");
  Real OSFilRemove(file.bsr+".lin");
  Real OSFilRemove(file.bsr+".mis");
  Real OSFilRemove(file.bsr+".dis");
  Real OSFilRemove(file.bsr+".reg");
  Real OSFilRemove(file.bsr+".con");
  file.bsr
}

]];

