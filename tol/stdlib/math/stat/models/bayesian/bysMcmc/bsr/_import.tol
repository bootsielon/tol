/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// FILE: _import.tol
// PURPOSE: Declares method BysMcmc::Bsr::Import and related methods
/////////////////////////////////////////////////////////////////////////////


NameBlock Import = [[

Text _MID = "[Bsr::Import] ";

//////////////////////////////////////////////////////////////////////////////
//Returns the NameBlock needed to build BSR information about constraining 
//inequations.
NameBlock Constraints(
  //A list of sets with structure of @Bsr.OrderRelation.Info
  Set order.relations,
  //A list of sets with structure of @Bsr.GenericConstraint.Info
  Set generic.constraints,
  //A list of formated texts in one of this ways
  // "lowerValue <= coef_1*parameter_1 + coef_2*parameter_2 + ... "
  // "upperValue >= coef_1*parameter_1 + coef_2*parameter_2 + ... "
  Set explicit.constraints)
//////////////////////////////////////////////////////////////////////////////
{[[
  Set _order.relations      = order.relations;
  Set _generic.constraints  = generic.constraints;
  Set _explicit.constraints = explicit.constraints;
  //Returns the total number of generic constraints 
  Real Get.OrderRelation.Size     (Real unused) { Card(_order.relations) };
  Real Get.GenericConstraint.Size (Real unused) { Card(_generic.constraints) };
  Real Get.ExplicitConstraint.Size(Real unused) { Card(_explicit.constraints) };

  Set  Get.OrderRelation     (Real r) { _order.relations     [r] };
  Set  Get.GenericConstraint (Real r) { _generic.constraints [r] };
  Text Get.ExplicitConstraint(Real r) { _explicit.constraints[r] }

]]};

//////////////////////////////////////////////////////////////////////////////
NameBlock Order.Relations(Set order.relations)
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::Bsr::Import::Constraints
  (order.relations, Copy(Empty), Copy(Empty))
};

//////////////////////////////////////////////////////////////////////////////
NameBlock Generic.Constraints(Set generic.constraints)
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::Bsr::Import::Constraints
  (Copy(Empty), Copy(Empty), generic.constraints)
};

//////////////////////////////////////////////////////////////////////////////
NameBlock Explicit.Constraints(Set explicit.constraints)
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::Bsr::Import::Constraints
  (Copy(Empty), Copy(Empty), explicit.constraints)
};

NameBlock _unconstrained = Constraints(Copy(Empty),Copy(Empty),Copy(Empty));
//////////////////////////////////////////////////////////////////////////////
NameBlock Unconstrained(Real unused)
//////////////////////////////////////////////////////////////////////////////
{
  _unconstrained
};

///////////////////////////////////////////////////////////////////////////
  Text RealTextS(Real x)
///////////////////////////////////////////////////////////////////////////
{
  FormatReal(x,"%+.16g")
};


Text _comment =  "///////////////////////////////////////////////////////"
                 "//////////////////////\n";

///////////////////////////////////////////////////////////////////////////
Real Write.Header(NameBlock model, Real fileHandler, Text module.type)
///////////////////////////////////////////////////////////////////////////
{
  Text model.name = model::Get.Doc.Model.Name(0);
  Text model.desc = model::Get.Doc.Model.Description(0);
  Text session.name = model::Get.Doc.Session.Name(0);
  Text session.desc = model::Get.Doc.Session.Description(0);
  Text session.authors = model::Get.Doc.Session.Authors(0);
  WriteLn(_MID+"Writing header ...");
  Real FPutText(fileHandler,
    _comment+
    "// Bayesian Sparse Regression \n"+
    _comment+
    "\n"+
    "$BEGIN\n"
    "\n"+
    "Module.Type = "+module.type+";\n"
    "Model.Name = \""+model.name+"\";\n"
    "Model.Description = \""+Replace(model.desc,"\n","\\n\"\n\"")+"\";\n"
    "Session.Name = \""+session.name+"\";\n"
    "Session.Description = \""+Replace(session.desc,"\n","\\n\"\n\"")+"\";\n"
    "Session.Authors = \""+session.authors+"\";\n"
    "\n");
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Header.MainLinearBlock(NameBlock model, Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  WriteLn(_MID+"Writing definition of main linear block parameters");
  Real FPutText(fileHandler,
    "\n\n"+_comment+
    "// Defining header of Regression Variables\n"+
    _comment+
    "\n");
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Header.MissingBlock(NameBlock model, Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  WriteLn(_MID+"Writing definition of missing block parameters");
  Real FPutText(fileHandler,
    "\n\n"+_comment+
    "// Defining header of Regression Missing Values\n"+
    _comment+
    "\n");
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Header.NoiseDistribution(NameBlock model, Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  WriteLn(_MID+"Writing noise distribution");
  Real FPutText(fileHandler,
    "\n\n"+_comment+
    "// Defining header of noise distribution\n"+
    _comment+
    "\n"
    );
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Header.RegressionEquations(NameBlock model, Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  //Escribo las ecuaciones que aporta cada segmento.
  WriteLn(_MID+"Writing header of regression equations");
  Real FPutText(fileHandler,
    "\n\n"+_comment+
    "// Defining regression equations\n"+
    _comment+
    "\n"
    );
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Header.Constraints(NameBlock model, Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  //Escribo las restricciones que involucran los parametros de cada
  //segmento. Estas restricciones pueden ser:
  // 
  //- Restricciones de dominio: lo <= p <= hi
  // 
  //- restricciones de orden, solo parametros del mismo bloque: b_i <= b_k
  // 
  //- restricciones arbitrarias, solo para parametros del mismo bloque:
  // 
  //a1*b1 + a2*b2 + ... + ak*bk <= c
  
  WriteLn(_MID+"Writing header of constrains");
  Real FPutText(fileHandler,
    "\n\n"+_comment+
    "// Defining Parameter Constraints\n"+
    _comment+
    "\n"
    );
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Data.MainLinearBlock(NameBlock segment,
                                Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  WriteLn(_MID+" segment "+segment::Get.Name(0));
  Set For(1,segment::Get.Param.Size(0), Real(Real k) 
  {
    Set P = segment::Get.Param(k);
    Real iv = If(!IsUnknown(P->InitValue),
    {
      FPutText(fileHandler, P->Name+" <- "+ RealTextS(P->InitValue)+";\n");
      P->InitValue
    },
    {
      If(IsUnknown(P->LowerBound)&IsUnknown(P->UpperBound),
      {
        FPutText(fileHandler, "$Extern "+P->Name+";\n");
        ?
      }, 
      {
        Real rv = Rand(P->LowerBound, P->UpperBound),
        FPutText(fileHandler, P->Name+" <- "+ RealTextS(rv)+";\n");
        rv
      })
    });
    Real 0
  });
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Data.MissingBlock(NameBlock segment,
                             Real fileHandler,
                             Real writePosition)
///////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE [Write.Data.MissingBlock] 1 segment="<<segment::Get.Name(0));
//WriteLn("TRACE [Write.Data.MissingBlock] 2 writePosition="<<writePosition);
  Set For(1,segment::Get.Missing.Size(0), Real(Real k) 
  {
    Set P = segment::Get.Missing(k);
    Real nr = !IsUnknown(P->Prior.Sigma)      & LT(P->Prior.Sigma,+1/0);
    Real lb = !IsUnknown(P->Prior.LowerBound) & GT(P->Prior.LowerBound,-1/0);
    Real ub = !IsUnknown(P->Prior.UpperBound) & LT(P->Prior.UpperBound,+1/0);
  //WriteLn("TRACE [Write.Data.MissingBlock] P->Prior.Sigma="<<P->Prior.Sigma+" nr="<<nr);
    Text position = If(!writePosition,"",
    "\n at row "+IntText(P->Owner.Row)+" for "+
    Case(
      P->Owner.Type==BysMcmc::Options::Data.Owner.Type::Output,
      {
        "output"
      },
      P->Owner.Type==BysMcmc::Options::Data.Owner.Type::Input,
      {
        "input "<<P->Owner.Column
      },
      P->Owner.Type==BysMcmc::Options::Data.Owner.Type::TransferFunction,
      {
        WriteLn("Cannot define missing values over transfer function "+P->Owner.Name,"E");
        Real Stop;
        ""
      }));
    Case(!nr & !lb & !ub,
    {
      FPutText(fileHandler, 
        P->Name+" ? "+position+
        "\n <- "+RealTextS(P->Prior.Average)+";\n")
    },
    !nr,
    {
      FPutText(fileHandler, P->Name+" ? "+position+
        "\n <- "+RealTextS(P->Prior.Average)+
        "\n ~ Uniform("+ 
        RealTextS(P->Prior.LowerBound)+","+
        RealTextS(P->Prior.UpperBound)+")"+";\n")
    },
    !lb & !ub,
    {
      FPutText(fileHandler, P->Name+" ? "+position+
        "\n ~ Normal("+ 
        RealTextS(P->Prior.Average)+","+
        RealTextS(P->Prior.Sigma)+");\n")
    },
    1==1,
    {
      FPutText(fileHandler, P->Name+" ? "+position+
        "\n ~ TruncatedNormal("+ 
        RealTextS(P->Prior.Average)+","+
        RealTextS(P->Prior.Sigma)+","+
        RealTextS(P->Prior.LowerBound)+","+
        RealTextS(P->Prior.UpperBound)+");\n")
    });
    Real 0
  });
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Data.NoiseDistribution(NameBlock segment,
                                  Real fileHandler,
                                  Text path.prefix)
///////////////////////////////////////////////////////////////////////////
{
  Text name = segment::Get.Name(0);
  Set timeInfo = segment::Get.TimeInfo(0); 
  Text timeExpr = If(!Card(timeInfo),"",
  {
    " dating "+Identify(timeInfo->Dating) +
    " from "+FormatDate(timeInfo->FirstDate,"%cy%Ym%md%dh%hi%is%s") +
    " until "+FormatDate(timeInfo->LastDate,"%cy%Ym%md%dh%hi%is%s") 
  });
  Anything s2 = segment::Get.Sigma2(0);
  Real s2HasPrior = And(Grammar(s2)=="Text", 
                        FunctionExist("Text","segment::Get.SigmaPrior"));
//WriteLn("TRACE "+_MID+" Grammar(s2)="<<Grammar(s2));
//WriteLn("TRACE "+_MID+" FunctionExist(Text,segment::Get.SigmaPrior)="<<FunctionExist("Text","segment::Get.SigmaPrior"));
//WriteLn("TRACE "+_MID+" s2HasPrior="<<s2HasPrior);
  Text s2Prior = If(!s2HasPrior, "",
  {
    Text sp = segment::Get.SigmaPrior(0);
    If(sp=="",""," ~ "+sp+" ")
  });
//WriteLn("TRACE "+_MID+" s2Prior="<<s2Prior);
  FPutText(fileHandler, name+"::Noise"
    "["+IntText(segment::Get.Equation.Size(0))+timeExpr+"]"+
    "\n  ~ Normal(0,"<<s2+s2Prior);
  Real arima.size = If(!FunctionExist("Real","segment::Get.ARIMA.Size"),0,
     segment::Get.ARIMA.Size(0));
  Case(
  arima.size, 
  {
    FPutText(fileHandler, " * Cov = ArimaCovariance([[");
    Set For(1, arima.size, Real(Real af)
    {
      Set fac = segment::Get.ARIMA.Factor(af);
      FPutText(fileHandler, If(af>1,",","")+"\n  @ARIMAStruct("<<
        fac->Periodicity+","<<
        fac->AR+","<<
        fac->MA+","<<
        fac->DIF+")")
    });
    FPutText(fileHandler, "]])")
  },
  FunctionExist("Text","segment::Get.Cov"),
  {
    FPutText(fileHandler, " * Cov = {$ "+segment::Get.Cov(0)+" $}")
  },
  FunctionExist("Text","segment::Get.CovInv"),
  {
    FPutText(fileHandler, " * CovInv = {$ "+segment::Get.CovInv(0)+" $}")
  },
  FunctionExist("Text","segment::Get.CovChol"),
  {
    FPutText(fileHandler, " * CovChol = {$ "+segment::Get.CovChol(0)+" $}")
  },
  FunctionExist("Text","segment::Get.CovInvChol"),
  {
    FPutText(fileHandler, " * CovInvChol = {$ "+segment::Get.CovInvChol(0)+" $}")
  });
  FPutText(fileHandler, ")");
  If(!FunctionExist("Set","segment::Get.NonLinearFilters"),
  {
    WriteLn("Not implemented method Get.NonLinearFilters. "
    "No linear filter is assumed.");
    False
  },
  {
    Set nlf = segment::Get.NonLinearFilters(0);
    If(!Card(nlf),False,
    {
      Text file = name+".NonLinearFilters.oza";
      Text nlf.path = path.prefix+file;
      WriteLn("Get.NonLinearFilters returns "<<Card(nlf)+
      "linear filters that will be stored in "+nlf.path);
      Real Ois.Store(nlf,nlf.path);
      Real FPutText(fileHandler, "\nwith non linear filters \n"
      "  {$ Set { Include(\""+file+"\") } $}");
      True
    })
  });
  FPutText(fileHandler, ";\n");
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Data.RegressionMatrices(NameBlock segment,
                                   Real fileHandler,
                                   Text path.prefix)
///////////////////////////////////////////////////////////////////////////
{
  Text ResName = segment::Get.Name(0)+"::Noise";
  VMatrix Y = segment::Get.OutputVMatrix(0);
  Real Ois.Store([[Y]],path.prefix+"Output.oza");
  Real FPutText(fileHandler, "\nOutput = "
  "  {$ VMatrix { Include(\"./Output.oza\")[1] } $};");
  VMatrix X = segment::Get.InputVMatrix(0);
  If(!VColumns(X),1,
  {
    Real Ois.Store([[X]],path.prefix+"Input.oza");
    Real FPutText(fileHandler, "\nInput = "
    "  {$ VMatrix { Include(\"./Input.oza\")[1] } $};");
    2
  })
};

///////////////////////////////////////////////////////////////////////////
Real Write.Data.RegressionEquations(NameBlock segment,
                                    Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  Text ResName = segment::Get.Name(0)+"::Noise";
  Real nEqu = segment::Get.Equation.Size(0);
  Real iE = 1;
  Real fefz = FunctionExist("Real", "segment::Get.Param.ForceZero");
  Real While(iE<=nEqu, Real 
  {
    Real inpSiz = segment::Get.Equation.Input.Size(iE);
    Text txt = "" << 
      segment::Get.Equation.Output(iE) + 
      " == " + 
      ResName+"["+IntText(iE)+"]" +
      If(!inpSiz,"", SetSum(For(1, inpSiz, Text(Real term)
      {
        Anything x = segment::Get.Equation.Input.Coef(iE,term);
        Text g = Grammar(x);
        Real forceZero = If(!fefz,0, segment::Get.Param.ForceZero(term));
        Text v = If(g=="Real", If(And(!forceZero,!x), Text "", RealTextS(x)), 
                 If(And(!forceZero,Or(x=="+0",x=="0",x=="-0")),"",x));
        Text txt = If(v=="","", v+"*"+segment::Get.Equation.Input.Param(iE,term));
        txt
      })))+";\n";
    FPutText(fileHandler,txt);
    Real iE := iE + 1
  });
  0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Domain.Constraints(NameBlock segment, Real f)
///////////////////////////////////////////////////////////////////////////
{
  WriteLn(_MID+"Escribiendo restricciones de intervalo para los parametros "
          "del bloque "<<segment::Get.Name(0));
  //Uso los parametros del bloque para escribir los intervalos.
  Set For(1,segment::Get.Param.Size(0), Real(Real k) 
    {
      Set P = segment::Get.Param(k);
      
      Real lb = GT(P->Prior.LowerBound,Real -1/0);
      Real ub = LT(P->Prior.UpperBound,Real +1/0);
      If(lb, FPutText(f, RealTextS(P->Prior.LowerBound)+"<=+"+P->Name+";\n"));
      If(ub, FPutText(f, RealTextS(P->Prior.UpperBound)+">=+"+P->Name+";\n"));
      Real 0
    });
  Real 0
};

///////////////////////////////////////////////////////////////////////////
Real Write.Data.Constraints(NameBlock segmentOrFullModel, 
                            Real fileHandler)
///////////////////////////////////////////////////////////////////////////
{
  NameBlock handler = segmentOrFullModel::Get.Constraints.Handler(0);
  Set For(1, handler::Get.OrderRelation.Size(0), Real(Real r) 
  {
    Set or = handler::Get.OrderRelation(r);
    Real FPutText(fileHandler, "0>=+1.0*"+or->Lower+"-1.0*"+or->Upper+";\n");
    Real 0
  });
  
  Set For(1, handler::Get.GenericConstraint.Size(0), Real(Real r) 
  {
    Set gc = handler::Get.GenericConstraint(r);
    Real lb = And(!IsUnknown(gc->LowerBound),GT(gc->LowerBound,-1/0));
    //WriteLn("TRACE gc->LowerBound ="<<gc->LowerBound);
    Real ub = And(!IsUnknown(gc->UpperBound),LT(gc->UpperBound,+1/0));
    //WriteLn("TRACE gc->UpperBound ="<<gc->UpperBound);
    //WriteLn("TRACE lb ="<<lb+" ub="<<ub);
    Text expr =  If(!Card(gc->LinearComb),"", SetSum(
      EvalSet(gc->LinearComb, Text(@Bsr.LinearCombTerm term)
      {
        If(term->Coefficient==0,"",
          RealTextS(term->Coefficient)+"*"<<term->Parameter)
      })));
    If(lb, FPutText(fileHandler, 
      RealTextS(gc->LowerBound)+"<="+expr+";\n"));
    If(ub, FPutText(fileHandler, 
      RealTextS(gc->UpperBound)+">="+expr+";\n"));
    Real 0
  });
  Set For(1, handler::Get.ExplicitConstraint.Size(0), Real(Real r) 
  {
    Text inequ = handler::Get.ExplicitConstraint(r);
    FPutText(fileHandler, inequ + ";\n");
    Real 0
  });
  0
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Write.Primary =
"Imports data from a model defined by a NameBlock having a set of mandatory "
"methods to get all needed information to write an ASCII file with BSR "
"format that will can be readed by function BSR.Parse ";
  Text Write.Primary(NameBlock model)
//////////////////////////////////////////////////////////////////////////////
{
  Real numSegment = model::Get.LinReg.Size(0);
  NameBlock segment = model::Get.LinReg.Segment(0);
  Text segName = segment::Get.Name(0);
  Text path.prefix = model::Get.Doc.Path(0);
  Real Do OSDirMake(path.prefix);
  Text file.bsr = path.prefix+"primary.bsr";
  WriteLn(_MID+" Writing primary module\n  \""+file.bsr+"\"");
  Real f.bsr = FOpen(file.bsr,"w");
  Real If(!f.bsr, Real{
      WriteLn(_MID+"Cannot open "+file.bsr+" for writing.","E");
      Real Stop
    });
  WriteLn(_MID+"File "+file.bsr+" was open successfully.");

  Real Write.Header                    (model,   f.bsr, "primary");
  Real Write.Header.MainLinearBlock    (model,   f.bsr);
  Real Write.Data.MainLinearBlock      (segment, f.bsr);
  Real Write.Header.NoiseDistribution  (model,   f.bsr);
  Real Write.Data.NoiseDistribution    (segment, f.bsr, path.prefix);
  Real Write.Header.RegressionEquations(model,   f.bsr);
  Real Write.Data.RegressionMatrices   (segment, f.bsr, path.prefix);
  Real Write.Header.MissingBlock       (model,   f.bsr);
  Real Write.Data.MissingBlock         (segment, f.bsr, 1);
  Real Write.Domain.Constraints        (segment, f.bsr);
  Real Write.Data.Constraints          (segment, f.bsr);
  Real FPutText(f.bsr,"\n$END\n");
  Real FClose(f.bsr);
  file.bsr
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Write.Joint =
"Imports data from a model defined by a NameBlock having a set of mandatory "
"methods to get all needed information to write an ASCII file with BSR "
"format that will can be readed by function BSR.Parse ";
  Text Write.Joint(NameBlock model)
//////////////////////////////////////////////////////////////////////////////
{
  Text path.prefix = model::Get.Doc.Path(0);
  Real Do OSDirMake(path.prefix);
  Text file.bsr = path.prefix+"joint.bsr";
  WriteLn(_MID+" Writing joint module\n  \""+file.bsr+"\"");
  Real f.bsr = FOpen(file.bsr,"w");
  Real If(!f.bsr, Real{
      WriteLn(_MID+"Cannot open "+file.bsr+" for writing.","E");
      Real Stop
    });
  WriteLn(_MID+"File "+file.bsr+" was open successfully.");
  Real FClose(f.bsr);
  Real f.head = FOpen(file.bsr+".head","w");
  Real f.lin  = FOpen(file.bsr+".lin", "w");
  Real f.mis  = FOpen(file.bsr+".mis", "w");
  Real f.dis  = FOpen(file.bsr+".dis", "w");
  Real f.reg  = FOpen(file.bsr+".reg", "w");
  Real f.con  = FOpen(file.bsr+".con", "w");

  Real Write.Header                    (model, f.head, "joint");
  Real Write.Header.MainLinearBlock    (model, f.lin);
  Real Write.Header.MissingBlock       (model, f.mis);
  Real Write.Header.NoiseDistribution  (model, f.dis);
  Real Write.Header.RegressionEquations(model, f.reg);
  Real Write.Header.Constraints        (model, f.con);

  Real iB = 1;
  Real numSegment = model::Get.LinReg.Size(0);
  Real While(iB<=numSegment, Real 
  {
    NameBlock segment = model::Get.LinReg.Segment(iB);
    WriteLn(_MID+" Writing segment "+segment::Get.Name(0));
    Real Write.Data.MainLinearBlock    (segment, f.lin);
    Real Write.Data.MissingBlock       (segment, f.mis, False);
    Real Write.Data.NoiseDistribution  (segment, f.dis, path.prefix);
    Real Write.Data.RegressionEquations(segment, f.reg);
    Real Write.Domain.Constraints      (segment, f.con);
    Real Write.Data.Constraints        (segment, f.con);
    Real iB := iB+1
  });
  Real Write.Data.Constraints(model, f.con);
  Real FPutText(f.con,"\n$END\n");
  Real FClose(f.head);
  Real FClose(f.lin);
  Real FClose(f.mis);
  Real FClose(f.dis);
  Real FClose(f.reg);
  Real FClose(f.con);
  Real OSFilCat([[
    file.bsr+".head",
    file.bsr+".lin",
    file.bsr+".mis",
    file.bsr+".dis",
    file.bsr+".reg",
    file.bsr+".con"]],
    file.bsr);

  Real OSFilRemove(file.bsr+".head");
  Real OSFilRemove(file.bsr+".lin");
  Real OSFilRemove(file.bsr+".mis");
  Real OSFilRemove(file.bsr+".dis");
  Real OSFilRemove(file.bsr+".reg");
  Real OSFilRemove(file.bsr+".con");
  file.bsr
};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Write.Master =
"Imports data from a model defined by a NameBlock having a set of mandatory "
"methods to get all needed information to write an ASCII file with BSR "
"format that will can be readed by function BSR.Parse ";
  Text Write.Master(NameBlock model)
//////////////////////////////////////////////////////////////////////////////
{
  Text path.prefix = model::Get.Doc.Path(0);
  Real Do OSDirMake(path.prefix);
  Text file.bsr = path.prefix+"master.bsr";
  WriteLn(_MID+" Writing master module\n  \""+file.bsr+"\"");
  Real f.bsr = FOpen(file.bsr,"w");
  Real If(!f.bsr, Real{
      WriteLn(_MID+"Cannot open "+file.bsr+" for writing.","E");
      Real Stop
    });
  WriteLn(_MID+"File "+file.bsr+" was open successfully.");

  Set modules = model::Get.Modules(0);
  Real Write.Header(model, f.bsr, "master");
  Real FPutText(f.bsr,"Modular.Schema = "+model::Get.Modular.Schema(0)+";\n");

  Set EvalSet(modules, Real(NameBlock module)
  {
    Text moduleType = module::Get.ModuleType(0);
    Text module.bsr = Replace(
      module::Get.Doc.Path(0)+moduleType+".bsr",
      path.prefix,
      "./");
    Real FPutText(f.bsr,"Include "+moduleType+
     " module \""+module.bsr+"\";\n");
    Text Write.Module(module, moduleType);
    1
  });
  Real FPutText(f.bsr,"\n$END\n");
  Real FClose(f.bsr);
  file.bsr
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Write.Module =
"Imports data from a model defined by a NameBlock having a set of mandatory "
"methods to get all needed information to write an ASCII file with BSR "
"format that will can be readed by function BSR.Parse ";
  Text Write.Module(NameBlock model, Text moduleType)
//////////////////////////////////////////////////////////////////////////////
{
  Case
  (
    moduleType=="primary", Write.Primary(model),
    moduleType=="joint",   Write.Joint  (model),
    moduleType=="master",  Write.Master (model),
    1==1,
    {
      Error("Invalid module type '"+moduleType+"' should be one of these "
            "'primary', 'joint' or 'master'");
      ""
    }
  )
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Write =
"Imports data from a model defined by a NameBlock having a set of mandatory "
"methods to get all needed information to write an ASCII file with BSR "
"format that will can be readed by function BSR.Parse ";
  Text Write(NameBlock model)
//////////////////////////////////////////////////////////////////////////////
{
  Text moduleType = ToLower(If(!FunctionExist("Text","model::Get.ModuleType"),
  {
    "joint"
  },
  {
    model::Get.ModuleType(0)
  }));
  Write.Module(model,moduleType)
}


]];

