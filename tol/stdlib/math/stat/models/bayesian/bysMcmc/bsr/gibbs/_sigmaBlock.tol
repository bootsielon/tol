/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// MODULE: Stat (Statistics)
// FILE: _sigmaBlock.tol
// PURPOSE: Declares Class BysMcmc::Bsr::Gibbs::BlockSigma
/////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
Struct BlockSigma.PartialIndex
//--------------------------------------------------------------------------
{
  Real idxFixed;
  Real idxReload
};

/////////////////////////////////////////////////////////////////////////////
Class BlockSigma : BlockSampler
/////////////////////////////////////////////////////////////////////////////
{
  //--------------------------------------------------------------------------
  // Mandatory members
  //--------------------------------------------------------------------------
  Real _.m;
  //Selects residuals with constant sigma
  Set _.sigmaBlockCte;
  //Selects residuals with variant sigma
  Set _.sigmaBlockVar;

  //Number of variant variances (dimension of sigma block)
  Real _.S;
  //A diagonal matrix with sum of all constant sigmas that will be used in 
  //regression standarizing
  VMatrix _.sigmaInvCte;
  //Sigma block current store
  VMatrix _.sigmaInv;

  //--------------------------------------------------------------------------
  //Auxiliar members
  //--------------------------------------------------------------------------
  NameBlock _.ws = [[ Real unused_=? ]];
  Set _.segment.partial.index = Copy(Empty);

  //--------------------------------------------------------------------------
  //Methods
  //--------------------------------------------------------------------------

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" initialize 1 ");
    Real hasFixed   = _.partialSampler::_.fixedParamNum  > 0;
  //WriteLn("TRACE "+_MID+" initialize hasFixed="<<hasFixed);
    Real hasReload  = _.partialSampler::_.reloadParamNum > 0;
  //WriteLn("TRACE "+_MID+" initialize hasReload="<<hasReload);
    Real hasPartial = hasFixed | hasReload;
  //WriteLn("TRACE "+_MID+" initialize hasPartial="<<hasPartial);
    Set If(hasPartial, 
    {
      Set _.segment.partial.index := 
      EvalSet(_.sigmaBlockVar,Set(BSR.NoiseDistrib segment)
      {
        Real idxFixed  = 0;
        Real idxReload = 0;
        Text name = ToName(segment->SigmaName);
        Real If(hasFixed,
        {
          idxFixed:=FindIndexByName(_.partialSampler::_.fixedParam, name)
        });
        Real If(hasReload & !idxFixed,
        {
          idxReload:=FindIndexByName(_.partialSampler::_.reloadParam, name)
        });
        BysMcmc::Bsr::Gibbs::BlockSigma.PartialIndex(idxFixed, idxReload) 
      })
    });
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Real _buildWorkSpace(VMatrix residuals_)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" BlockSigma::_buildWorkSpace 0");
    NameBlock _.ws := 
    [[
      VMatrix  residuals = residuals_
    ]];
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.sumOfSquares =
  "Method of generation of sigma block containing draws of all variant "
  "variances as inverses of a squared-chi";
  NameBlock sumOfSquares(Real numSim, VMatrix residuals, BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" sumOfSquares 1 "+segment->Name);
    Real    m    = (segment->ArimaAuxInfo)::numDifData;
  //WriteLn("TRACE "+_MID+" sumOfSquares 2 ");
    VMatrix ek   = SubRow(residuals, segment->EquIdx);
  //WriteLn("TRACE "+_MID+" sumOfSquares 3 ek=("<<Matrix Tra(VMat2Mat(ek))+")");
    Real    rss_ = VMatDat(MtMSqr(ek),1,1);
  //WriteLn("TRACE "+_MID+" sumOfSquares 4 ");
    Real rss  = If(rss_==0, 
    {
      If(numSim>1, WriteLn(_MID+" Sampling sum of squares of residuals "
        "is just zero for segment "+segment->Name,"W"));
      0.0001*m
    },
    {
      rss_
    });
  //WriteLn("TRACE "+_MID+" sumOfSquares 5 ");
    [[
      Real m,
      Real rss
    ]]
  };

  ////////////////////////////////////////////////////////////////////////////
  Real draw.invRandChisq.segment(
    Real numSim, 
    VMatrix residuals, 
    BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.1 "+segment->Name);
    NameBlock sumSqr = sumOfSquares(numSim, residuals, segment);
  //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2 ");
    Case(
    StructName(segment->SigmaPrior)=="Bsr.Sigma.Prior.InverseGamma",
    {
    //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.1 ");
      Real s2 = segment->SigmaPrior->Sigma2;
    //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.2 ");
      Real w  = segment->SigmaPrior->Weight;
    //WriteLn("TRACE ["+_MID+"] draw.invRandChisq("<<s2+","<<w+")");
      Case(
      w==1,  
      {
      //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.1 ");
        s2
      },
      w==0,
      {
      //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.2 ");
        sumSqr::rss/RandChisq(sumSqr::m)
      },
      LT(0,w,1),
      {
      //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.3 ");
        //w = m0/(m0+m); m0*(w-1)=-m*w; m0 = m*w/(1-w)
        Real m0 = Max(1,Round(sumSqr::m*w/(1-w)));
      //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.4 ");
        Real rss = sumSqr::rss + m0 * s2;
      //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.5 ");
        Real m = sumSqr::m + m0;
      //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.6 ");
        Real S2 = rss/RandChisq(m); 
      //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.7 ");
        /*
      //WriteLn("TRACE "+_MID+" draw.invRandChisq ("+segment->Name+") "+
          " s2="<<s2+
          " w="<<w+
          " m0="<<m0+
          " sumSqr::m="<<sumSqr::m+
          " sumSqr::rss="<<sumSqr::rss+
          " m="<<m+
          " S2="<<S2); */
        S2          
      },
      1==1,
      {
        WriteLn(_MID+" Weigtht of prior sigma is not in [0,1] "
        "for segment "+segment->Name,"E");
        ?
      })

    },
    1==1,
    {
    //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.3 ");
      sumSqr::rss/RandChisq(sumSqr::m)
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.invRandChisq =
  "Method of generation of sigma block containing draws of all variant "
  "variances as inverses of a squared-chi";
  VMatrix draw.invRandChisq(Real numSim, VMatrix residuals)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" draw.invRandChisq 1 ");
   
    Set v = If(!Card(_.segment.partial.index),
    {
      EvalSet(_.sigmaBlockVar,Real(BSR.NoiseDistrib segment)
      {
        draw.invRandChisq.segment(numSim, residuals, segment)
      })
    },
    {
      For(1,Card(_.sigmaBlockVar),Real(Real k)
      {
        Set partial = _.segment.partial.index[k];
        Real Case(partial->idxFixed,
        {
          VMatDat(_.partialSampler::_.fixedValues,partial->idxFixed,1)
        },
        {
          VMatDat(_.partialSampler::_.reloadValues,partial->idxreload,1)
        },
        {
          draw.invRandChisq.segment(numSim, residuals, _.sigmaBlockVar[k])
        })
      })
    });
    Mat2VMat(SetCol(v))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw =
  "Method of simulation of sigma block";
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    draw.invRandChisq(numSim, _.ws::residuals)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setStore =
  "Sets _.store to the specified row vector of values and prepares the "
  "filter";
  Real setStore(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" setStore("<<Rows(values)+"x"<<Columns(values)+")");
    If(_.N<=0,0,{
    Real putStore(values);
    VMatrix sigmaInvVar = BinGroup("+", 
    For(1,Card(_.sigmaBlockVar), VMatrix (Real k)
    {
      Real si = 1/Sqrt(VMatDat(_.store,k,1));
      _.sigmaBlockVar[k]->Li*si
    }));
  //WriteLn("TRACE "+_MID+" solve.stdReg 2");
    VMatrix _.sigmaInv := sigmaInvVar + _.sigmaInvCte;
    1 })
  };

  //////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.New =
  "Builds a NameBlock that can draw a Gibbs sample of a variance block of a "
  "general regression model.";
  //////////////////////////////////////////////////////////////////////////////
  Static BlockSigma New(
   Text name, 
   Set NoiseDistrib, 
   BysMcmc::McmcPartialHandler mcmcPartialHandler,
   Real numBlock, 
   Real firstCol,
   BysMcmc::Config  config)
  //////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::Gibbs::BlockSigma sigBlk = [[

    Code _.buildWorkSpace = _buildWorkSpace;

    Real _.m = VRows(NoiseDistrib[1]->Li);
    //Selects residuals with constant sigma
    Set _.sigmaBlockCte = 
    {
    //WriteLn("TRACESelecting residuals with known wariance");
      Select(NoiseDistrib, Real(BSR.NoiseDistrib d)
      { d->SigmaIndex<=0 })
    };
    //Selects residuals with variant sigma
    Set _.sigmaBlockVar = 
    {
    //WriteLn("TRACESelecting residuals with unknown wariance");
      Select(NoiseDistrib, Real(BSR.NoiseDistrib d)
      { d->SigmaIndex>0 })
    };
    //Defining the block in the Markov Chain
    Real _defined = define
    (
      name,
      EvalSet(_.sigmaBlockVar, Text(BSR.NoiseDistrib d) { d->SigmaName });
      mcmcPartialHandler,
      numBlock,
      firstCol,
      config
    );
    //Number of variant variances (dimension of sigma block)
    Real _.S = Card(_.sigmaBlockVar);
    //A diagonal matrix with sum of all constant sigmas that will be used in 
    //regression standarizing
    VMatrix _.sigmaInvCte = If(!Card(_.sigmaBlockCte), Zeros(_.m),
      BinGroup("+", EvalSet(_.sigmaBlockCte, VMatrix (BSR.NoiseDistrib d) 
      { d->Li })));
    //Sigma block current store
    VMatrix _.sigmaInv = _.sigmaInvCte

  ]]}

};

