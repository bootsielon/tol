/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// MODULE: Stat (Statistics)
// FILE: _sigmaBlock.tol
// PURPOSE: Declares method BysMcmc::Bsr::Gibbs::SigmaBlock
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
Class BlockSamplerSigma : BlockSampler
/////////////////////////////////////////////////////////////////////////////
{
  //--------------------------------------------------------------------------
  // Mandatory members
  //--------------------------------------------------------------------------
  Real _.m;
  //Selects residuals with constant sigma
  Set _.sigmaBlockCte;
  //Selects residuals with variant sigma
  Set _.sigmaBlockVar;

  //Number of variant variances (dimension of sigma block)
  Real _.S;
  //A diagonal matrix with sum of all constant sigmas that will be used in 
  //regression standarizing
  VMatrix _.sigmaInvCte;
  //Sigma block current store
  VMatrix _.sigmaInv;

  //--------------------------------------------------------------------------
  //Auxiliar members
  //--------------------------------------------------------------------------
  NameBlock _.ws = [[ Real unused_=? ]];

  //--------------------------------------------------------------------------
  //Methods
  //--------------------------------------------------------------------------
  ////////////////////////////////////////////////////////////////////////////
  Real _buildWorkSpace(VMatrix residuals_)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" BlockSamplerSigma::_buildWorkSpace 0");
    NameBlock _.ws := 
    [[
      VMatrix  residuals = residuals_
    ]];
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.sumOfSquares =
  "Method of generation of sigma block containing draws of all variant "
  "variances as inverses of a squared-chi";
  NameBlock sumOfSquares(Real numSim, VMatrix residuals, BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" sumOfSquares 1 "+segment->Name);
    Real    m    = (segment->ArimaAuxInfo)::numDifData;
  //WriteLn("TRACE "+_MID+" sumOfSquares 2 ");
    VMatrix ek   = SubRow(residuals, segment->EquIdx);
  //WriteLn("TRACE "+_MID+" sumOfSquares 3 ek=("<<Matrix Tra(VMat2Mat(ek))+")");
    Real    rss_ = VMatDat(MtMSqr(ek),1,1);
  //WriteLn("TRACE "+_MID+" sumOfSquares 4 ");
    Real rss  = If(rss_==0, 
    {
      If(numSim>1, WriteLn(_MID+" Sampling sum of squares of residuals "
        "is just zero for segment "+segment->Name,"W"));
      0.0001*m
    },
    {
      rss_
    });
  //WriteLn("TRACE "+_MID+" sumOfSquares 5 ");
    [[
      Real m,
      Real rss
    ]]
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.invRandChisq =
  "Method of generation of sigma block containing draws of all variant "
  "variances as inverses of a squared-chi";
  VMatrix draw.invRandChisq(Real numSim, VMatrix residuals)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" draw.invRandChisq 1 ");
    Set v = EvalSet(_.sigmaBlockVar,Real(BSR.NoiseDistrib segment)
    {
    //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.1 "+segment->Name);
      NameBlock sumSqr = sumOfSquares(numSim, residuals, segment);
    //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2 ");
      Case(
      StructName(segment->SigmaPrior)=="Bsr.Sigma.Prior.InverseGamma",
      {
      //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.1 ");
        Real s2 = segment->SigmaPrior->Sigma2;
      //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.2 ");
        Real w  = segment->SigmaPrior->Weight;
      //WriteLn("TRACE ["+_MID+"] draw.invRandChisq("<<s2+","<<w+")");
        Case(
        w==1,  
        {
        //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.1 ");
          s2
        },
        w==0,
        {
        //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.2 ");
          sumSqr::rss/RandChisq(sumSqr::m)
        },
        LT(0,w,1),
        {
        //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.3 ");
          //w = m0/(m0+m); m0*(w-1)=-m*w; m0 = m*w/(1-w)
          Real m0 = Max(1,Round(sumSqr::m*w/(1-w)));
        //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.4 ");
          Real rss = sumSqr::rss + m0 * s2;
        //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.5 ");
          Real m = sumSqr::m + m0;
        //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.6 ");
          Real S2 = rss/RandChisq(m); 
        //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.2.3.7 ");
          /*
        //WriteLn("TRACE "+_MID+" draw.invRandChisq ("+segment->Name+") "+
            " s2="<<s2+
            " w="<<w+
            " m0="<<m0+
            " sumSqr::m="<<sumSqr::m+
            " sumSqr::rss="<<sumSqr::rss+
            " m="<<m+
            " S2="<<S2); */
          S2          
        },
        1==1,
        {
          WriteLn(_MID+" Weigtht of prior sigma is not in [0,1] "
          "for segment "+segment->Name,"E");
          ?
        })

      },
      1==1,
      {
      //WriteLn("TRACE "+_MID+" draw.invRandChisq 2.3 ");
        sumSqr::rss/RandChisq(sumSqr::m)
      })
    });
    Mat2VMat(SetCol(v))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw =
  "Method of simulation of sigma block";
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    draw.invRandChisq(numSim, _.ws::residuals)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setStore =
  "Sets _.store to the specified row vector of values and prepares the "
  "filter";
  Real setStore(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.N<=0,0,{
    Real putStore(values);
    VMatrix sigmaInvVar = BinGroup("+", 
    For(1,Card(_.sigmaBlockVar), VMatrix (Real k)
    {
      Real si = 1/Sqrt(VMatDat(_.store,k,1));
      _.sigmaBlockVar[k]->Li*si
    }));
  //WriteLn("TRACE "+_MID+" solve.stdReg 2");
    VMatrix _.sigmaInv := sigmaInvVar + _.sigmaInvCte;
    1 })
  }
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.SigmaBlock =
"Builds a NameBlock that can draw a Gibbs sample of a variance block of a "
"general regression model.";
//////////////////////////////////////////////////////////////////////////////
  BlockSamplerSigma SigmaBlock(Text name, 
                               Set NoiseDistrib, 
                               BysMcmc::McmcPartialHandler mcmcPartialHandler,
                               Real numBlock, 
                               Real firstCol,
                               BysMcmc::Config  config)
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::Bsr::Gibbs::BlockSamplerSigma sigBlk = [[

  Code _.buildWorkSpace = _buildWorkSpace;

  Real _.m = VRows(NoiseDistrib[1]->Li);
  //Selects residuals with constant sigma
  Set _.sigmaBlockCte = 
  {
  //WriteLn("TRACESelecting residuals with known wariance");
    Select(NoiseDistrib, Real(BSR.NoiseDistrib d)
    { d->SigmaIndex<=0 })
  };
  //Selects residuals with variant sigma
  Set _.sigmaBlockVar = 
  {
  //WriteLn("TRACESelecting residuals with unknown wariance");
    Select(NoiseDistrib, Real(BSR.NoiseDistrib d)
    { d->SigmaIndex>0 })
  };
  //Defining the block in the Markov Chain
  Real _defined = define
  (
    name,
    EvalSet(_.sigmaBlockVar, Text(BSR.NoiseDistrib d) { d->SigmaName });
    mcmcPartialHandler,
    numBlock,
    firstCol,
    config
  );
  //Number of variant variances (dimension of sigma block)
  Real _.S = Card(_.sigmaBlockVar);
  //A diagonal matrix with sum of all constant sigmas that will be used in 
  //regression standarizing
  VMatrix _.sigmaInvCte = If(!Card(_.sigmaBlockCte), Zeros(_.m),
    BinGroup("+", EvalSet(_.sigmaBlockCte, VMatrix (BSR.NoiseDistrib d) 
    { d->Li })));
  //Sigma block current store
  VMatrix _.sigmaInv = _.sigmaInvCte

]]};
