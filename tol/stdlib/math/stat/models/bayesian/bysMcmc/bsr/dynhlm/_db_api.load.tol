//////////////////////////////////////////////////////////////////////////////
// FILE    : _db_api.load.tol
// PURPOSE : Implements model loading related methods of NameBlock 
//           BysMcmc::Bsr::DynHlm::DBApi
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//Manejador de series del modelo
  NameBlock CreateSeriesHandler(Set obs.node.handlers)
//////////////////////////////////////////////////////////////////////////////
{[[
  //Se crean las series de cada nodo
  Set _.obs.node = obs.node.handlers; 

  //Se comprueba la unicidad de nombres y se indexa para acelerar búsquedas
  Real _check_unique = SetIndexByName(_.obs.node);


  ///////////////////////////////////////////////////////////////////////////
  //Returns the asked serie or vector of a node
  Anything GetSerie(Text id_node, Text id_serie)
  ///////////////////////////////////////////////////////////////////////////
  {
    (_.obs.node[id_node])::GetSerie(id_serie)
  };

  ///////////////////////////////////////////////////////////////////////////
  //Returns the asked non linear filter of a node
  NameBlock GetNonLinFlt(Text id_node, Text id_nonLinFlt)
  ///////////////////////////////////////////////////////////////////////////
  {
    (_.obs.node[id_node])::GetNonLinFlt(id_nonLinFlt)
  };

  Set _.range.nodes = Range(1,Card(_.obs.node),1);

  ///////////////////////////////////////////////////////////////////////////
  //Searchs for enabled input over all observational nodes having no transfer
  //function or 1/1
  Set SelectNodesWithInputEnabled(Text input)
  ///////////////////////////////////////////////////////////////////////////
  {
    Set select = Select(_.range.nodes, Real(Real k)
    {
      Real j = FindIndexByName(((_.obs.node)[k])::_.input, input);
      If(!j, 0, ((((_.obs.node)[k])::_.input)[j])::_.enabled)
    });
    Set EvalSet(select,NameBlock(Real k)
    {
      Text id_node_k = ((_.obs.node)[k])::_.id_node;
      NameBlock [[
        Text _.id_node = id_node_k;
        Text _.id_parameter = child_input+"::Coef";
        Real _.sigma_factor = 1
      ]]
    })
  };
  ///////////////////////////////////////////////////////////////////////////
  //Searchs for enabled input over all observational nodes having transfer
  //function with omega including a term which degree is equal to numDeg
  Set SelectNodesWithOmegaEnabled(Text input, Real numDeg)
  ///////////////////////////////////////////////////////////////////////////
  {
    Set select = Select(_.range.nodes, Real(Real k)
    {
      Real j = FindIndexByName(((_.obs.node)[k])::_.input, input);
      If(!j, 0, ((((_.obs.node)[k])::_.input)[j])::_.enabled)
    });
    Set EvalSet(select,NameBlock(Real k)
    {
      Text id_node_k = ((_.obs.node)[k])::_.id_node;
      NameBlock [[
        Text _.id_node = id_node_k;
        Text _.id_parameter = child_input+"::NumDeg."+IntText(numDeg);
        Real _.sigma_factor = 1
      ]]
    })
  }
]]};

////////////////////////////////////////////////////////////////////////////
//Loads from data base information about all constraints related to a 
//specified node.
//For constraints without a node owner use the pseudo-node "MIXTURE"
  NameBlock LoadNodeConstraints(Text dbName, 
                                Text model, 
                                Text session,
                                Text id_node)
////////////////////////////////////////////////////////////////////////////
{
  Text order_node_cond = If(id_node=="MIXTURE",
    "id_node_lower<>id_node_upper",
    "id_node_lower='"+id_node+"' AND id_node_upper='"+id_node+"'");

  Set orderRelations = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT \n"+
  "  Concat(B.id_gibbs_blk,'::',A.id_node_lower,'::',A.id_parameter_lower), \n"+
  "  Concat(C.id_gibbs_blk,'::',A.id_node_upper,'::',A.id_parameter_upper)  \n"+
  "FROM \n"
  "  "+dbName+"."+_table::OrderRel+" as A, \n"
  "  "+dbName+"."+_table::Parameter+" as B, \n"
  "  "+dbName+"."+_table::Parameter+" as C \n"
  "WHERE \n"+
  "  A.id_model='"+model+"' AND \n"+
  "  A.id_session='"+session+"' AND\n"+
  "  B.id_model='"+model+"' AND \n"+
  "  B.id_session='"+session+"' AND\n"+
  "  C.id_model='"+model+"' AND \n"+
  "  C.id_session='"+session+"' AND\n"+
  "  A.id_node_lower=B.id_node AND \n"+
  "  A.id_parameter_lower=B.id_parameter AND\n"+
  "  A.id_node_upper=C.id_node AND \n"+
  "  A.id_parameter_upper=C.id_parameter AND\n"+
  order_node_cond, 
  "Bsr.OrderRelation.Info");
//WriteLn("TRACE orderRelations=\n"<<orderRelations);
  Set constrBorder = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT \n"+
  "  vl_left_border, nu_inequation, vl_right_border \n"+
  "FROM "+dbName+"."+_table::ConstrBorder+" WHERE \n"+
  "  id_model='"+model+"' AND \n"+
  "  id_session='"+session+"' AND\n"+
  "  id_node='"+id_node+"'"
  "ORDER BY nu_inequation", 
  "Bsr.DynHlm.DBStrConstrBorder");

  Set genericConstraints = 
  EvalSet(constrBorder, Set(Bsr.DynHlm.DBStrConstrBorder b)
  {
    Set linComb = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
    "SELECT \n"+
    "  A.vl_coef, Concat(B.id_gibbs_blk,'::',A.id_node,'::',A.id_parameter)  \n"+
    "FROM \n"+
    "  "+dbName+"."+_table::ConstrLinComb+" as A, \n"+
    "  "+dbName+"."+_table::Parameter+" as B \n"+
    "WHERE \n"+
    "  A.id_model='"+model+"' AND \n"+
    "  A.id_session='"+session+"' AND\n"+
    "  A.nu_inequation="+IntText(b->NumInequation)+" AND \n"+
    "  B.id_model='"+model+"' AND \n"+
    "  B.id_session='"+session+"' AND\n"+
    "  A.id_node=B.id_node AND \n"+
    "  A.id_parameter=B.id_parameter\n", 
    "Bsr.LinearCombTerm");
    //VBR: SHOULD CHECK id_node if is not MIXTURE
    Bsr.GenericConstraint.Info
    (
      b->LowerBound,
      linComb,
      b->UpperBound
    )
  });

  BysMcmc::Bsr::Import::Constraints
  (
    orderRelations,
    genericConstraints,
    Copy(Empty)
  )
};

///////////////////////////////////////////////////////////////////////////
// Non Linear Filter Section
Set LoadNodeNonLinFil(
  Text dbName, 
  Text model, 
  Text session,
  Text id_node, 
  NameBlock modelHandler)
///////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE [LoadNodeNonLinFil] 1 id_node="+id_node);
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  Set db_genericNonLinBlk = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT \n"+
  "  id_node, \n"+
  "  id_series \n"+
  "FROM "+dbName+"."+_table::NonLinFlt+" WHERE \n"+
  "  id_model='"+id_model+"' AND \n"+
  "  id_session='"+id_session+"'\n AND"+
  "  id_node='"+id_node+"'\n",
  "Bsr.DynHlm.DBStrNonLinFlt");

  Set genericNonLinBlk = If(!Card(db_genericNonLinBlk), 
    Empty,
    EvalSet(db_genericNonLinBlk,NameBlock get.nlf(Bsr.DynHlm.DBStrNonLinFlt nlf)
    {
      modelHandler::GetNonLinFlt(nlf->node, nlf->nameBlock)
    }));
//WriteLn("TRACE [LoadNodeNonLinFil] 2 Card(genericNonLinBlk)="<<Card(genericNonLinBlk));
  genericNonLinBlk
};

////////////////////////////////////////////////////////////////////////////
//Loads from data base an observational node
//Data series are given by user through a modelHandler having at least a 
//method Serie GetSerie(Text id_node, Text id_serie)
NameBlock LoadObsNode(Text dbName, 
                      Text model, 
                      Text session,
                      Text id_node, 
                      NameBlock modelHandler,
                      Set input.missing.labels,
                      Set genericNonLinearFilters)
////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE LoadObsNode 1");
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
//WriteLn("TRACE LoadObsNode 2");
  Set db_output = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT \n"+
  "  id_series, \n"+
  "  vl_mis_pri_sig_fac, \n"+
  "  vl_mis_pri_min, \n"+
  "  vl_mis_pri_max, \n"+
  "  dh_start, \n"+
  "  dh_end , \n"+
  "  vl_sigma , \n"+
  "  vl_sigma_prior_weight \n"+
  "FROM "+dbName+"."+_table::ObsOutput+" WHERE \n"+
  "  id_model='"+model+"' AND \n"+
  "  id_session='"+session+"' AND \n"+
  "  id_node='"+id_node+"' ",
  "Bsr.DynHlm.DBStrObsOutput")[1];

  Set db_arima = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT \n"+
  "  nu_period, \n"+
  "  te_ar, \n"+
  "  te_ma, \n"+
  "  te_dif \n"+
  "FROM "+dbName+"."+_table::ObsArimaBlk+" WHERE \n"+
  "  id_model='"+model+"' AND \n"+
  "  id_session='"+session+"' AND \n"+
  "  id_node='"+id_node+"' \n"+
  "ORDER BY nu_factor ASC", 
  "Bsr.DynHlm.DBStrARIMA");
//WriteLn("TRACE LoadObsNode 4 db_output=\n"<<db_output);
  Set arima = EvalSet(db_arima, Set(Bsr.DynHlm.DBStrARIMA factor)
  {
    ARIMAStruct
    (
      factor->period,
      Eval(factor->AR),
      Eval(factor->MA),
      Eval(factor->DIF)
    )
  });
//WriteLn("TRACE LoadObsNode 5");
  NameBlock output = {BysMcmc::Bsr::DynHlm::BuildNode::Obs.Output(
    BysMcmc::Bsr::DynHlm::BuildNode::Obs.Data.Info(
      id_node,db_output->id_series, 
      BysMcmc::Options::Data.Owner.Type::Output,
      modelHandler::GetSerie(id_node, db_output->id_series), 
      0,
      db_output->firstDate, 
      db_output->lastDate, 
      If(BysMcmc::Bsr::DynHlm::DBApi::useNodeInMissingIdentifier, 
        id_node, "MIXTURE"),
      db_output->missingPriorSigmaFactor, 
      db_output->missingPriorLowerBound, 
      db_output->missingPriorUpperBound),
      db_output->sigma,
      db_output->sigmaPriorWeight,
      arima)};
//WriteLn("TRACE LoadObsNode 6");
  Set db_inputs = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT \n"+
  "  A.id_parameter, \n"+
  "  A.id_series, \n"+
  "  A.vl_mis_pri_sig_fac, \n"+
  "  A.vl_mis_pri_min, \n"+
  "  A.vl_mis_pri_max, \n"+
  "  B.vl_prm_ini, \n"+
  "  B.vl_prm_min, \n"+
  "  B.vl_prm_max \n"+
  "FROM \n"+
  "  "+dbName+"."+_table::ObsInput+" as A, \n"+
  "  "+dbName+"."+_table::Parameter+" as B \n"+
  "WHERE \n"+
  "  A.id_model='"+model+"' AND \n"+
  "  A.id_session='"+session+"' AND \n"+
  "  A.id_node='"+id_node+"' AND\n"+
  "  B.id_model='"+model+"' AND \n"+
  "  B.id_session='"+session+"' AND \n"+
  "  B.id_node='"+id_node+"' AND \n"+
  "  B.id_parameter=A.id_parameter", 
  "Bsr.DynHlm.DBStrObsInput");
//WriteLn("TRACE LoadObsNode 7 db_inputs=\n"<<db_inputs);
  Set input = { EvalSet(db_inputs, 
  NameBlock buildInput(Bsr.DynHlm.DBStrObsInput db_inp)
  {
    BysMcmc::Bsr::DynHlm::BuildNode::Obs.Input(
      db_inp->id_parameter,
      BysMcmc::Bsr::DynHlm::BuildNode::Obs.Data.Info(
        id_node,db_inp->id_series, 
        BysMcmc::Options::Data.Owner.Type::Input,
        modelHandler::GetSerie(id_node, db_inp->id_series),
        0,
        db_output->firstDate, 
        db_output->lastDate, 
        If(BysMcmc::Bsr::DynHlm::DBApi::useNodeInMissingIdentifier, 
          id_node, "MIXTURE"),
        db_inp->missingPriorSigmaFactor, 
        db_inp->missingPriorLowerBound, 
        db_inp->missingPriorUpperBound),
      db_inp->paramInitValue, 
      db_inp->paramPriorLowerBound, 
      db_inp->paramPriorUpperBound)
  })};
  Set db_transFun = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT \n"+
  "  A.id_transferFunction, \n"
  "  A.te_omega, \n"
  "  A.te_delta, \n"
  "  A.id_series, \n"+
  "  A.vl_mis_pri_sig_fac, \n"+
  "  A.vl_mis_pri_min, \n"+
  "  A.vl_mis_pri_max, \n"+
  "  0, \n"+
  "  0.0/0.0, \n"+
  "  0.0/0.0 \n"+
  "FROM \n"+
  "  "+dbName+"."+_table::ObsTransFun+" as A\n"+
  "WHERE \n"+
  "  A.id_model='"+model+"' AND \n"+
  "  A.id_session='"+session+"' AND \n"+
  "  A.id_node='"+id_node+"' \n", 
  "Bsr.DynHlm.DBStrObsTransFun");
  Set transFun = { EvalSet(db_transFun, 
  NameBlock buildTransFun(Bsr.DynHlm.DBStrObsTransFun db_tf)
  {
    Real p = Degree(Eval(db_tf->te_omega));
    BysMcmc::Bsr::DynHlm::BuildNode::Obs.TransFun(
      id_node,
      db_tf->id_transferFunction,
      db_tf->te_omega,
      db_tf->te_delta,
      BysMcmc::Bsr::DynHlm::BuildNode::Obs.Data.Info(
        id_node,db_tf->id_series, 
        BysMcmc::Options::Data.Owner.Type::TransferFunction,
        modelHandler::GetSerie(id_node, db_tf->id_series),
        p,
        db_output->firstDate, 
        db_output->lastDate,
        If(BysMcmc::Bsr::DynHlm::DBApi::useNodeInMissingIdentifier, 
          id_node, "MIXTURE"),
        db_tf->missingPriorSigmaFactor, 
        db_tf->missingPriorLowerBound, 
        db_tf->missingPriorUpperBound),
      db_tf->paramInitValue, 
      db_tf->paramPriorLowerBound, 
      db_tf->paramPriorUpperBound)
  })};
//WriteLn("TRACE LoadObsNode 8");
  NameBlock _.constr=BysMcmc::Bsr::DynHlm::DBApi::LoadNodeConstraints
    (dbName,model,session,id_node);
  Real forceZeroInputCoef = 
    If(!FunctionExist("Real", "modelHandler::ForceZeroInputCoef"),0,
      modelHandler::ForceZeroInputCoef(0));
  BysMcmc::Bsr::DynHlm::BuildNode::Obs(
    output, input, transFun, input.missing.labels, 
    _.constr, forceZeroInputCoef, genericNonLinearFilters)
};

////////////////////////////////////////////////////////////////////////////
//Loads from data base a latent node
NameBlock LoadLatNode(Text dbName, 
                      Text model, 
                      Text session, 
                      Text id_node,
                      Set genericNonLinearFilters)
////////////////////////////////////////////////////////////////////////////
{
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  [[
    Text _.id_node = id_node;
    Set db_sigma_info = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
    "SELECT \n"+
    "  vl_sigma, vl_sigma_prior_weight \n"+
    "FROM "+dbName+"."+_table::LatSigBlk+" WHERE \n"+
    "  id_model='"+model+"' AND \n"+
    "  id_session='"+session+"' AND \n"+
    "  id_node='"+id_node+"' ", 
    "")[1];
    Real db_sigma = db_sigma_info[1];
    Real db_sigmaPriorWeight = db_sigma_info[2];
    Set db_equ = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
    "SELECT \n"+
    "  nu_equation, \n"+
    "  vl_sigma_factor \n"+
    "FROM "+dbName+"."+_table::LatEqu+" WHERE \n"+
    "  id_model='"+model+"' AND \n"+
    "  id_session='"+session+"' AND \n"+
    "  id_node_father='"+id_node+"' \n"
    "ORDER BY nu_equation", 
    "Bsr.DynHlm.DBStrLatEqu");      

    Set db_output = EvalSet(db_equ, Set(Bsr.DynHlm.DBStrLatEqu equ)
    {
      BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
      "SELECT \n"+
      "  nu_equation, \n"+
      "  Concat(B.id_gibbs_blk,'::', A.id_node_child, '::',A.id_parameter_child ), \n"+
      "  vl_coef \n"+
      "FROM \n"+
      "  "+dbName+"."+_table::LatOutput+" as A, \n"
      "  "+dbName+"."+_table::Parameter+" as B  \n"
      "WHERE \n"+
      "  A.id_model='"+model+"' AND \n"+
      "  A.id_session='"+session+"' AND \n"+
      "  A.id_node_father='"+id_node+"' AND \n"+
      "  A.nu_equation="+IntText(equ->nu_equation)+" AND \n"+
      "  B.id_model='"+model+"' AND \n"+
      "  B.id_session='"+session+"' AND \n"+
      "  A.id_node_child=B.id_node AND \n"+
      "  A.id_parameter_child=B.id_parameter \n",
      "Bsr.DynHlm.DBStrLatOutput")
    });
    Set db_input = EvalSet(db_equ, Set(Bsr.DynHlm.DBStrLatEqu equ)
    {
      BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
      "SELECT \n"+
      "  nu_equation, \n"+
      "  Concat(B.id_gibbs_blk,'::', A.id_node_father, '::',A.id_parameter_father ), \n"+
      "  vl_coef \n"+
      "FROM \n"+
      "  "+dbName+"."+_table::LatInput+" as A, \n"
      "  "+dbName+"."+_table::Parameter+" as B  \n"
      "WHERE \n"+
      "  A.id_model='"+model+"' AND \n"+
      "  A.id_session='"+session+"' AND \n"+
      "  A.id_node_father='"+id_node+"' AND \n"+
      "  A.nu_equation="+IntText(equ->nu_equation)+" AND \n"+
      "  B.id_model='"+model+"' AND \n"+
      "  B.id_session='"+session+"' AND \n"+
      "  A.id_node_father=B.id_node AND \n"+
      "  A.id_parameter_father=B.id_parameter \n",
      "Bsr.DynHlm.DBStrLatInput")
    });

    Set db_param = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
    "SELECT \n"+
    "  Concat(id_gibbs_blk,'::',id_node,'::',id_parameter), \n"+
    "  vl_prm_ini, \n"+
    "  vl_prm_min, \n"+
    "  vl_prm_max \n"+
    "FROM "+dbName+"."+_table::Parameter+" WHERE \n"+
    "  id_model='"+model+"' AND \n"+
    "  id_session='"+session+"' AND \n"+
    "  id_node='"+id_node+"' ", 
    "Bsr.Param.Info"); 

    Text Get.Name(Real unused) { _.id_node };
    Real hasPrior = If(IsUnknown(db_sigmaPriorWeight),False,
                       LT(0,db_sigmaPriorWeight,1));
    Anything Get.Sigma2(Real unused) 
    { 
      If(IsUnknown(db_sigma) | hasPrior,
        "SigmaBlk::"+_.id_node+"::Variance",
        db_sigma^2)
    };
    Text Get.SigmaPrior(Real unused) 
    { 
      If(!hasPrior,"",
         "Bsr.Sigma.Prior.InverseGamma("<<
         db_sigma+","<<db_sigmaPriorWeight+")")
    };
    Real Get.ARIMA.Size(Real unused) { 0 };
    Real Get.Param.Size(Real unused) { Card(db_param) };
    Set Get.Param(Real numParam) { db_param[numParam] };
    Real Get.Missing.Size(Real unused) {  0 };
    Set Get.TimeInfo(Real unused) { Copy(Empty) };

    Set _.genericNonLinearFilters = genericNonLinearFilters;
    //Returns a set of NameBlock's with user specified non linear filters
    Set Get.NonLinearFilters(Real unused)
    {
      _.genericNonLinearFilters
    };
    Real Get.Equation.Size(Real unused) { Card(db_equ) };
    //Returns Real known output or Text missing name
    Text Get.Equation.Output(Real t) { "+0" };
    //Returns the number of input terms involved in t-th equation
    Real Get.Equation.Input.Size(Real t) 
    { 
      Card(db_output[t])+Card(db_input[t])
    };
    //Returns Real known output or Text missing name of an input term
    Text Get.Equation.Input.Coef(Real t, Real term) 
    { 
      Real outParamNum = Card(db_output[t]);
      Real f = db_equ[t]->sigma_factor;
      Real coef = If(term<=outParamNum,
        db_output[t][term            ]->coef,
       -db_input [t][term-outParamNum]->coef);
      BysMcmc::Bsr::Import::RealTextS(coef/f) 
    };
    //Returns the param name of an input term
    Text Get.Equation.Input.Param(Real t, Real term)
    {
      Real outParamNum = Card(db_output[t]);
      If(term<=outParamNum,
        db_output[t][term            ]->child,
        db_input [t][term-outParamNum]->father)
    };
    NameBlock _.constr=BysMcmc::Bsr::DynHlm::DBApi::LoadNodeConstraints
      (dbName,model,session,id_node);
    NameBlock Get.Constraints.Handler(Real unused) { _.constr } 
  ]]
};

////////////////////////////////////////////////////////////////////////////
//Loads from data base a prior node
NameBlock LoadPriNode(Text dbName, 
                      Text model, 
                      Text session, 
                      Text id_node,
                      Set genericNonLinearFilters)
////////////////////////////////////////////////////////////////////////////
{
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  [[
    Text _.id_node = id_node;
    Set db_equ = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
    "SELECT \n"+
    "  nu_equation, \n"+
    "  vl_average, \n"+
    "  vl_sigma, \n"+
    "  vl_sigma_prior_weight \n"+
    "FROM "+dbName+"."+_table::PriEqu+" WHERE \n"+
    "  id_model='"+model+"' AND \n"+
    "  id_session='"+session+"' AND \n"+
    "  id_node_father='"+id_node+"' \n"
    "ORDER BY nu_equation", 
    "Bsr.DynHlm.DBStrPriEqu");

    Set db_output = EvalSet(db_equ, Set(Bsr.DynHlm.DBStrLatEqu equ)
    {
      BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
      "SELECT \n"+
      "  nu_equation, \n"+
      "  Concat(B.id_gibbs_blk,'::', A.id_node_child, '::',A.id_parameter_child ), \n"+
      "  vl_coef \n"+
      "FROM \n"+
      "  "+dbName+"."+_table::PriOutput+" as A, \n"
      "  "+dbName+"."+_table::Parameter+" as B  \n"
      "WHERE \n"+
      "  A.id_model='"+model+"' AND \n"+
      "  B.id_model='"+model+"' AND \n"+
      "  A.id_session='"+session+"' AND \n"+
      "  B.id_session='"+session+"' AND \n"+
      "  A.id_node_father='"+id_node+"' AND \n"+
      "  A.nu_equation="+IntText(equ->nu_equation)+ " AND \n"+
      "  A.id_node_child=B.id_node AND \n"+
      "  A.id_parameter_child=B.id_parameter \n",
      "Bsr.DynHlm.DBStrPriOutput")
    });

    Text Get.Name(Real unused) { _.id_node };

    Real hasPrior = If(IsUnknown(db_equ[1]->sigmaPriorWeight),False,
                       LT(0,db_equ[1]->sigmaPriorWeight,1));
    Anything Get.Sigma2(Real unused) 
    { 
      If(IsUnknown(db_equ[1]->sigma) | hasPrior,
        "SigmaBlk::"+_.id_node+"::Variance",
        db_equ[1]->sigma^2)
    };
    Text Get.SigmaPrior(Real unused) 
    { 
      If(!hasPrior,"",
         "Bsr.Sigma.Prior.InverseGamma("<<
         db_equ[1]->sigma+","<<db_equ[1]->sigmaPriorWeight+")")
    };

    Real Get.ARIMA.Size(Real unused) { 0 };
    Real Get.Param.Size(Real unused) { 0 };
    Set Get.Param(Real numParam) { Copy(Empty) };
    Real Get.Missing.Size(Real unused) {  0 };
    Set Get.TimeInfo(Real unused) { Copy(Empty) };

    Set _.genericNonLinearFilters = genericNonLinearFilters;
    //Returns a set of NameBlock's with user specified non linear filters
    Set Get.NonLinearFilters(Real unused)
    {
      _.genericNonLinearFilters
    };
    Real Get.Equation.Size(Real unused) { Card(db_equ) };
    //Returns Real known output or Text missing name
    Text Get.Equation.Output(Real t) 
    { 
      Real f = db_equ[1]->sigma / db_equ[t]->sigma;
      BysMcmc::Bsr::Import::RealTextS(f*db_equ[t]->average) 
    };
    //Returns the number of input terms involved in t-th equation
    Real Get.Equation.Input.Size(Real t) { Card(db_output[t]) };
    //Returns Real known output or Text missing name of an input term
    Text Get.Equation.Input.Coef(Real t, Real term) 
    { 
      Real f = db_equ[1]->sigma / db_equ[t]->sigma;
      BysMcmc::Bsr::Import::RealTextS(f*db_output[t][term]->coef) 
    };
    //Returns the param name of an input term
    Text Get.Equation.Input.Param(Real t, Real term)
    {
      db_output[t][term]->child
    };
    NameBlock Get.Constraints.Handler(Real unused) 
    { BysMcmc::Bsr::Import::Unconstrained(0) }
  ]]
};



////////////////////////////////////////////////////////////////////////////
//Loads from data base full model definition and creates a NameBlock with
//Auxiliar data and final MCMC and reports will be saved in resultRootPath
//Data series are given by user through a modelHandler having at least a 
//method Serie GetSerie(Text id_node, Text id_serie)
NameBlock LoadModelDef.Joint(
  Text dbName, 
  Text model, 
  Text session, 
  Text resultRootPath,
  NameBlock modelHandler, 
  BysMcmc::Config config,
  Real includeObs,
  Real includeLat,
  Real includePri,
  Text sufixPath)
////////////////////////////////////////////////////////////////////////////
{[[
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  Text _.moduleType="joint";
  Text _.dbName = dbName; 
  Text _.id_model = model;
  Text _.id_session = session;
  Text _.resultRootPath = resultRootPath;
  Text _.sufixPath = sufixPath;
  NameBlock _.modelHandler = modelHandler;

  Real _.modSesCheck = 
  {
    Real count = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
    "SELECT count(*) FROM "+dbName+"."+_table::ModSes+" WHERE "+
    "  id_model='"+_.id_model+"' AND id_session='"+_.id_session+"'","")[1][1];
    If(count==1, 1,
    {
      Error("Cannot find model-session ('"+model+"'-'"+session+"')");
      Stop;
      0
    })
  };
  Text _.model.description = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT ds_model FROM "+dbName+"."+_table::Model+" WHERE "+
  "  id_model='"+_.id_model+"'","")[1][1];
  Text _.session.description = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT ds_session FROM "+dbName+"."+_table::Session+" WHERE "+
  "  id_session='"+_.id_session+"'","")[1][1];
  Text _.session.te_authors = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT te_authors FROM "+dbName+"."+_table::Session+" WHERE "+
  "  id_session='"+_.id_session+"'","")[1][1];

  Set input.missing.labels = Copy(Empty);

  Set _.nodes.obs = If(!includeObs,Copy(Empty),
  BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT id_node_type, id_node FROM "+dbName+"."+_table::Node+" WHERE \n"+
  "  id_model='"+_.id_model+"' AND \n"+
  "  id_session='"+_.id_session+"' AND "
  "  id_node_type='OBS'"
  "order by nu_node","Bsr.DynHlm.DBNode"));
  Set _.nodes.lat = If(!includeLat,Copy(Empty), 
  BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT id_node_type, id_node FROM "+dbName+"."+_table::Node+" WHERE \n"+
  "  id_model='"+_.id_model+"' AND \n"+
  "  id_session='"+_.id_session+"' AND "
  "  id_node_type='LAT'"
  "order by nu_node","Bsr.DynHlm.DBNode"));
  Set _.nodes.pri =  If(!includePri,Copy(Empty),
  BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT id_node_type, id_node FROM "+dbName+"."+_table::Node+" WHERE \n"+
  "  id_model='"+_.id_model+"' AND \n"+
  "  id_session='"+_.id_session+"' AND "
  "  id_node_type='PRI'"
  "order by nu_node","Bsr.DynHlm.DBNode"));
  Set _.nodes = _.nodes.obs<<_.nodes.lat<<_.nodes.pri;

//Mandatory methods that will be used by BysMcmc::Bsr::Import

  Text Get.ModuleType(Real unused) { _.moduleType };

  ///////////////////////////////////////////////////////////////////////////
  // Documental Section
  //Returns model identifier to help in analysis organization
  Text Get.Doc.Model.Name(Real unused) { _.id_model };
  //Brief explanation of model
  Text Get.Doc.Model.Description(Real unused)  { _.model.description };
  //Returns model identifier to help in analysis organization
  Text Get.Doc.Session.Name(Real unused)  { _.id_session };
  //Brief explanation of model
  Text Get.Doc.Session.Description(Real unused) { _.session.description };
  //e-mail or any identifier of te_authors separated by \n
  Text Get.Doc.Session.Authors(Real unused)  { _.session.te_authors };
  //The path where the BSR-ASCII formated file will be stored
  Text Get.Doc.Path(Real unused) 
  { 
    _.resultRootPath+_.id_model+"/"+_.id_session+"/"+
    If(_.sufixPath=="","",_.sufixPath+"/")
  };

  ///////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  // Linear Regression Section
  Real Get.LinReg.Size(Real unused) 
  { 
    Card(_.nodes)
  };

  ////////////////////////////////////////////////////////////////////////////
  // Non Linear Filter Section
  NameBlock Get.LinReg.Segment(Real segmentNumber) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    Set node = _.nodes[segmentNumber];
    Text id_node = node->Node;
    Set gnlf = BysMcmc::Bsr::DynHlm::DBApi::LoadNodeNonLinFil(
      _.dbName, _.id_model, _.id_session, id_node, _.modelHandler);
  //WriteLn("TRACE [Get.LinReg.Segment] id_node="+id_node+" node->NodeType="<<node->NodeType);
    Case(
      node->NodeType=="OBS", 
      {
        BysMcmc::Bsr::DynHlm::DBApi::LoadObsNode(
          _.dbName, _.id_model, _.id_session, id_node, 
          _.modelHandler, input.missing.labels, gnlf)
      },   
      node->NodeType=="LAT", 
      {
        BysMcmc::Bsr::DynHlm::DBApi::LoadLatNode(
          _.dbName, _.id_model, _.id_session, id_node, gnlf)
      },
      node->NodeType=="PRI", 
      {
        BysMcmc::Bsr::DynHlm::DBApi::LoadPriNode(
          _.dbName, _.id_model, _.id_session, id_node, gnlf)
      }
    )
  };

  ////////////////////////////////////////////////////////////////////////////
  // NO Linear Constraints Section
  NameBlock _.constr=BysMcmc::Bsr::DynHlm::DBApi::LoadNodeConstraints
    (dbName,model,session,"MIXTURE");
  NameBlock Get.Constraints.Handler(Real unused) { _.constr } 
  ////////////////////////////////////////////////////////////////////////////

]]};

//////////////////////////////////////////////////////////////////////////////
//Loads from data base full model definition and creates a NameBlock with
//Auxiliar data and final MCMC and reports will be saved in resultRootPath
//Data series are given by user through a modelHandler having at least a 
//method Serie GetSerie(Text id_node, Text id_serie)
NameBlock LoadModelDef.Joint.All(
  Text dbName, 
  Text model, 
  Text session, 
  Text resultRootPath,
  NameBlock modelHandler, 
  BysMcmc::Config config)
//////////////////////////////////////////////////////////////////////////////
{
  LoadModelDef.Joint(
   dbName, model, session, resultRootPath,modelHandler,config, 
   true,true,true,"")
};

//////////////////////////////////////////////////////////////////////////////
//Loads from data base full model definition and creates a NameBlock with
//Auxiliar data and final MCMC and reports will be saved in resultRootPath
//Data series are given by user through a modelHandler having at least a 
//method Serie GetSerie(Text id_node, Text id_serie)
NameBlock LoadModelDef.Master.ObsAsPrimary(
  Text dbName, 
  Text model, 
  Text session, 
  Text resultRootPath,
  NameBlock modelHandler, 
  BysMcmc::Config config)
//////////////////////////////////////////////////////////////////////////////
{
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  Text model.description = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT ds_model FROM "+dbName+"."+_table::Model+" WHERE "+
  "  id_model='"+model+"'","")[1][1];
  Text session.description = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT ds_session FROM "+dbName+"."+_table::Session+" WHERE "+
  "  id_session='"+session+"'","")[1][1];
  Text session.te_authors = BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT te_authors FROM "+dbName+"."+_table::Session+" WHERE "+
  "  id_session='"+session+"'","")[1][1];

  NameBlock master.module = [[
  Text _.moduleType="master";
  Text _.dbName = dbName; 
  Text _.id_model = model;
  Text _.id_session = session;
  Text _.resultRootPath = resultRootPath;
  NameBlock _.modelHandler = modelHandler;

  Text _.model.description = model.description;
  Text _.session.description =  session.description;
  Text _.session.te_authors = session.te_authors;

  Set _.input.missing.labels = [[ Copy(Empty) ]];
  Text _.modular.Schema = config::DBApi.masterSampler;

  Set _.nodes.obs = 
  BysMcmc::Bsr::DynHlm::DBApi::SqlTableTrace(
  "SELECT id_node_type, id_node FROM "+dbName+"."+_table::Node+" WHERE \n"+
  "  id_model='"+_.id_model+"' AND \n"+
  "  id_session='"+_.id_session+"' AND "
  "  id_node_type='OBS'"
  "order by nu_node","Bsr.DynHlm.DBNode");
  
  Set _.obs = EvalSet(_.nodes.obs, NameBlock(Set node)
  {
    Set input.missing.labels = _.input.missing.labels;
    NameBlock obs.module = [[
    Text _.moduleType="primary";
    Text _.id_node = node->Node;
    Text _.dbName = dbName; 
    Text _.id_model = model;
    Text _.id_session = session;
    Text _.resultRootPath = resultRootPath;
    NameBlock _.modelHandler = modelHandler;
    Text _.model.description = model.description;
    Text _.session.description =  session.description;
    Text _.session.te_authors = session.te_authors;
    Set _.input.missing.labels = input.missing.labels;

    Set _.gnlf = BysMcmc::Bsr::DynHlm::DBApi::LoadNodeNonLinFil(
        _.dbName, _.id_model, _.id_session, _.id_node, _.modelHandler);
    NameBlock _.segment = BysMcmc::Bsr::DynHlm::DBApi::LoadObsNode(
        _.dbName, _.id_model, _.id_session, _.id_node, 
        _.modelHandler, _.input.missing.labels[1], _.gnlf);

    //////////////////////////////////////////////////////////////////////////
    //Mandatory methods that will be used by BysMcmc::Bsr::Import
    //////////////////////////////////////////////////////////////////////////
    Text Get.ModuleType(Real unused) { _.moduleType };
    // Documental Section
    //Returns model identifier to help in analysis organization
    Text Get.Doc.Model.Name(Real unused) { _.id_model };
    //Brief explanation of model
    Text Get.Doc.Model.Description(Real unused)  { _.model.description };
    //Returns model identifier to help in analysis organization
    Text Get.Doc.Session.Name(Real unused)  { _.id_session };
    //Brief explanation of model
    Text Get.Doc.Session.Description(Real unused) { _.session.description };
    //e-mail or any identifier of te_authors separated by \n
    Text Get.Doc.Session.Authors(Real unused)  { _.session.te_authors };
    //The path where the BSR-ASCII formated file will be stored
    Text Get.Doc.Path(Real unused) 
    { 
      _.resultRootPath+_.id_model+"/"+_.id_session+"/"+_.id_node+"/"
    };
    // Linear Regression Section
    Real Get.LinReg.Size(Real unused) { 1 };
    // Segment Section
    NameBlock Get.LinReg.Segment(Real segmentNumber) { _.segment }
    
  ]]});
  NameBlock _.latPri = LoadModelDef.Joint(
   dbName, model, session, resultRootPath, modelHandler,config, 
   false,true,true,"LatPri");
  Set _.modules = 
  {
    Real numSegment = _.latPri::Get.LinReg.Size(0);
    NameBlock handler = _.latPri::Get.Constraints.Handler(0);
    Real numConstr = handler::Get.OrderRelation.Size(0)+
                     handler::Get.GenericConstraint.Size(0)+
                     handler::Get.ExplicitConstraint.Size(0);
    If(!numSegment & !numConstr, _.obs, _.obs << [[_.latPri]])
  };

  //Mandatory methods that will be used by BysMcmc::Bsr::Import

  ////////////////////////////////////////////////////////////////////////////
  // Documental Section
  //Returns model identifier to help in analysis organization
  Text Get.Doc.Model.Name(Real unused) { _.id_model };
  //Brief explanation of model
  Text Get.Doc.Model.Description(Real unused)  { _.model.description };
  //Returns model identifier to help in analysis organization
  Text Get.Doc.Session.Name(Real unused)  { _.id_session };
  //Brief explanation of model
  Text Get.Doc.Session.Description(Real unused) { _.session.description };
  //e-mail or any identifier of te_authors separated by \n
  Text Get.Doc.Session.Authors(Real unused)  { _.session.te_authors };
  //The path where the BSR-ASCII formated file will be stored
  Text Get.Doc.Path(Real unused) 
  { 
    _.resultRootPath+_.id_model+"/"+_.id_session+"/"
  };

  ////////////////////////////////////////////////////////////////////////////
  
  Text Get.ModuleType(Real unused) { _.moduleType };
  Text Get.Modular.Schema(Real unused) { _.modular.Schema };
  Set Get.Modules(Real unused) { _.modules }

]]};
