/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// MODULE: Stat (Statistics)
// FILE: _outputMissingBlock.tol
// PURPOSE: Declares method BysMcmc::Bsr::Gibbs::OutputMissingBlock
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
Class BlockOutputMissing : BlockStdLin 
////////////////////////////////////////////////////////////////////////////
{
  //--------------------------------------------------------------------------
  // Mandatory members
  //--------------------------------------------------------------------------
  //Output missing pairs i,k
  Set _.t;
  //Selecting output missing variables with prior information
  Matrix _.I;
  //Number of output missing prior equations
  Real _.prior.M;
  //Average vector of output missing priors
  Matrix _.prior.nu;
  //Inverse of standard deviation vector of output missing priors
  Matrix _.prior.si;
  //Standarized output of missing priors
  VMatrix _.prior.Y;
  //Standarized input of missing priors
  VMatrix _.prior.X;

  //--------------------------------------------------------------------------
  //Auxiliar members
  //--------------------------------------------------------------------------
  //Auxiliar variable for filter creating
  VMatrix _.FEye = Rand(0,0,0,0);
  //Work space
  WorkSpace.LinReg _.ws = BysMcmc::Bsr::Gibbs::WorkSpace.LinReg::Null(0);
  //Standarized input of free missing priors
  VMatrix _.prior.X.free = Rand(0,0,0,0);

  //--------------------------------------------------------------------------
  //Methods
  //--------------------------------------------------------------------------
  ////////////////////////////////////////////////////////////////////////////
  WorkSpace.LinReg getWorkSpaceLinReg(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  { _.ws };


  ////////////////////////////////////////////////////////////////////////////
  Real _buildWorkSpace_full(BysMcmc::Bsr::Gibbs::BlockArima arm.blk, //Arima Block handler
                            VMatrix   si,    //SigmaBlock filter
                            VMatrix   Z)     //Noise with missing as zero
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" _buildWorkSpace_full 1");
    VMatrix If(VRows(_.FEye)==0,
    {
      _.FEye := SubCol(Eye(VRows(Z)), _.t)
    });
    VMatrix F = arm.blk::filter(_.FEye);
  //WriteLn("TRACE "+_MID+" _buildWorkSpace_full 2 F("<<VRows(F)+"x"<<VColumns(F)+")");
    BysMcmc::Bsr::Gibbs::WorkSpace.LinReg wslr = 
    [[
      VMatrix _.Y = arm.blk::filter(si*Z) << _.prior.Y;
      VMatrix _.X = (-si*F) << _.prior.X
    ]];
  //WriteLn("TRACE "+_MID+" _buildWorkSpace_full 3.1 wslr::_.Y("<<VRows(wslr::_.Y)+"x"<<VColumns(wslr::_.Y)+")");
  //WriteLn("TRACE "+_MID+" _buildWorkSpace_full 3.2 wslr::_.X("<<VRows(wslr::_.X)+"x"<<VColumns(wslr::_.X)+")");
    BysMcmc::Bsr::Gibbs::WorkSpace.LinReg _.ws := wslr;
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real _buildWorkSpace_partial(
    BysMcmc::Bsr::Gibbs::BlockArima arm.blk, //Arima Block handler
    VMatrix   si,    //SigmaBlock filter
    VMatrix   Z)     //Noise with missing as zero
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" _buildWorkSpace_partial 1");
    VMatrix If(VRows(_.prior.X.free)==0,
    {
      Set idx = ExtractByIndex(_.t, _.i2);
      _.FEye := SubCol(Eye(VRows(Z)), idx);
      _.prior.X.free := SubCol(_.prior.X, _.i2)
    });
    VMatrix F = arm.blk::filter(_.FEye);
    VMatrix v1 = SubRow(_.partialSampler::_.values, _.i1);

  //WriteLn("TRACE "+_MID+" _buildWorkSpace_partial 2 u1\n="<<Matrix(Tra(VMat2Mat(u1))));
    VMatrix V1 = MergeRows(VRows(Z), [[ [[ v1, SetCol(_.i1) ]] ]]);
  //WriteLn("TRACE "+_MID+" _buildWorkSpace_partial 2 V1\n="<<Matrix(Tra(VMat2Mat(V1))));
    BysMcmc::Bsr::Gibbs::WorkSpace.LinReg wslr = 
    [[
      VMatrix _.Y = arm.blk::filter(si*(Z-V1))<< _.prior.Y;
      VMatrix _.X = (-si*F) << _.prior.X.free
    ]];
  //WriteLn("TRACE "+_MID+" _buildWorkSpace_partial 3.1 wslr::_.Y("<<VRows(wslr::_.Y)+"x"<<VColumns(wslr::_.Y)+")");
  //WriteLn("TRACE "+_MID+" _buildWorkSpace_partial 3.2 wslr::_.X("<<VRows(wslr::_.X)+"x"<<VColumns(wslr::_.X)+")");
    BysMcmc::Bsr::Gibbs::WorkSpace.LinReg _.ws := wslr;
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real _buildWorkSpace(BysMcmc::Bsr::Gibbs::BlockArima arm.blk, //Arima Block handler
                       VMatrix   si,    //SigmaBlock filter
                       VMatrix   Z)     //Noise with missing as zero
  ////////////////////////////////////////////////////////////////////////////
  {
    If(!_.N1,
    {
      _buildWorkSpace_full(arm.blk,si,Z)
    },
    {
      _buildWorkSpace_partial(arm.blk,si,Z)
    })
  };

  ///////////////////////////////////////////////////////////////////////////
  Real initialize(Real unused)
  ///////////////////////////////////////////////////////////////////////////
  {
    Real initialize.subBlocks(unused);
  //WriteLn("TRACE "+_MID+" initialize 1");
    VMatrix u = _.store;
    //Selecting output missing variables with left truncated prior information
    Set leftConstrainedPrior.sel = 
      Select(_.prior.sel, Real(BSR.MissingBlock b)
      {
        GT(b->MinBound,-1/0)
      });
    //Selecting output missing variables with right truncated prior information
    Set rightConstrainedPrior.sel = 
      Select(_.prior.sel, Real(BSR.MissingBlock b)
      {
        LT(b->MaxBound,1/0)
      });
  //WriteLn("TRACE "+_MID+" initialize 2");
    //Number of output missing with left constrained prior 
    Real left.R = Card(leftConstrainedPrior.sel);
    //Number of output missing with left constrained prior 
    Real right.R = Card(rightConstrainedPrior.sel);
    //Number of output missing with constrained prior 
    Real R = left.R + right.R;
    //Border of output missing constrains
    VMatrix prior.a = If(!R, Rand(0,0,0,0), 
    {
      If(!left.R,  Rand(0,1,0,0), (-Mat2VMat(SetMat(Extract(leftConstrainedPrior.sel,  8)))))  <<
      If(!right.R, Rand(0,1,0,0), (+Mat2VMat(SetMat(Extract(rightConstrainedPrior.sel, 9)))))  
    });
  //WriteLn("TRACE "+_MID+" initialize 3");
    //Coefficients of output missing constrains
    VMatrix prior.A = 
    {
      Set left.range  = Range(1,        left.R, 1);
      Set right.range = Range(1+left.R, R,      1);
      Matrix left  = If(!left.R, Rand(0,3,0,0),
                     SetMat(Traspose([[left.range]])) | 
                     SetMat(Extract(leftConstrainedPrior.sel, 2)) |
                     Rand(left.R,1,-1,-1));
      Matrix right = If(!right.R, Rand(0,3,0,0),
                     SetMat(Traspose([[right.range]])) | 
                     SetMat(Extract(rightConstrainedPrior.sel, 2)) |
                     Rand(right.R,1,+1,+1));
      Convert(Triplet(left<<right,R,_.N),"Cholmod.R.Sparse")
    };
  //WriteLn("TRACE "+_MID+" initialize 4");
    Real ok = matchConstrains(u,prior.A,prior.a);
  //WriteLn("TRACE "+_MID+" initialize 5");
    ok
  };
  
  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filter =
  "Filter regression output with current missing block values. You can set a "
  "previously simulated vector of paramters calling before to method "
  "setMcmcRow";
  VMatrix filter(VMatrix Z)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" filter Z:"<<Z);
    If(Not(enabled), Z,
    {
      VMatrix V = MergeRows(VRows(Z), [[ [[ _.store, _.I]] ]]);
      Z+Convert(V,"Blas.R.Dense")
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.New =
  "Builds a NameBlock that can draw a Gibbs sample of a Output Missing block "
  "of a Bayesian Sparse Regression model";
  ////////////////////////////////////////////////////////////////////////////
  Static BlockStdLin New(
    Text name, 
    Set  outputMissingBlock, 
    BysMcmc::McmcPartialHandler mcmcPartialHandler,
    Real numBlock, 
    Real firstCol,
    BysMcmc::NameBlock config)
  //////////////////////////////////////////////////////////////////////////////
  {
    If(!Card(outputMissingBlock), 
    BysMcmc::Bsr::Gibbs::BlockStdLinEmpty::New(name, numBlock, firstCol, config),
    BysMcmc::Bsr::Gibbs::BlockOutputMissing blk = [[
    Code _.buildWorkSpace = _buildWorkSpace;
    VMatrix _.store = Mat2VMat(SetMat(Extract(outputMissingBlock, 6)));
    //Defining the block in the Markov Chain
    Real _defined = define(
      name, 
      EvalSet(outputMissingBlock, Text(BSR.MissingBlock b){ b->Name }), 
      mcmcPartialHandler,
      numBlock, 
      firstCol, 
      config);
    //Output missing pairs i,k
    Set _.t = Traspose(Extract(outputMissingBlock, 3))[1];
    //Selecting output missing variables with prior information
    Matrix _.I = SetCol(_.t);
    Set _.prior.sel = Select(outputMissingBlock, Real(BSR.MissingBlock b)
    {
      b->Prior != "None"
    });
    //Number of output missing prior equations
    Real _.prior.M = Card(_.prior.sel);
    //Average vector of output missing priors
    Matrix _.prior.nu = If(!_.prior.M, Rand(0,0,0,0), 
      SetMat(Extract(_.prior.sel, 6)));
    //Inverse of standard deviation vector of output missing priors
    Matrix _.prior.si = If(!_.prior.M, Rand(0,0,0,0), 
    {
      Matrix s2 = SetMat(Extract(_.prior.sel, 7));
      RPow(s2,-1/2)
    });
    //Standarized output of output missing priors
    VMatrix _.prior.Y = If(!_.prior.M, Rand(0,1,0,0), 
      Mat2VMat(_.prior.nu $* _.prior.si));
    //Standarized output of output missing priors
    VMatrix _.prior.X = If(!_.prior.M, Rand(0,_.N,0,0), 
    {
    //WriteLn("TRACE "+_MID+" _.prior.X 1");
      Matrix triplet = SetMat(Traspose([[Set Range(1,_.prior.M,1)]])) | 
                       SetMat(Extract(_.prior.sel, 2)) |
                       _.prior.si;
    //WriteLn("TRACE "+_MID+" _.prior.X 2 triplet=\n"<<triplet);
      VMatrix tr = Triplet(triplet,_.prior.M,_.N);
    //WriteLn("TRACE "+_MID+" _.prior.X 3");
      VMatrix pX = Convert(tr,"Cholmod.R.Sparse");
    //WriteLn("TRACE "+_MID+" _.prior.X 4 prior.X="<<pX);
      pX
    })

  ]])}

};

