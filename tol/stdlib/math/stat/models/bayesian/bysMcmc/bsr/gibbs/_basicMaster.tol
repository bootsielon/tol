/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// FILE: _basicMaster.tol
// PURPOSE: Declares method BysMcmc::Bsr::Gibbs::BasicMaster
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
Class MasterSamplerBasic : MasterSampler
/////////////////////////////////////////////////////////////////////////////
{
  //--------------------------------------------------------------------------
  // Mandatory members
  //--------------------------------------------------------------------------
  //Internal reference to model definition
  Set _.modelDef;
  //External filter of output
  Set _.externalFilter;
  //Output after external filters
  VMatrix _.Y;
  //BSR basic blocks
  BysMcmc::Bsr::Gibbs::BlockSamplerStdLinear _.mln.blk;
  BysMcmc::Bsr::Gibbs::BlockSamplerSigma     _.sig.blk;
  BysMcmc::Bsr::Gibbs::BlockSamplerArima     _.arm.blk;
  BysMcmc::Bsr::Gibbs::BlockSamplerStdLinear _.inpMis.blk;
  BysMcmc::Bsr::Gibbs::BlockSamplerStdLinear _.outMis.blk;

  //--------------------------------------------------------------------------
  //Auxiliar members
  //--------------------------------------------------------------------------
  //Output filtered by missing values
  VMatrix _.YplusV = Rand(0,0,0,0);
  //Linear input filtered by missing values
  VMatrix _.XplusU = Rand(0,0,0,0);
  //Linear input filter
  VMatrix _.filter = Rand(0,0,0,0);
  //ARIMA noise
  VMatrix _.noise  = Rand(0,0,0,0);
  //residuals
  VMatrix _.residuals  = Rand(0,0,0,0);
  //Linear block values
  VMatrix _.beta   = Rand(0,0,0,0);

  //--------------------------------------------------------------------------
  //Methods
  //--------------------------------------------------------------------------

  ////////////////////////////////////////////////////////////////////////////
  Text get.session(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    _.modelDef->DocInfo->Session.Name
  }; 

  ////////////////////////////////////////////////////////////////////////////
  Text get.path(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    _.modelDef->DocInfo->Path 
  }; 

  ////////////////////////////////////////////////////////////////////////////
  Real DoExternalFilter(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+"DoExternalFilter 1");
    VMatrix _.Y := _.modelDef->Y;
  //WriteLn("TRACE"+_MID+"DoExternalFilter 2");
    If(!Card(_.externalFilter), 1,
    {
    //WriteLn("TRACE"+_MID+"DoExternalFilter 3");
      Real filter.blk(BysMcmc::BlockSampler extFlt)
      {
        extFlt::do.filter(_.Y)
      };
      SetMin(EvalSet(_.externalFilter,filter.blk))
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix findMatchingBeta(VMatrix givenInitVal)
  //Assigning initial values to linear block variables
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Config cfg = _.config;
    If(!VRows(_.modelDef->a), givenInitVal,
    {
    //WriteLn("TRACESearching valid initial values");
      Set try = SetOfNameBlock
      (
        {[[Text name="givenByUser", Real order=cfg::bsr.iniVal.try.givenByUser]]},
        {[[Text name="zero",        Real order=cfg::bsr.iniVal.try.zero]]},
        {[[Text name="cnstrMinNorm",Real order=cfg::bsr.iniVal.try.cnstrMinNorm]]},
        {[[Text name="cnstrMLE",    Real order=cfg::bsr.iniVal.try.cnstrMLE]]}
      );
      Set try.sel = Select(try,Real(NameBlock method) 
      { method::order });
      Set try.sort = Sort(try.sel,Real(NameBlock a, NameBlock b) 
      { Compare(a::order,b::order) });
      Real method.num = 1;
      Real method.ok = False;
      Real n = VColumns(_.modelDef->X);
      VMatrix beta = Rand(n,1,?,?);
      While(And(!method.ok,method.num<=Card(try.sort)),
      {
        Text method.name = (try.sort[method.num])::name;
        Do WriteLn(_MID+"Trying feasible initial values for MCM by method "+
          method.name+" ...", "");
        VMatrix beta := Case(
        method.name=="givenByUser", 
        {
          givenInitVal
        },
        method.name=="zero", 
        {
          Rand(n,1,0,0)
        },
        method.name=="givenByUser", 
        {
          beta := givenInitVal
        },
        method.name=="cnstrMinNorm", 
        {
          Matrix  Dt    = VMat2Mat(Tra(_.modelDef->A));
          Matrix  d     = VMat2Mat(_.modelDef->a);
          Matrix  XtX   = Diag(n,1);
          Matrix  XtY   = Rand(n,1,0,0);
          Matrix  cnstr = Rquadprog::solveQP(XtX, XtY, -Dt, -d,
                                            {[[Real verbose=TRUE]]})[1];
          Mat2VMat(cnstr)
        },
        method.name=="cnstrMLE", 
        {
          Matrix  Dt    = VMat2Mat(Tra(_.modelDef->A));
          Matrix  d     = VMat2Mat(_.modelDef->a);
          Matrix  XtX   = VMat2Mat(MtMSqr(_.XplusU));
          Matrix  XtY   = VMat2Mat(Tra(Tra(_.YplusV)*_.XplusU));
          Matrix  cnstr = Rquadprog::solveQP(XtX, XtY, -Dt, -d,
                                            {[[Real verbose=TRUE]]})[1];
          Mat2VMat(cnstr)
        });
        Real method.ok :=  VMatMax(_.modelDef->A*beta-_.modelDef->a)<=0;
        If(method.ok,
          WriteLn(_MID+"Method "+method.name+" matches constraints."),
          WriteLn(_MID+"Method "+method.name+" DOESN'T match constraints."));
        Real method.num := method.num+1
      });
      beta
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" initialize 0");
    Real initialize.blocks(unused);
  //WriteLn("TRACE"+_MID+" initialize 1");
    VMatrix _.YplusV := _.outMis.blk::filter(_.Y);
  //WriteLn("TRACE"+_MID+" initialize 1.1 _.YplusV("<<VRows(_.YplusV)+"x"<<VColumns(_.YplusV)+")");
    VMatrix _.XplusU := _.inpMis.blk::filter(_.modelDef->X);
  //WriteLn("TRACE"+_MID+" initialize 1.2 _.XplusU("<<VRows(_.XplusU)+"x"<<VColumns(_.XplusU)+")");
    Matrix givenBeta=
    SetCol(EvalSet(_.modelDef->LinearBlock,Real(BSR.LinearBlock b)
    { b->InitialValue }));
    VMatrix beta0 = findMatchingBeta(Mat2VMat(givenBeta));
  //WriteLn("TRACE"+_MID+" initialize 3 beta0("<<VRows(beta0)+"x"<<VColumns(beta0)+")");
    Real ok = _.mln.blk::matchConstrains(beta0, _.modelDef->A, _.modelDef->a);
  //WriteLn("TRACE"+_MID+" initialize 4");
    VMatrix _.beta   := _.mln.blk::_.store;
  //WriteLn("TRACE"+_MID+" initialize 5 _.beta("<<VRows(_.beta)+"x"<<VColumns(_.beta)+")");
    Real DoExternalFilter(0);
    Real If(_.sig.blk::_.partialSampler::_.freeParamNum,
    {
      _.sig.blk::_.buildWorkSpace(_.YplusV - _.XplusU*_.beta)
    });
    VMatrix sig_0 = _.sig.blk::get.draw(0, True);
  //WriteLn("TRACE"+_MID+" initialize 7");
  //WriteLn("TRACE"+_MID+" _.XplusU "<<_.XplusU);
  //WriteLn("TRACE"+_MID+" _.beta "<<_.beta);
    VMatrix _.filter := _.XplusU*_.beta;
  //WriteLn("TRACE"+_MID+" _.filter "<<_.filter);
    VMatrix _.noise := _.YplusV-_.filter;
  //WriteLn("TRACE"+_MID+" _.noise "<<_.noise);
  //WriteLn("TRACE"+_MID+" init 8");
    VMatrix _.residuals := _.arm.blk::filter(_.noise);
  //WriteLn("TRACE"+_MID+" _.residuals "<<_.residuals);
  //WriteLn("TRACE"+_MID+" init 9");
    Real If(_.sig.blk::_.partialSampler::_.freeParamNum,
    {
      Real _.sig.blk::_.buildWorkSpace(_.residuals)
    });
  //WriteLn("TRACE"+_MID+" init 10");
    VMatrix sig_1 = _.sig.blk::get.draw(0, True);
  //WriteLn("TRACE"+_MID+" init 11");
    ok
  };

  ////////////////////////////////////////////////////////////////////////////
  Real setStore(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_.name+"::setStore("<<Rows(values)+"x"<<Columns(values)+")");   
    putStore(values);
    setStore.blocks(values) 
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw =
  "Converts the original regression to standarized noise N(0,I) and "
  "solves it";
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" MasterSamplerBasic::draw 1");
    Real DoExternalFilter(0);
    VMatrix om = If(Not(_.outMis.blk::_.N),
    {
      VMatrix _.YplusV := _.Y;
      Rand(0,1,0,0)
    },
    {
      Real If(_.outMis.blk::_.partialSampler::_.freeParamNum,
      {
        Real _.outMis.blk::_.buildWorkSpace(
          _.arm.blk,_.sig.blk::_.sigmaInv,_.Y-_.XplusU*_.beta)
      });
      VMatrix aux = _.outMis.blk::get.draw(numSim, False);
      VMatrix _.YplusV := _.outMis.blk::filter(_.Y);
      aux
    });
  //WriteLn("TRACE"+_MID+" MasterSamplerBasic::draw 2 om="<<om);
    VMatrix im = If(Not(_.inpMis.blk::_.N),
    {
      VMatrix _.XplusU := _.modelDef->X;
      Rand(0,1,0,0)
    },
    {
      Real If(_.inpMis.blk::_.partialSampler::_.freeParamNum,
      {
        Real _.inpMis.blk::_.buildWorkSpace(
          _.arm.blk,_.sig.blk::_.sigmaInv,_.YplusV-_.modelDef->X*_.beta,_.beta)
      });
      VMatrix aux = _.inpMis.blk::get.draw(numSim, False);
      VMatrix _.XplusU := _.inpMis.blk::filter(_.modelDef->X);
      aux
    });
  //WriteLn("TRACE"+_MID+" MasterSamplerBasic::draw 3 im="<<im);
    VMatrix _.filter := If(Not(_.mln.blk::_.N),
      _.YplusV*0,
      _.XplusU*_.beta);
    VMatrix _.noise := _.YplusV - _.filter;
    VMatrix arm = If(Not(_.arm.blk::_.N),
    {
      VMatrix _.residuals := _.noise;
      Rand(0,1,0,0)
    },
    {
      Real If(_.arm.blk::_.partialSampler::_.freeParamNum,
      {
        Real _.arm.blk::_.buildWorkSpace(_.noise, _.sig.blk::_.store )
      });
      _.arm.blk::get.draw(numSim, False)
    });
    VMatrix _.residuals := _.arm.blk::filter(_.noise);
  //WriteLn("TRACE"+_MID+" MasterSamplerBasic::draw 4 arm="<<arm);
    VMatrix _Y = _.YplusV;
    VMatrix _X = _.XplusU;
    VMatrix sig = If(Not(_.sig.blk::_.N),
    { 
       Rand(0,1,0,0)
    },
    {
      Real If(_.sig.blk::_.partialSampler::_.freeParamNum,
      {
        Real _.sig.blk::_.buildWorkSpace(_.residuals)
      });
      _.sig.blk::get.draw(numSim, False)
    });
    VMatrix si = _.sig.blk::_.sigmaInv;
    VMatrix _Y := si*_Y;
    VMatrix _X := si*_X;
  //WriteLn("TRACE"+_MID+" MasterSamplerBasic::draw 5 sig="<<sig);
    VMatrix _.beta := If(Not(_.mln.blk::_.N),Rand(0,1,0,0),
    {
    //WriteLn("TRACE"+_MID+" MasterSamplerBasic::draw 5.1 _.mln.blk::_.partialSampler::_.freeParamNum="<<_.mln.blk::_.partialSampler::_.freeParamNum);
      Real If(_.mln.blk::_.partialSampler::_.freeParamNum,
      {
        Real _.mln.blk::_.buildWorkSpace(_Y, _X, _.arm.blk)
      });
      _.mln.blk::get.draw(numSim, False)
    });
  //WriteLn("TRACE"+_MID+" MasterSamplerBasic::draw 6 _.beta="<<_.beta);
    VMatrix param = _.beta << sig << arm << im << om;
  //WriteLn("TRACE"+_MID+" MasterSamplerBasic::draw 7 param="<<VRows(param)+"x"<<VColumns(param)+")");
    Real putStoreV(param);
    param
  };


  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setMcmcRow =
  "Set values of all blocks from a given row of a Markov Chain";
  Real setMcmcRow(Matrix mcmc, Real row) 
  ////////////////////////////////////////////////////////////////////////////
  {
    setStore(SubRow(mcmc, [[row]]))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setSegmentInputCol =
  "";
  Real setSegmentInputCol(Matrix Xj, Real segmentNum, Real column)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set equIdx = (_.modelDef->NoiseDistrib)[segmentNum]->EquIdx;
    //VBR: Se asume que las ecuaciones de un segmento son consecutivas!
    PutVMatBlock(_.modelDef->X, equIdx[1], column, Xj)
  };


  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member._eval =
  "Set values of all blocks from a given row vector of values";
  Set _eval(Matrix values, Real useTimeInfo, Real justWithTimeInfo) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" eval 1");
    Real setStore(values);
    Real DoExternalFilter(0);
  //WriteLn("TRACE"+_MID+" eval 2");
    VMatrix _.YplusV := _.outMis.blk::filter(_.Y);
    VMatrix fullOutput.mis = _.outMis.blk::filter(_.Y*0);
  //WriteLn("TRACE"+_MID+" eval 3");
    VMatrix _.XplusU := _.inpMis.blk::filter(_.modelDef->X);
  //WriteLn("TRACE"+_MID+" eval 4");
    VMatrix _.beta := _.mln.blk::_.store;
    VMatrix fullFilter = _.modelDef->X*_.beta;
    VMatrix fullFilter.full = _.XplusU*_.beta;
    VMatrix fullFilter.mis = fullFilter.full - fullFilter;
    VMatrix fullNoise  = _.YplusV - fullFilter.full;
  //WriteLn("TRACE"+_MID+" eval 5");
  //WriteLn("TRACE"+_MID+" eval 6");
    Set all.segments = Range(1,Card(_.arm.blk::_.NoiseDistrib),1);
    Set select = If(!justWithTimeInfo, all.segments, 
      Select(all.segments, Real(Real k)
      {
        Set segment = (_.arm.blk::_.NoiseDistrib)[k];
        Card(segment->TimeInfo)
      }));
    EvalSet(select, Set(Real k)
    {
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].1");
      Set segment = (_.arm.blk::_.NoiseDistrib)[k];
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].2");
      Text name = Replace(segment->Name,"::Noise","");
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].2.1");
      Matrix output_ = VMat2Mat(SubRow(_.modelDef->Y,segment->EquIdx));
      Matrix output.mis_ = VMat2Mat(SubRow(fullOutput.mis,segment->EquIdx));
      Matrix output.extFil = VMat2Mat(SubRow(_.modelDef->Y-_.Y,segment->EquIdx));
      Matrix output.full = output_+output.mis_;
      Matrix output = IfMat(output.mis_,RProd(output_,?),output_);
      Matrix output.mis  = IfMat(output.mis_,output.mis_,RProd(output.mis_,?));
      Matrix filter_ = VMat2Mat(SubRow(fullFilter,segment->EquIdx));
      Matrix filter.mis_ = VMat2Mat(SubRow(fullFilter.mis,segment->EquIdx));
      Matrix filter.full = filter_+filter.mis_;
      Matrix filter = IfMat(filter.mis_,RProd(filter_,?),filter_);
      Matrix filter.mis  = IfMat(filter.mis_,filter.mis_,RProd(filter.mis_,?));
      Matrix noise = VMat2Mat(SubRow(fullNoise,segment->EquIdx));
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].2.2 segment->SigmaIndex="<<segment->SigmaIndex);
      Real sigma  = If(segment->SigmaIndex<=0, 
        VMatDat(segment->L,(segment->EquIdx)[1],(segment->EquIdx)[1]),
        Sqrt(VMatDat(_.sig.blk::_.store,segment->SigmaIndex,1)));
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].2.3");
      Set ti = If(useTimeInfo, segment->TimeInfo, Copy(Empty));
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].3");
      Set arima = segment->Arima;
      Real hasArima = Card(arima)>0;

      Matrix difNoise = noise;
      Matrix residuals = noise;
      Matrix forecast = output.full - noise;
      Real difDeg = 0;
      Real If(hasArima,
      {
        Set aux = segment->ArimaAuxInfo;
        Real m = aux::m;
        Real d = aux::difDegree;
        Real difDeg:=d;
        Real n = m - d;
        Polyn dif  = ARIMAGetDIF(arima);
        Matrix difNoise := Sub(DifEq(dif/1,noise),d+1,1,n,1);
        NameBlock almagro = ARMAProcess::Eval.Almagro(
          aux::ar,aux::ma,Mat2VMat(difNoise),sigma);
        Matrix residuals := VMat2Mat(almagro::_.a);
        Matrix forecast := Sub(output.full,d+1,1,n,1)-residuals;
        1
      });
      Real avr = MatAvr(residuals);
      Real stdErr = Sqrt(MatDat(MtMSqr(residuals),1,1)/Rows(residuals));       

      Set aux = If(Card(ti),
      { 
      //WriteLn("TRACE"+_MID+" eval 7["<<k+"].4");
        Date first = ti->FirstDate;
        Date difFirst = Succ(first, ti->Dating, difDeg);
        Serie serOutput        = MatSerSet(Tra(output),        ti->Dating, first)[1];
        Serie serOutput.extFil = MatSerSet(Tra(output.extFil), ti->Dating, first)[1];
        Serie serOutput.mis    = MatSerSet(Tra(output.mis),    ti->Dating, first)[1];
        Serie serOutput.full   = MatSerSet(Tra(output.full),   ti->Dating, first)[1];
        Serie serFilter        = MatSerSet(Tra(filter),        ti->Dating, first)[1];
        Serie serFilter.mis    = MatSerSet(Tra(filter.mis),    ti->Dating, first)[1];
        Serie serFilter.full   = MatSerSet(Tra(filter.full),   ti->Dating, first)[1];
        Serie serNoise         = MatSerSet(Tra(noise),         ti->Dating, first)[1];
        If(hasArima,
        { 
          Serie serDifNoise  = MatSerSet(Tra(difNoise), ti->Dating, difFirst)[1];
          Serie serResiduals = MatSerSet(Tra(residuals),ti->Dating, difFirst)[1];
          Serie serForecast  = MatSerSet(Tra(forecast), ti->Dating, difFirst)[1];
          [[sigma, stdErr, avr, serOutput, serOutput.mis, serOutput.full, 
            serFilter, serFilter.mis, serFilter.full, serNoise, serForecast,
            serDifNoise, serResiduals, arima]]
        },
        {
          Serie serForecast = MatSerSet(Tra(forecast), ti->Dating, first)[1];
          [[sigma, stdErr, avr, serOutput, serOutput.mis, serOutput.extFil, serOutput.full,
            serFilter, serFilter.mis, serFilter.full, serNoise, serForecast]]
        })
      },
      {
        If(hasArima,
        { 
          [[sigma, stdErr, avr, output, output.extFil, output.mis, output.full, 
            filter, filter.mis, filter.full, noise, forecast,
            difNoise, residuals, arima]]
        },
        {
          [[sigma, stdErr, avr, output, output.extFil, output.mis, output.full, 
            filter, filter.mis, filter.full, noise, forecast]]
        })
      });
      Real SetIndexByName(aux);
      Eval(name+"=aux")
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.eval =
  "Set values of all blocks from a given row vector of values";
  Set eval(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Real setStore(values);
    _eval(values, True, False)
  };
/*
  VBR: no está acabada aún.
  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.forecast.bands =
  "";
  Set forecast.bands(Matrix param.mcmc, Real confidence) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Real q = (1-confidence)/2;
    Set evals = Traspose(For(1,Rows(param.mcmc),Set(Real r)
    {
      _eval(SubRow(param.mcmc,[[r]]), True, True)
    }));
    For(1,Card(_.arm.blk::_.NoiseDistrib), Set(Real k)
    {
      Set segment = (_.arm.blk::_.NoiseDistrib)[k];
    //WriteLn("TRACE"+_MID+" eval 7["<<k+"].2");
      Text name = Replace(segment->Name,"::Noise","");
      Matrix forecast = SerMat((evals[k])::serForecast);
      Matrix bands = Group("ConcatColumns",
      For(1,Columns(forecast.mcmc),Matrix(Real c)
      {
        Matrix C = SubCol(forecast.mcmc,[[c]]);
        Real q1  = MatQuantile(C,  q);
        Real avg = MatAvg(C);
        Real q2  = MatQuantile(C,1-q);
        Col(q1,avg,q2)
      }));
      Set series = MatSerSet(bands,Dating())
      Set aux = 
      [[
        (evals[k])::serOutput.full,
        (evals[k])::serForecast
      Eval()
    })
  };
*/
  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getRegEquBlock =
  "Gets the index of a regression equation block specified by its name or "
  "position.\n"
  "If the specified name is not found or the position is out of range no "
  "block will be referenced and an error message will be shown";
  Real getRegEquBlock(Anything resBlock)
  ////////////////////////////////////////////////////////////////////////////
  {
    Text g = Grammar(resBlock);
    Case
    (
      g=="Real", 
      {
        Real n = Card(_.modelDef->NoiseDistrib);
        If(And(resBlock<=n,resBlock>=1), resBlock, 
        {
          Real CMsg::Coded::show(BysMcmc::_.cmsg::_.indexOutOfRange,
            [[_MID+"::getRegEquBlock", resBlock, 1, n]]),
          -1
        })
      },
      g=="Text", 
      {
        Real f = FindIndexByName(_.modelDef->NoiseDistrib,resBlock);
        If(f, f, 
        {
          Real CMsg::Coded::show(BysMcmc::_.cmsg::_.notFoundName,
            [[_MID+"::getRegEquBlock",resBlock]]),
          -1
        })
      },
      1==1,      
      {
        Real CMsg::Coded::show(BysMcmc::_.cmsg::_.invalidType,
            [[_MID+"::getRegEquBlock",resBlock]]),
        -2
      }
    )
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.subRegEquBlockV =
  "Extracts from a matrix A the rows corresponding to a block of regression "
  "equations specified by resBlock as is described in method getRegEquBlock";
  VMatrix subRegEquBlockV(Anything resBlock, VMatrix A)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real blk = getRegEquBlock(resBlock);
    SubRow(A,(_.modelDef->NoiseDistrib)[blk]->EquIdx)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.subDifRegEquBlockV =
  "Extracts from a matrix A the rows corresponding to a block of regression "
  "equations specified by resBlock as is described in method getRegEquBlock, "
  "and applys the corresponding ARIMA difference filter if exists.";
  VMatrix subDifRegEquBlockV(Anything resBlock, VMatrix A)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real blk = getRegEquBlock(resBlock);
    Set segment = (_.modelDef->NoiseDistrib)[blk];
    Set aux = segment->ArimaAuxInfo;
    If(Not(aux::difDegree), SubRow(A,segment->EquIdx),
    {
      VMatrix D  = (segment->ArimaAuxInfo)::D;
      VMatrix A_ = SubRow(A,segment->EquIdx); 
      VMatrix DA = D*A_;
      SubRow(DA,Range(aux::difDegree+1,aux::m,1))
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.subRegEquBlock =
  "Extracts from a matrix A the rows corresponding to a block of regression "
  "equations specified by resBlock as is described in method getRegEquBlock";
  Matrix subRegEquBlock(Anything resBlock, Matrix A)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real blk = getRegEquBlock(resBlock);
    SubRow(A,(_.modelDef->NoiseDistrib)[blk]->EquIdx)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.subDifRegEquBlock =
  "Extracts from a matrix A the rows corresponding to a block of regression "
  "equations specified by resBlock as is described in method getRegEquBlock, "
  "and applys the corresponding ARIMA difference filter if exists.";
  Matrix subDifRegEquBlock(Anything resBlock, Matrix A)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real blk = getRegEquBlock(resBlock);
    Set segment = (_.modelDef->NoiseDistrib)[blk];
    Set aux = segment->ArimaAuxInfo;
    DifEq(aux::dif/1,SubRow(A,segment->EquIdx))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getInput =
  "Returns original input matrix filtered by current missing block values "
  "for a block of regression equations specified by resBlock as is described "
  "in method getRegEquBlock";
  Matrix getInput(Anything resBlock, Set beta.index)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix X_U = _.inpMis.blk::filter(_.modelDef->X);
    VMatrix X = SubCol(X_U,beta.index);
    VMat2Mat(subRegEquBlockV(resBlock, X))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getOutput =
  "Returns original output matrix filtered by current missing block values "
  "for a block of regression equations specified by resBlock as is described "
  "in method getRegEquBlock";
  Matrix getOutput(Anything resBlock)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix Y = _.outMis.blk::filter(_.modelDef->Y);
    VMat2Mat(subRegEquBlockV(resBlock, Y))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getNoise =
  "Returns integrated noise for a given vector of linear block parameters "
  "Y-X*b for a block of regression equations specified by resBlock as is "
  "described in method getRegEquBlock";
  Matrix getNoise(Anything resBlock, Set beta.index, Matrix beta)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real blk = getRegEquBlock(resBlock);
    Matrix X = getInput(blk, beta.index);
    Matrix Y = getOutput(blk);
    Y-X*beta
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getDifInputFull =
  "Returns differenced input matrix filtered by current missing block "
  "values D(B)*X for full block of regression equations specified by resBlock "
  "as is described in method getRegEquBlock";
  Matrix getDifInputFull(Anything resBlock)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix X_U = _.inpMis.blk::filter(_.modelDef->X);
    VMat2Mat(subDifRegEquBlockV(resBlock, X_U))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getDifInput =
  "Returns differenced input matrix filtered by current missing block "
  "values D(B)*X for a block of regression equations specified by resBlock "
  "as is described in method getRegEquBlock";
  Matrix getDifInput(Anything resBlock, Set beta.index)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix X_U = _.inpMis.blk::filter(_.modelDef->X);
    VMatrix X = SubCol(X_U,beta.index);
    VMat2Mat(subDifRegEquBlockV(resBlock, X))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getDifOutput =
  "Returns differenced output matrix filtered by current missing block "
  "values D(B)*Y for a block of regression equations specified by resBlock "
  "as is described in method getRegEquBlock";
  Matrix getDifOutput(Anything resBlock)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix Y_V = _.outMis.blk::filter(_.modelDef->Y);
    VMat2Mat(subDifRegEquBlockV(resBlock, Y_V))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getDifNoise =
  "Returns differenced noise for a given vector of linear block parameters "
  "D(B)*Y - D(B)*X*b for a block of regression equations specified by "
  "resBlock as is described in method getRegEquBlock";
  Matrix getDifNoise(Anything resBlock, Set beta.index, Matrix beta)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real blk = getRegEquBlock(resBlock);
    Matrix X = getDifInput(blk, beta.index);
    Matrix Y = getDifOutput(blk);
    Y-X*beta
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getResiduals =
  "Returns residuals for a given vector of linear block parameters "
  "(D(B)*phi(B)/theta(B))*(Y-X*b) for a block of regression equations "
  "specified by resBlock as is described in method getRegEquBlock";
  Matrix getResiduals(Anything resBlock, Set beta.index, Matrix beta)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real    blk = getRegEquBlock(resBlock);
    Set     segment  = (_.modelDef->NoiseDistrib)[blk];
    Matrix  Z   = getNoise(blk, beta.index, beta);
    Set     ev  = ARIMALevinsonEval(segment->Arima, Z);
    ev::a
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.timeForecast =
  "Returns time forecast for a block of regression equations representing a "
  "time series with unknown sigma and optional ARIMA structure.\n"
  "The block of equations is the specified by resBlock as is described "
  "in method getRegEquBlock.";
  Matrix timeForecast.mcmc(Matrix   mcmc, 
                           Anything resBlock, 
                           Set      beta.idx,
                           Matrix   inputForecast)
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::BlockSampler lin = _.mln.blk;
    BysMcmc::BlockSampler sig = _.sig.blk;

    Real blk = getRegEquBlock(resBlock);
    Real T = Rows(inputForecast);
    Real N = Rows(mcmc);
    Set  segment = (_.modelDef->NoiseDistrib)[blk];
    Set aux = segment->ArimaAuxInfo;
    Real sigmaIndex = segment->SigmaIndex;
    Set sigma.names = [[segment->SigmaName]];
    Set sigma.idx = sig::getMcmcColIndexes(sigma.names);
    Matrix s.mcmc = Sqrt(SubCol(mcmc,sigma.idx));
    Matrix beta.mcmc = SubCol(mcmc,beta.idx);
    Matrix X_b.mcmc = beta.mcmc*Tra(inputForecast);
    Matrix noise_.mcmc = If(Or(aux::difDegree,aux::p,aux::q),
    {
      Real pd = aux::p+aux::difDegree;
      Real m  = aux::m;
      Set pdEquIdx = ExtractByIndex(segment->EquIdx, Range(m-pd+1,m,1));

      Matrix X0 = VMat2Mat(SubCol(SubRow(_.modelDef->X, pdEquIdx),beta.idx));
      Matrix Y0 = VMat2Mat(       SubRow(_.modelDef->Y, pdEquIdx));
      Group("ConcatRows",For(1,N,Matrix(Real numSim)
      {
        Real   s  = MatDat(s.mcmc,numSim,1);
        Matrix E0 = Gaussian(aux::q,1,0,s);
        Matrix E  = Gaussian(T,     1,0,s);
        Matrix Z0 = Y0-X0*Tra(SubRow(beta.mcmc,[[numSim]]));
        Matrix Z  = _.arm.blk::difEq.ARI.MA(blk,E,E0,Z0);
        Tra(Z)
      }))
    },
    {
      Group("ConcatColumns",For(1,T,Matrix(Real t)
      {
        Gaussian(N,1,0,1) $* s.mcmc
      }))
    });
    X_b.mcmc + noise_.mcmc
  }
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.BasicMaster =
"Builds a NameBlock that can draw a Gibbs sample of a Bayesian Sparse "
"Regression model";
MasterSamplerBasic BasicMaster(BSR.ModelDef modelDef, 
                          BysMcmc::McmcPartialHandler mcmcPartialHandler,
                          Real numBlock, 
                          Real firstCol,
                          BysMcmc::Config config)
//////////////////////////////////////////////////////////////////////////////
{
  Text name = modelDef->DocInfo->Model.Name; 
  BysMcmc::Bsr::Gibbs::MasterSamplerBasic master = [[

  //--------------------------------------------------------------------------
  // Read only members
  //--------------------------------------------------------------------------

  //Internal reference to model definition
  Set _.modelDef = modelDef;
  //External filter of output
  Set _.externalFilter = Copy(Empty);
  //Output after external filters
  VMatrix _.Y = _.modelDef->Y;

  BysMcmc::McmcPartialHandler _.mcmcPartialHandler = mcmcPartialHandler;

  //Setting NameBlock description
  Text _.autodoc.description="Gibbs sampler for model "+name;
  BysMcmc::Bsr::Gibbs::BlockSamplerStdLinear _.mln.blk = 
  BysMcmc::Bsr::Gibbs::MainLinearBlock
  (
    "BSR.MainLinBlock."+name,
    EvalSet(_.modelDef->LinearBlock, Text(BSR.LinearBlock b){ b->Name }),
    mcmcPartialHandler,
    1,
    firstCol,
    config
  );
  BysMcmc::Bsr::Gibbs::BlockSamplerSigma _.sig.blk = 
  BysMcmc::Bsr::Gibbs::SigmaBlock
  (
    "BSR.SigmaBlock."+name,
    _.modelDef->NoiseDistrib,
    mcmcPartialHandler,
    2,
    _.mln.blk::_.lastCol+1,
    config
  );
  BysMcmc::Bsr::Gibbs::BlockSamplerArima _.arm.blk = 
  BysMcmc::Bsr::Gibbs::ArimaBlock
  (
    "BSR.ArimaBlock."+name,
    _.modelDef->NoiseDistrib,
    mcmcPartialHandler,
    3, 
    _.sig.blk::_.lastCol+1,
    config
  );

  BysMcmc::Bsr::Gibbs::BlockSamplerStdLinear _.inpMis.blk = 
  BysMcmc::Bsr::Gibbs::InputMissingBlock
  (
    "BSR.InputMissingBlock."+name,
    _.modelDef->InputMissingBlock,
    mcmcPartialHandler,
    4,
    _.arm.blk::_.lastCol+1,
    config
  );

  BysMcmc::Bsr::Gibbs::BlockSamplerStdLinear _.outMis.blk = 
  BysMcmc::Bsr::Gibbs::OutputMissingBlock
  (
    "BSR.OutputMissingBlock."+name,
    _.modelDef->OutputMissingBlock,
    mcmcPartialHandler,
    5,
    _.inpMis.blk::_.lastCol+1,
    config
  );

  Set _.blocks =
  [[
    _.mln.blk,
    _.sig.blk,
    _.arm.blk,
    _.inpMis.blk,
    _.outMis.blk
  ]];

  Real _defined = define(
    name,
    get.colNames(0),
    _.mcmcPartialHandler,
    numBlock,
    firstCol,
    config)

]]};      
