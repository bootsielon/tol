/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// MODULE: Stat (Statistics)
// FILE: _oneNode.tol
// PURPOSE: Estimation methods for simplified models with just one node
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
NameBlock OneNode =
/////////////////////////////////////////////////////////////////////////////
[[
  //read only autodoc
  Text _.autodoc.description =
  "Estimation methods for simplified BSR models with just one node.";

  //Tool function to reduce registers length in _.linearParamInfo
  Set LPI(
    Text Name,              // Unique identidier of the parameter
    Real InitValue,         // Given by user initial value or ?
    Real Prior.LowerBound,  // Minimum feasible value or -1/0
    Real Prior.UpperBound,  // Maximum feasible value or +1/0
    Real Prior.Average,     // Normal prior average
    Real Prior.Sigma,       // Normal prior standard deviation 
    Real Prior.SigmaWeight)       // Normal prior weight
  {
    Bsr.OneNode.LinearParamInfo(
      Text Name,              
      Real InitValue,         
      Real Prior.LowerBound,  
      Real Prior.UpperBound,  
      Real Prior.Average,
      Real Prior.Sigma,
      Real Prior.SigmaWeight,
      Real Prior.Missing.SigmaFactor=?, //Already not implemented
      Real Prior.Missing.LowerBound=?,  //Already not implemented
      Real Prior.Missing.UpperBound=?)  //Already not implemented
  };

  ///////////////////////////////////////////////////////////////////////////
  Class ModelData
  ///////////////////////////////////////////////////////////////////////////
  {
    Code LPI = BysMcmc::Bsr::OneNode::LPI;
  //Mandatory members
    Set  _.docInfo;        //BSR.DocInfo
    Set _.linearParamInfo; //Set of Bsr.OneNode.LinearParamInfo
    VMatrix _.Y;           //Output data 
    VMatrix _.X;           //Input data  
    Real _.sigma;          //Sigma prior value, or ? to freely simulate it
  //Optional members 
    Text _.segmentName = "Obs";        //Node name
    Set _.orderRelation = Copy(Empty); //Set of Bsr.OrderRelation.Info\n"
    Set _.arima  = Copy(Empty);        //Set of ARIMAStruct\n"
    Real _.sigmaPriorWeight = 0;       //Weight for Bsr.Sigma.Prior.InverseGamma\n"
    Set _.timeInfo = Copy(Empty)       //BSR.NoiseTimeInfo\n"
  };

  ///////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.GetCycler = 
  "Creates a BysMcmc:Cycler for a generic OneNode model\n" 
  "Model must have just one node, usually observational and dense."
  "Model is defined as a BSR basic and an optional set of non linear filters."
  "BSR will be built from simplified data argument";
  Cycler GetCycler(ModelData data, Set nonLinFil, Config config_)
  ///////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[BysMcmc::Bsr::OneNode::GetCycler]";
  //WriteLn(_MID+" TRACE 1");
    //Output matrix
    VMatrix Y = data::_.Y;
  //WriteLn(_MID+" TRACE 2");
    //Input matrix
    VMatrix X = data::_.X;

  //WriteLn(_MID+" TRACE 3");
    //Observational data length
    Real m = VRows(Y);
    //Number of variables at linear block 
    Real n = VColumns(X);

    //Used to collect prior information if exists
    Real prior.num = 0;
    VMatrix prior.Y = Rand(0,1,0,0);
    Matrix prior.X.triplet = Rand(0,3,0,0);
    Set prior.index = Copy(Empty);
    //Used to collect domain information if exists
    Real domain.num = 0;
    VMatrix domain.a = Rand(0,1,0,0);
    Matrix  domain.A.triplet = Rand(0,3,0,0);
    
  //WriteLn(_MID+" TRACE 4");
    //Builds linear block and collects prior and domain information
    Set linearBlock = For(1,n, Set(Real j)
    {
      Set pi = (data::_.linearParamInfo)[j];
      Set aux = [[BSR.LinearBlock(pi->Name, pi->InitValue)]];
    //WriteLn(_MID+" TRACE 4.["<<j+"].1");
      Real prior.Average = If(ObjectExist("Real","pi->Prior.Average"),
                              pi->Prior.Average, ?);
      Real estimSigma = IsUnknown(pi->Prior.Sigma) | 
                       !IsUnknown(pi->Prior.SigmaWeight);
      Real If(!IsUnknown(prior.Average),
      {
        Set Append(prior.index,[[j]]);
        //Collecting prior information
        Real prior.num := prior.num+1;
        Real factor = If(estimSigma,1,1/pi->Prior.Sigma);
        VMatrix prior.Y := prior.Y << 
          Mat2VMat(Row(pi->Prior.Average*factor));
        Matrix prior.X.triplet := 
          prior.X.triplet << Row(prior.num,j,factor);
        0
      });
    //WriteLn(_MID+" TRACE 4.["<<j+"].2");
      Real prior.LowerBound = If(ObjectExist("Real","pi->Prior.LowerBound"),
                              pi->Prior.LowerBound, -1/0);
      Real If(!IsUnknown(prior.LowerBound) & GT(prior.LowerBound,Real -1/0),
      {
        //Collecting domain lower limits
        Real domain.num := domain.num+1;
        VMatrix domain.a := domain.a << Mat2VMat(Row(-pi->Prior.LowerBound));
        Matrix domain.A.triplet := domain.A.triplet << Row(domain.num,j,-1);
        0
      });
    //WriteLn(_MID+" TRACE 4.["<<j+"].3");
      Real prior.UpperBound = If(ObjectExist("Real","pi->Prior.UpperBound"),
                              pi->Prior.UpperBound, +1/0);
      Real If(!IsUnknown(prior.UpperBound) & LT(prior.UpperBound,Real +1/0),
      {
        //Collecting domain upper limits
        Real domain.num := domain.num+1;
        VMatrix domain.a := domain.a << Mat2VMat(Row(+pi->Prior.UpperBound));
        Matrix domain.A.triplet := domain.A.triplet << Row(domain.num,j,+1);
        0
      });
    //Setting name of variables to allow hashed searching
      Set PutName(pi->Name,aux[1]); 
      aux[1]
    });
    //Checks unique name and prepares for hashed searching by name
    Real SetIndexByName(linearBlock);
  //WriteLn(_MID+" TRACE 5");
    //Domain constraints
    VMatrix domain.A = Triplet(domain.A.triplet,domain.num,n);
    //Building order relations if exist
    Set orderRelation = If(ObjectExist("Set","data::_.orderRelation"),
                           data::_.orderRelation, Copy(Empty)); 
    Real order.num = Card(orderRelation);
    VMatrix order.a = Rand(order.num,1,0,0);
    VMatrix order.A = If(!order.num,Rand(0,n,0,0),
    {
      Matrix triplet = Group("ConcatRows",For(1,order.num,Matrix(Real k)
      {
        Set rel = orderRelation[k];
        Real lower = FindIndexByName(linearBlock, rel->Lower);
        If(!lower,WriteLn("Cannot create order relation. "
                          "Variable "+rel->Lower+" was not found","E"));
        Real upper = FindIndexByName(linearBlock, rel->Upper);
        If(!upper,WriteLn("Cannot create order relation. "
                          "Variable "+rel->Upper+" was not found","E"));
        Row(k,lower,+1) << 
        Row(k,upper,-1) 
      }));
      Triplet(triplet,order.num,n)
    });

    Real m.full = m+prior.num;

  //WriteLn(_MID+" TRACE 6");
    //Observational information
    Real sigmaIsUnknown = IsUnknown(data::_.sigma);
    Set noiseObs = {[[
      BSR.NoiseDistrib(
        Text Name = data::_.segmentName+"::Noise";
        Real Nu = 0;
        Text SigmaName = If(sigmaIsUnknown,data::_.segmentName+"::Sigma","");
        Real SigmaIndex = If(sigmaIsUnknown,1,-1);
        Set SigmaPrior = Copy(Empty);
        Set arima = If(ObjectExist("Set","data::_.arima"),
          data::_.arima, Copy(Empty));
        Set ArimaAuxInfo = Copy(Empty);
        VMatrix Cov = Eye(m.full,m.full,0,Rand(m,1,1,1)<<Rand(prior.num,1,0,0));
        VMatrix L = Cov;
        VMatrix Li = Cov;
        Set EquIdx = Range(1,m,1);
        Set TimeInfo = If(ObjectExist("Set","data::_.timeInfo"),
          data::_.timeInfo, Copy(Empty)),
        Set NonLinFilters = nonLinFil
      )
    ]]};

  //WriteLn(_MID+" TRACE 7");
    //Prior information
    VMatrix prior.X = Triplet(prior.X.triplet,prior.num,n);
    Real sigmaIndex = If(sigmaIsUnknown,1,0);
    Set noisePrior = For(1,Card(prior.index),Set(Real j)
    {
      Set pi = (data::_.linearParamInfo)[prior.index[j] ];
      Real estimSigma = IsUnknown(pi->Prior.Sigma) | 
                       !IsUnknown(pi->Prior.SigmaWeight);
      Real sigmaIndex := sigmaIndex + estimSigma;

      Set SigmaPrior = If(IsUnknown(pi->Prior.SigmaWeight),Copy(Empty),
        Bsr.Sigma.Prior.InverseGamma(pi->Prior.Sigma,pi->Prior.SigmaWeight));
      Real cov.value = If(estimSigma, 1, pi->Prior.Sigma);
      Real L.value   = If(estimSigma, 1, Sqrt(pi->Prior.Sigma));
      Real Li.value  = If(estimSigma, 1, 1/Sqrt(pi->Prior.Sigma));
      VMatrix z1 = Rand(m+j-1,1,0,0);
      VMatrix z2 = Rand(m.full-(j+m),1,0,0);
      VMatrix cov.diag = Tra(z1<<Mat2VMat(Col(cov.value))<<z2);
      VMatrix L.diag   = Tra(z1<<Mat2VMat(Col(L.value  ))<<z2);
      VMatrix Li.diag  = Tra(z1<<Mat2VMat(Col(Li.value ))<<z2);
      Set BSR.NoiseDistrib(
        Text Name = data::_.segmentName+".Prior::Noise";
        Real Nu = 0;
        Text SigmaName = If(!estimSigma,"","Pri."+pi->Name+"::Sigma");
        Real SigmaIndex = Copy(sigmaIndex);
        Set SigmaPrior,
        Set arima = Copy(Empty);
        Set ArimaAuxInfo = Copy(Empty);
        VMatrix Cov = Eye(m.full,m.full,0,cov.diag);
        VMatrix L   = Eye(m.full,m.full,0,L.diag);
        VMatrix Li  = Eye(m.full,m.full,0,Li.diag);
        Set EquIdx = SetOfReal(m+j);
        Set TimeInfo = Copy(Empty)
      )
   });

  //WriteLn(_MID+" TRACE 8");
    //All allowed segments in this simplified API are obs and prior (optionally)
    Set noiseDistrib_ = noiseObs << noisePrior;
    //Setting name of segments to allow hashed searching
    Set noiseDistrib = For(1,Card(noiseDistrib_), Set(Real k)
    {
      Set PutName(noiseDistrib_[k]->Name,noiseDistrib_[k]);
      noiseDistrib_[k]
    });
    //Checks unique name and prepares for hashed searching by name
    Real SetIndexByName(noiseDistrib);
  //WriteLn(_MID+" TRACE 9");
    //Building generic model definition
    Set modelDef = BSR.ModelDef (
      "joint",
      docInfo = data::_.docInfo,
      linearBlock,
      Set inputMissing  = If(ObjectExist("Set","data::_.inputMissing"),
                             data::_.inputMissing, Copy(Empty));
      Set outputMissing = If(ObjectExist("Set","data::_.outputMissing"),
                             data::_.outputMissing, Copy(Empty));
      noiseDistrib,
      VMatrix Y.full = Y << prior.Y,
      VMatrix X.full = X << prior.X,
      VMatrix a = domain.a << order.a,
      VMatrix A = domain.A << order.A
    );
    BysMcmc::Cycler cycler = BysMcmc::Bsr::Gibbs::GetCyclerFromParsed
   (
      modelDef,
      BysMcmc::McmcPartialHandler::Null(0),
      config_,
      BysMcmc::Notifier::Null(0)
    );
    Set Append(cycler::auxInfo,[[data]]);
  //WriteLn(_MID+" TRACE 12");
    cycler
  };

  ///////////////////////////////////////////////////////////////////////////
  Class Probit
  ///////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Estimation _.estim;
    Matrix _.param;
    
    //////////////////////////////////////////////////////////////////////////
    Text _.autodoc.member.GetProbPoint =
    "Returns output probabilities for given input matrix and parameters "
    "vector"; 
    Matrix GetProbPoint(Matrix X, Matrix beta)
    //////////////////////////////////////////////////////////////////////////
    { 
      F01(X*beta)
    };
    //////////////////////////////////////////////////////////////////////////
    Text _.autodoc.member.GetProbAvg =
    "Returns output probabilities for given input matrix and average vector "
    "of simulated parameters"; 
    Matrix GetProbAvg(Matrix X)
    //////////////////////////////////////////////////////////////////////////
    { 
      GetProbPoint(X,_.param)
    };
    //////////////////////////////////////////////////////////////////////////
    Text _.autodoc.member.GetProb =
    "Returns output probabilities for given input matrix integrated "
    "over all simulated vectors of parameters"; 
    Matrix GetProb(Matrix X)
    ////////////////////////////////////////////////////////////////////////
    { 
      Real numSim = Rows(_.estim::report::mcmc);
      Matrix prob = Rand(Rows(X),1,0,0);
      Set For(1,numSim,Real (Real sim)
      {
        Matrix pr=GetProbPoint(X,Tra(SubRow(_.estim::report::mcmc,[[sim]])));
        Matrix prob := prob + pr;
        0
      });
      prob*(1/numSim)
    }
  };

  ///////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.GetCyclerProbit = 
  "Creates a BysMcmc:Cycler for a probit OneNode model\n" 
  "Model is defined as a BSR basic and an non linear ProbitFilter.";
  Cycler GetCyclerProbit(ModelData data, Config config_)
  //////////////////////////////////////////////////////////////////////////////
  {
    //All methods are performed for being _.sigma=1
    Real data::_.sigma:=1;
    Set nonLinFil = {[[
    //Filtro no lineal del output para el modelo probit
    NameBlock probitFilter = BysMcmc::Bsr::Gibbs::ProbitFilter(
      Real enabled = True,
      data::_.segmentName,
      VMat2Mat(data::_.Y),
      UnknownDate,
      UnknownDate)
    ]]};
    BysMcmc::Cycler cycler = BysMcmc::Bsr::OneNode::GetCycler
      (data, nonLinFil, config_);
    cycler
  };

  ///////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.GetProbit = 
  "Creates a BysMcmc::Bsr::OneNode::Probit object from an estimated model";
  Probit GetProbit(Estimation estim)
  //////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::OneNode::Probit probit = 
    [[
      BysMcmc::Estimation _.estim = estim;
      Matrix _.param = If(Not(_.estim::cycler::_.config::mcmc.sampleLength), 
                          Rand(0,0,0,0),
                          Tra(_.estim::param.average))
    ]]
  }

]];
