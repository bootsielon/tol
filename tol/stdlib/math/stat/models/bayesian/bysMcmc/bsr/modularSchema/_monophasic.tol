/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// FILE: _monophasic.tol
// PURPOSE: Converts a master modular schema in a simple joint module
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
NameBlock Monophasic = 
/////////////////////////////////////////////////////////////////////////////
[[
  //////////////////////////////////////////////////////////////////////////
  @BSR.ModelDef childToJoint(Set module)
  //////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE ChildToJoint module "+module->ModuleType+" "+Name(module));
    If(module->ModuleType!="master", module, 
       BysMcmc::Bsr::ModularSchema::Monophasic::MasterToJoint(module))
  };
  //////////////////////////////////////////////////////////////////////////
  @BSR.ModelDef MasterToJoint(Set master)
  //////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[MasterToJoint]";
  //WriteLn("TRACE MasterToJoint module "+master->ModuleType+" "+Name(master));
    Set subModule = EvalSet(master->SubModule, childToJoint);
    Case(
    Card(subModule)==0, {
      WriteLn(_MID+" Master "+master->DocInfo->Path+" has no submodule","E");
      Copy(Empty)
    }, 
    Card(subModule)==1, {
      @BSR.ModelDef(
        subModule[1]->ModuleType;
        master->DocInfo;
        subModule[1]->LinearBlock;
        subModule[1]->InputMissingBlock;
        subModule[1]->OutputMissingBlock;
        subModule[1]->NoiseDistrib;
        Y=Convert(subModule[1]->Y,"Blas.R.Dense");
        subModule[1]->X;
        subModule[1]->a;
        subModule[1]->A)
    }, 
    1==1, {
  //WriteLn("TRACE MasterToJoint 1");
    Set LinearBlock = 
    {
      Set aux.1 = EvalSet(subModule, Set(@BSR.ModelDef module)
      {
        Set sel = Select(module->LinearBlock, Real(@BSR.LinearBlock v)
        {
          Not(v->Extern)
        })
      });
      Set aux.2 = Unique(BinGroup("<<", aux.1));
      Real SetIndexByName(aux.2);
      aux.2 
    };  
    Real n = Card(LinearBlock);
  //WriteLn("TRACE MasterToJoint 2");
    Set col.index = EvalSet(subModule, Matrix(@BSR.ModelDef module)
    {
      Set index = EvalSet(module->LinearBlock,Real(@BSR.LinearBlock v)
      {
        Text name = Name(v);
        Real idx = FindIndexByName(LinearBlock, name);
        If(!idx, WriteLn(_MID+" Cannot resolve symbol of external linear variable "
        "\n  "+v->Name+
        "\nused in module \n  "+module->DocInfo->Path,"E"));
      //WriteLn("  Index("+name+")="<<idx);
        idx
      });
      SetCol(index)
    });
  //WriteLn("TRACE MasterToJoint 3");
    Real m = 0;
    Set row.index = EvalSet(subModule, Set(@BSR.ModelDef module)
    {
      Real Y.rows = VRows(module->Y);
      Real A.rows = VRows(module->A);
      If(!Y.rows & !A.rows,
      {
        WriteLn(_MID+" Submodule "+module->DocInfo->Path+" has no "
        "equation nor inequation","E")
      });
      Real r0 = m+1;
      Real m := m+Y.rows;
      Range(r0,m,1)
    });
    Real missingInputBlock.index = 0;
    Real missingOutputBlock.index = 0;

  //WriteLn("TRACE MasterToJoint 4");
    Set reDim = Traspose(For(1,Card(subModule), Set(Real k)
    {
      @BSR.ModelDef module = subModule[k];
    //WriteLn("TRACE MasterToJoint 5.1 subModule "<<k);
      Real mk = Card(row.index[k]);
      Real m0 = If(!Card(row.index[k]),0,row.index[k][1]);

    //WriteLn("TRACE MasterToJoint 5.2");
      Set prc.mis.in(@BSR.MissingBlock mis)
      {@BSR.MissingBlock(
        Text Name = mis->Name;
        Real Index = Copy(missingInputBlock.index := missingInputBlock.index+1);
        Real Row = row.index[k][mis->Row];
        Real Col = MatDat(col.index[k],mis->Col,1);
        Text Prior = mis->Prior;
        Real Nu = mis->Nu;
        Real Sigma2 = mis->Sigma2;
        Real MinBound = mis->MinBound;
        Real MaxBound = mis->MaxBound
      )};
      
    //WriteLn("TRACE MasterToJoint 5.3");
      Set prc.mis.out(@BSR.MissingBlock mis)
      {@BSR.MissingBlock(
        Text Name = mis->Name;
        Real Index = Copy(missingOutputBlock.index := missingOutputBlock.index+1);
        Real Row = row.index[k][mis->Row];
        Real Col = 1;
        Text Prior = mis->Prior;
        Real Nu = mis->Nu;
        Real Sigma2 = mis->Sigma2;
        Real MinBound = mis->MinBound;
        Real MaxBound = mis->MaxBound
      )};
      
    //WriteLn("TRACE MasterToJoint 5.4");
      Set MissingInputBlock = EvalSet(module->InputMissingBlock,prc.mis.in);
    //WriteLn("TRACE MasterToJoint 5.5");
      Set MissingOutputBlock = EvalSet(module->OutputMissingBlock,prc.mis.out);
    //WriteLn("TRACE MasterToJoint 5.6");
      Set NoiseDistrib = EvalSet(module->NoiseDistrib,Set(@BSR.NoiseDistrib seg)
      {
        Set aux = [[ @BSR.NoiseDistrib(
          Text seg->Name;
          Real seg->Nu;
          Text seg->SigmaName;
          Real seg->SigmaIndex;
          Set seg->SigmaPrior;
          Set seg->Arima;
          Set seg->ArimaAuxInfo;
          VMatrix Cov=Convert(Enlarge(seg->Cov,m,m,m0,m0),"Cholmod.R.Sparse");
          VMatrix L  =Convert(Enlarge(seg->L,  m,m,m0,m0),"Cholmod.R.Sparse");
          VMatrix Li =Convert(Enlarge(seg->Li, m,m,m0,m0),"Cholmod.R.Sparse");
          Set EquIdx = ExtractByIndex(row.index[k],seg->EquIdx);
          Set seg->TimeInfo;
          Set seg->NonLinFilters
        ) ]];
        Set PutName(seg->Name,aux[1]);
        aux[1]
      });
    //WriteLn("TRACE MasterToJoint 5.7");
      {[[
        Set MissingInputBlock;
        Set MissingOutputBlock;
        Set NoiseDistrib;
        VMatrix Y = Convert(If(!VRows(module->Y),Rand(0,1,0,0),module->Y),"Blas.R.Dense");
        VMatrix X = If(!VRows(module->X),Rand(0,n,0,0),
          Tra(MergeRows(n,[[ [[Tra(module->X), col.index[k] ]] ]])));
        VMatrix a = If(!VRows(module->a),Rand(0,1,0,0),module->a);
        VMatrix A = If(!VRows(module->A),Rand(0,n,0,0),
         Tra(MergeRows(n,[[ [[Tra(module->A), col.index[k] ]] ]])))
      ]]}
    }));
  //WriteLn("TRACE MasterToJoint 6");
    Text ModuleType = "joint";
    Set MissingInputBlock = BinGroup("<<",reDim[1]);
    Set MissingOutputBlock = BinGroup("<<",reDim[2]);
    Set NoiseDistrib = BinGroup("<<",reDim[3]);
    Real sigmaIndex = 0;
    Set EvalSet(NoiseDistrib,Real (@BSR.NoiseDistrib seg)
    {
      Real If(seg->SigmaIndex<=0,seg->SigmaIndex, 
      { 
        sigmaIndex:=sigmaIndex+1;
        seg->SigmaIndex := Copy(sigmaIndex)
      })
    });
  //WriteLn("TRACE MasterToJoint 7.1");
    VMatrix Y = Convert(Group("ConcatRows",reDim[4]),"Blas.R.Dense");
  //WriteLn("TRACE MasterToJoint 7.2");
  //VMatrix X = Convert(Group("ConcatRows",reDim[5]),"Cholmod.R.Sparse");
    VMatrix X = Group("ConcatRows",reDim[5]);
  //WriteLn("TRACE MasterToJoint 7.3");
    VMatrix a = Convert(Group("ConcatRows",reDim[6]),"Cholmod.R.Sparse");
  //WriteLn("TRACE MasterToJoint 7.4");
    VMatrix A = Convert(Group("ConcatRows",reDim[7]),"Blas.R.Dense");
  //WriteLn("TRACE MasterToJoint 8");

    @BSR.ModelDef(
      Text ModuleType;
      Set master->DocInfo;
      Set LinearBlock;
      Set MissingInputBlock;
      Set MissingOutputBlock;
      Set NoiseDistrib;
      VMatrix Y;
      VMatrix X;
      VMatrix a;
      VMatrix A)
  })} 
]];

