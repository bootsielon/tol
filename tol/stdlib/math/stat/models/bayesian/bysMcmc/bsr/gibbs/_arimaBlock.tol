/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// MODULE: Stat (Statistics)
// FILE: arimaBlock.tol
// PURPOSE: Declares method BysMcmc::Bsr::Gibbs::ArimaBlock
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
Class BlockSamplerArima : BlockSampler
/////////////////////////////////////////////////////////////////////////////
{
  //--------------------------------------------------------------------------
  // Mandatory members
  //--------------------------------------------------------------------------
  Code _scalarSampler;
  //Selects noise with constant sigma
  Set _.NoiseDistrib;
  Set _.arimaStructBlock;
  //Number of variant variances (dimension of sigma block)
  Real    _.C;
  Real    _.m;
  Real    _.updateAll;

  //--------------------------------------------------------------------------
  //Auxiliar members
  //--------------------------------------------------------------------------
  NameBlock _.ws             = [[ Real unused_=? ]];
  Set       _.armaParamBlock = Copy(Empty);
  Real      _.N              = 0;
  Real      _.numDifData     = 0;
  Real      _.isNeutral      = True;
  VMatrix   _.noArmaId       = Rand(0,0,0,0);
  Set       _.paramDesc      = Copy(Empty); 
  VMatrix   _.difFilter      = Rand(0,0,0,0);

  //--------------------------------------------------------------------------
  //Methods
  //--------------------------------------------------------------------------
  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.enlargeSymVMatrix =
  "Puts a block symmetric matrix into a joint blocks with zeros out of the "
  "block cells";
  VMatrix enlargeSymVMatrix(VMatrix A, Matrix equIdxVec)
  ////////////////////////////////////////////////////////////////////////////
  {
    Matrix  triplet   = VMat2Triplet(A);
    VMatrix tr        = Triplet(triplet,_.m,_.m, equIdxVec, equIdxVec);
    Convert(tr,"Cholmod.R.Sparse")
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.enlargeRowsVMatrix =
  "Puts a block matrix into a joint blocks with zeros out of the "
  "block rows";
  VMatrix enlargeRowsVMatrix(VMatrix A, Matrix equIdxVec)
  ////////////////////////////////////////////////////////////////////////////
  {
    Matrix  triplet   = VMat2Triplet(Convert(A,"Cholmod.R.Sparse"));
    VMatrix tr        = Triplet(triplet,_.m,VColumns(A), equIdxVec);
    Convert(tr,"Cholmod.R.Sparse")
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.initializeNoArimaBlock =
  "Initiaizes ARIMA invariant information for a noise block without "
  "ARIMA struct";
  Real initializeNoArimaBlock(BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" initializeNoArimaBlock ["+segment->Name+"] 1 "+Time);
  //WriteLn("TRACE"+_MID+" initialize block["<<resBlockNum_+"] 2.1 "+Time);
    Set equIdx = segment->EquIdx;
    Matrix  equIdxVec = SetCol(equIdx);

  //WriteLn("TRACE"+_MID+" initializeNoArimaBlock ["+segment->Name+"] 2 equIdx = "<<equIdx);
    Real m = Card(equIdx);
    Real numPar = 0;
    Real difDegree = 0;
    Real p = 0;
    Real q = 0;
    Polyn dif = 1;
    Polyn ar = 1;
    Polyn ma = 1;
    Real numDifData = m;
    VMatrix D = Eye(m);
    Set segment->ArimaAuxInfo := 
    [[
      numPar, m, difDegree, p, q, numDifData, dif, ar, ma, D
    ]];
    Real SetIndexByName(segment->ArimaAuxInfo);
    VMatrix _.difFilter := 
      _.difFilter + enlargeSymVMatrix(D,equIdxVec);
    VMatrix _.noArmaId := 
      _.noArmaId + enlargeSymVMatrix(Eye(m),equIdxVec);
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.initializeArimaBlock =
  "Initiaizes ARIMA invariant information for a noise block with ARIMA "
  "struct";
  Real initializeArimaBlock(BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" initializeArimaBlock ["+segment->Name+"] 1 "+Time);
    Set     equIdx    = segment->EquIdx;
    Matrix  equIdxVec = SetCol(equIdx);
    Real numPar = 0;
    Set For(1,Card(segment->Arima), Real(Real factorNum_)
    {
      Set arimaFactor = (segment->Arima)[factorNum_];
      Real If(Degree(arimaFactor->AR)>2*arimaFactor->Periodicity,
      {
        Real CMsg::Coded::show(BysMcmc::_.cmsg::_.cannotDrawArima,
        [[
          _MID,
          segment->Name,
          factorNum_,
          "AR",
          arimaFactor->Periodicity,
          arimaFactor->AR
        ]]);
        1
      });
      Set arParDsc = EvalSet(Monomes(1-arimaFactor->AR), Set set.arParDsc(Polyn mon)
      {
        Real deg = Degree(mon);
        Real c = Coef(mon,deg);
        Text name = "ArmaBlk::"+segment->Name+"::AR.F"+IntText(factorNum_)+".D"+IntText(deg);
        ArmaParamDescStruct(name, resBlockNum_, factorNum_, "AR", deg, c, 0)
      });
      If(Degree(arimaFactor->MA)>2*arimaFactor->Periodicity,
      {
        Real CMsg::Coded::show(BysMcmc::_.cmsg::_.cannotDrawArima,
        [[
          _MID,
          segment->Name,
          factorNum_,
          "MA",
          arimaFactor->Periodicity,
          arimaFactor->MA
        ]]);
        1
      });
      Set maParDsc = EvalSet(Monomes(1-arimaFactor->MA), Set set.maParDsc(Polyn mon)
      {
        Real deg = Degree(mon);
        Real c = Coef(mon,deg);
        Text name = "ArmaBlk::"+segment->Name+"::MA.F"+IntText(factorNum_)+".D"+IntText(deg);
        ArmaParamDescStruct(name,resBlockNum_, factorNum_, "MA", deg, c, 0)
      });
      Set Append(_.paramDesc,arParDsc);
      Set Append(_.paramDesc,maParDsc);
      Real numPar := numPar+Card(arParDsc)+Card(maParDsc);
      1
    });
  //WriteLn("TRACE"+_MID+" initializeArimaBlock ["+segment->Name+"] 2 equIdx = "<<equIdx);
    Real m = Card(equIdx);
    Polyn ar = ARIMAGetAR(segment->Arima);
    Polyn ma = ARIMAGetMA(segment->Arima);
    Polyn dif = ARIMAGetDIF(segment->Arima);
    Real p = Degree(ar);
    Real q = Degree(ma);
    Real difDegree = Degree(dif);
    Real If(Or(difDegree,p,q), _.isNeutral := False );
    If(difDegree>m, Real CMsg::Coded::show
      (BysMcmc::_.cmsg::_.nonEnoughtDataForARIMADif,[[_MID,segment->name,difDegree,m]]));
    Real numDifData = m-difDegree;
    VMatrix D = 
    {
      Matrix aux1 = PolMat(dif,m,m);
      Rand(difDegree,m,0,0) <<
      Mat2VMat(SubRow(aux1, Range(difDegree+1,m,1)),0,0.25,1.E-10)
    };
    VMatrix _.difFilter := 
      _.difFilter + enlargeSymVMatrix(D,equIdxVec);
    VMatrix If(!numPar,
      _.noArmaId := _.difFilter + enlargeSymVMatrix(Eye(m),equIdxVec));
    VMatrix Li_ar = Rand(0,0,0,0);
    VMatrix L_ma  = Rand(0,0,0,0);
    Set Li_ar_factors = Copy(Empty);
    Set L_ma_factors = Copy(Empty);
  //WriteLn("TRACE"+_MID+" initialize block["<<resBlockNum_+"] 2.2.7 "+Time);
    Set segment->ArimaAuxInfo := 
    [[
       numPar, m, difDegree, p, q, numDifData, 
       dif, ar, ma, Li_ar, L_ma ,Li_ar_factors, L_ma_factors,
       D, equIdxVec
    ]];
    Real SetIndexByName(segment->ArimaAuxInfo);
    1
  };


  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.prepare =
  "Initializes ARIMA invariant information for all noise blocks and "
  "returns the total number of found ARMA parameters";
  Real prepare(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    WriteLn(_MID+" Initializing block");
    Real    _.N           := 0;
    Real    _.numDifData  := 0;
    VMatrix _.difFilter   := Zeros(_.m,_.m);
    VMatrix _.noArmaId    := Zeros(_.m,_.m);
    Set     _.paramDesc   := Copy(Empty);
  //WriteLn("TRACE"+_MID+"Initializing ARIMA filters");
  //WriteLn("TRACE "+_MID+" Initializing block 1");
    Set initAll = For(1,Card(_.NoiseDistrib), Real(Real resBlockNum_)
    {
      Set segment = _.NoiseDistrib[resBlockNum_];//BSR.NoiseDistrib;
      Set aux = segment->ArimaAuxInfo;
    //WriteLn("TRACE"+_MID+" initialize block["<<resBlockNum_+"] 1 "+Time);
      If(!Card(segment->Arima), 
         initializeNoArimaBlock(segment), 
         initializeArimaBlock(segment));
      Real _.N   := _.N  +aux::numPar; 
      Real _.numDifData := _.numDifData+aux::numDifData; 
      aux::numPar
    });
  //WriteLn("TRACE "+_MID+" Initializing block 2 Card(_.arimaStructBlock)="<<Card(_.arimaStructBlock));
    Set _.armaParamBlock := 
    {
    //WriteLn("TRACESelecting noise with known wariance");
      Select(_.arimaStructBlock, Real(BSR.NoiseDistrib segment)
      { (segment->ArimaAuxInfo)::numPar>0 })
    };
  //WriteLn("TRACE "+_MID+" Initializing block 4 ");
    WriteLn("  "+_MID+" Original data length = "<< _.m);
    WriteLn("  "+_MID+" Differenced data length = "<< _.numDifData);
    WriteLn("  "+_MID+" ARMA parameters = "<< _.N);
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Real _buildWorkSpace(VMatrix noise_, VMatrix sigma.full_)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" BlockSamplerArima::_buildWorkSpace 0");
    NameBlock _.ws := 
    [[
      VMatrix noise = noise_;
      VMatrix sigma.full = sigma.full_
    ]];
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.covDecomp.FastChol =
  "Calculates the Choleski decomposition and its inverse for a block with "
  "ARIMA struct using ARMAProcess::FastCholeskiCovFactor over full ARMA "
  "structure";
  Real covDecomp.FastChol(BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set     aux         = segment->ArimaAuxInfo;
    Real    m           = aux::m;
    NameBlock fastChol  = ARMAProcess::FastCholeskiCovFactor(aux::ar, aux::ma, m);
    Real If(VRows(fastChol::_.Li_ar)<=0, CMsg::Coded::show
      (BysMcmc::_.cmsg::_.invCholFac,[[_MID+ " AR factor of equations block "+segment->Name]]));
    Real If(VRows(fastChol::_.L_ma)<=0, CMsg::Coded::show
      (BysMcmc::_.cmsg::_.invCholFac,[[_MID+ " MA factor of equations block "+segment->Name]]));
    VMatrix aux::Li_ar := fastChol::_.Li_ar;
    VMatrix aux::L_ma  := fastChol::_.L_ma;
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filterJustBlock.FastChol =
  "Filters matrix by Choleski decomposition of ARIMA covarianze of a "
  "noise block that was decomposed using covDecomp.FastChol method";
  VMatrix filterJustBlock.FastChol(BSR.NoiseDistrib segment, VMatrix Z)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" filterJustBlock ["+segment->Name+"] 1");
    Set aux = segment->ArimaAuxInfo;
    CholeskiSolve(aux::L_ma,aux::Li_ar*Z,"PtL")
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.covDecomp.FastCholSea =
  "Calculates the Choleski decomposition and its inverse for a block with "
  "ARIMA struct using ARMAProcess::FastCholeskiCovFactor over each seasonal "
  "component of ARMA structure in an independent way";
  Real covDecomp.FastCholSea(BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set     aux         = segment->ArimaAuxInfo;
    Real    m           = aux::m;
    Set aux::Li_ar_factors := Copy(Empty);
    Set aux::L_ma_factors  := Copy(Empty);
    Set EvalSet(segment->Arima, Real(ARIMAStruct factor)
    {
      NameBlock fastChol  = ARMAProcess::FastCholeskiCovFactor(factor->AR, factor->MA, m);
      Real If(VRows(fastChol::_.Li_ar)<=0, CMsg::Coded::show
        (BysMcmc::_.cmsg::_.invCholFac,[[_MID+ " AR factor of equations block "+segment->Name]]));
      Real If(VRows(fastChol::_.L_ma)<=0, CMsg::Coded::show
        (BysMcmc::_.cmsg::_.invCholFac,[[_MID+ " MA factor of equations block "+segment->Name]]));
      Set Append(aux::Li_ar_factors, [[ fastChol::_.Li_ar ]]);
      Set Append(aux::L_ma_factors,  [[ fastChol::_.L_ma  ]]);
      1
    });
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filterJustBlock.FastCholSea =
  "Filters matrix by Choleski decomposition of ARIMA covarianze of a "
  "noise block that was decomposed using covDecomp.FastCholSea method";
  VMatrix filterJustBlock.FastCholSea(BSR.NoiseDistrib segment, VMatrix Z)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" filterJustBlock ["+segment->Name+"] 1");
    Set aux = segment->ArimaAuxInfo;
    VMatrix F = Z; 
    Set For(1,Card(segment->Arima), Real(Real k)
    {
      VMatrix F := CholeskiSolve(aux::L_ma_factors[k],aux::Li_ar_factors[k]*F,"PtL");
      1
    });
    F
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.covDecomp.DifEq =
  "Does bothing due to DifEq requires no previous action to filter";
  Real covDecomp.DifEq(BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filterJustBlock.DifEq =
  "Filters matrix by Choleski decomposition of ARIMA covarianze of a "
  "noise block solving ARMA difference equations with zero as initial values";
  VMatrix filterJustBlock.DifEq(BSR.NoiseDistrib segment, VMatrix Z)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" filterJustBlock ["+segment->Name+"] 1");
    Set aux = segment->ArimaAuxInfo;
    DifEq(aux::ar/aux::ma,Z)
  };
/* */
  ////////////////////////////////////////////////////////////////////////////
  Real covDecomp(BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
    Eval("covDecomp."+ _.config::bsr.arimaFilter+"(segment)")
  };
  ////////////////////////////////////////////////////////////////////////////
  VMatrix filterJustBlock(BSR.NoiseDistrib segment, VMatrix Z)
  ////////////////////////////////////////////////////////////////////////////
  {
    Eval("filterJustBlock."+ _.config::bsr.arimaFilter+"(segment,Z)")
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.covDecompAll =
  "Calculates the inverse of Choleski decomposition of ARIMA blocks all "
  "together";
  Real covDecompAll(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set EvalSet(_.armaParamBlock, covDecomp);
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setStore =
  "Sets _.store to the specified row vector of values";
  Real setStore(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.N<=0,0,
    {
      Real putStore(values);
      Real k = 1;
    //WriteLn("TRACE"+_MID+" setStore 1 _.store="<<Matrix VMat2Mat(_.store));
      Set Do EvalSet(_.paramDesc, Real setValue(ArmaParamDescStruct pd)
      {
      //WriteLn("TRACE"+_MID+" setStore 2.0 pd="<<pd);
      //WriteLn("TRACE"+_MID+" setStore 2.1 k="<<k);
        Real deg = pd->degree;
      //WriteLn("TRACE"+_MID+" setStore 2.2 deg="<<deg);
        Real x = -VMatDat(_.store, k, 1);
      //WriteLn("TRACE"+_MID+" setStore 2.3 x="<<x);
        Real If(pd->arma=="AR", 
          PutCoef((_.NoiseDistrib[pd->resBlockNum]->Arima)[pd->factorNum]->AR,deg,x),
          PutCoef((_.NoiseDistrib[pd->resBlockNum]->Arima)[pd->factorNum]->MA,deg,x));
      //WriteLn("TRACE"+_MID+" setStore 2.5 arima["<<pd->factorNum+"]="<<(_.NoiseDistrib[pd->resBlockNum]->Arima)[pd->factorNum]);
        Real (k := k+1);
        1
      });
      Set Do EvalSet(_.armaParamBlock, Real set.arma(BSR.NoiseDistrib segment)
      {
        Set   aux      = segment->ArimaAuxInfo;
        Polyn aux::ar := ARIMAGetAR (segment->Arima);
        Polyn aux::ma := ARIMAGetMA (segment->Arima);
      //WriteLn("TRACE"+_MID+" setStore("+segment->Name+") aux::ar="<<aux::ar);
      //WriteLn("TRACE"+_MID+" setStore("+segment->Name+") aux::ma="<<aux::ma);
        1
      });
      Real Do covDecompAll(0);
      1
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.show.arma =
  "Shows arma terms";
  Real show.arma(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set EvalSet(_.armaParamBlock, Real set.showArima(BSR.NoiseDistrib segment)
    {
      WriteLn("ARIMA("+segment->Name+")=\n"<<segment->Arima);
      1
    });
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filter.deterministic =
  "Filters a matrix just by deterministic terms";
  VMatrix filter.deterministic(VMatrix Z)
  ////////////////////////////////////////////////////////////////////////////
  {
    _.difFilter*Z
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filter.arma =
  "Filters a matrix just by arma terms";
  VMatrix filter.arma(VMatrix DX)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set s = EvalSet(_.armaParamBlock, Set set.filterArima(BSR.NoiseDistrib segment)
    {
      VMatrix aux1 = filterJustBlock(segment,SubRow(DX, segment->EquIdx));
      [[aux1, (segment->ArimaAuxInfo)::equIdxVec]]
    });
    MergeRows(_.m, s)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filter =
  "Filters a matrix by Choleski decomposition of ARIMA covarianze of a "
  "noise block";
  VMatrix filter(VMatrix Z)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.isNeutral, Z, {
  //WriteLn("TRACE"+_MID+" filter 1 ("+Identify(Z)+")="<< Z);
    VMatrix filterNoArma = filter.deterministic(Z);
  //WriteLn("TRACE"+_MID+" filter 2 filterNoArima="<< filterNoArma);
    If(!Card(_.armaParamBlock),
    {
    //WriteLn("TRACE"+_MID+" filter 3.1");
      filterNoArma
    },
    {
      VMatrix fltNoArma = _.noArmaId*filterNoArma;
    //WriteLn("TRACE"+_MID+" filter 3 fltNoArima="<<fltNoArma);
      VMatrix fltArma = filter.arma(filterNoArma);
    //WriteLn("TRACE"+_MID+" filter 4 fltArima="<< fltArma);
      VMatrix flt = fltNoArma+fltArma;
    //WriteLn("TRACE"+_MID+" filter 5 flt="<< flt);
      flt
    })
  })};


  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.scalar =
  "Method of generation of a ARMA block by using current scalar method,"
  " given by _scalarSampler, for each parameter";
  VMatrix draw.scalar(Real numSim, VMatrix noise, VMatrix sigma.full)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" draw.scalar [iter "<<numSim+"] 1 ");
    Matrix noise_ = VMat2Mat(noise);
    Set arma.draw.all = 
    EvalSet(_.paramDesc, Real arma.arms.draw(ArmaParamDescStruct pd)
    {
    //WriteLn("TRACE"+_MID+" draw.scalar 2 pd="<<pd);
      Set segment = _.NoiseDistrib[pd->resBlockNum];
      Set arima  = segment->Arima;
    //WriteLn("TRACE"+_MID+" draw.scalar 2.1 segment->SigmaIndex="<<segment->SigmaIndex);
      Real sigma = If(segment->SigmaIndex<=0,1,
         Sqrt(VMatDat(sigma.full,segment->SigmaIndex,1)));
    //WriteLn("TRACE"+_MID+" draw.scalar 2.2");
      Polyn dif  = ARIMAGetDIF(arima);
      Set factor = arima[pd->factorNum];
      Set equIdx = segment->EquIdx;
      Set aux    = segment->ArimaAuxInfo;
      Set polRef = SetOfPolyn(If(pd->arma=="AR", factor->AR, factor->MA));
    //WriteLn("TRACE"+_MID+" draw.scalar 2.1 polRef[1]="<<polRef[1]);
      Real deg = pd->degree;
      Set bounds = ARMAProcess::StationarityBounds.2(polRef[1], factor->Periodicity, deg);
      Real x0 = bounds[1]+0.001;
      Real x1 = bounds[2]-0.001;
    //WriteLn("TRACE"+_MID+" draw.scalar 3 bounds=["<<x0+","<<x1+"]");
      Real m = aux::m;
      Real n = m - aux::difDegree;
      Matrix pdNoise_ = SubRow(noise_,equIdx);

      Real SetValue(Real x0)
      {
        Real x = If(1+x==1, 0.000001, x);
      //WriteLn("TRACE"+_MID+" SetValue("<<x+")");
        Real pd->numEvalDens := pd->numEvalDens+1;
        Real x__ = PutCoef(polRef[1], deg, -x);
        Real x_  = Coef(polRef[1],deg);
        Polyn pol = polRef[1];
        Real isStationary = IsStationary(pol);
        If(!isStationary, Real CMsg::Coded::show
          (BysMcmc::_.cmsg::_.nonStationaryDraw,[[_MID,pd->name,pol,x]]));
        x
      };

      Matrix z = Sub(DifEq(dif/1,pdNoise_),aux::difDegree+1,1,n,1);
      VMatrix z_ = Mat2VMat(z);
      Polyn  ar = ARIMAGetAR(arima);
      Polyn  ma = ARIMAGetMA(arima);
      NameBlock almagro = ARMAProcess::Eval.Almagro(ar,ma,z_,sigma);

      VMatrix u0 = almagro::Draw.U_cond_Z(0);
      VMatrix z0 = almagro::Get.Z0(u0);
      VMatrix a0 = almagro::Get.A0(u0);
    //WriteLn("TRACE"+_MID+" draw.scalar almagro::_.p="<<almagro::_.p);
    //WriteLn("TRACE"+_MID+" draw.scalar almagro::_.q="<<almagro::_.p);
    //WriteLn("TRACE"+_MID+" draw.scalar almagro::_.z0="<<almagro::_.z0);
    //WriteLn("TRACE"+_MID+" draw.scalar almagro::_.a0="<<almagro::_.a0);
    //WriteLn("TRACE"+_MID+" draw.scalar u0="<<u0);
    //WriteLn("TRACE"+_MID+" draw.scalar z0="<<z0);
    //WriteLn("TRACE"+_MID+" draw.scalar a0="<<a0);

      Real LogDens.Almagro.Z_cond_U(Real x)
      {
        Real Do SetValue(x);
        Polyn  ar = ARIMAGetAR(arima);
        Polyn  ma = ARIMAGetMA(arima);
        Real llh = Copy(almagro::LogLH.Z_cond_U(ar,ma,z0,a0));
        llh 
      };
      Code LogDens = LogDens.Almagro.Z_cond_U;
      Real If(Or(pd->coef<x0,pd->coef>x1), { pd->coef := Rand(x0,x1) }, 0);
      Real pd->coef:= _scalarSampler(LogDens,x0,x1,pd->coef);

    //WriteLn("TRACE"+_MID+" draw.scalar pd->coef="<<pd->coef);
      pd->coef
    });
  //Real show.arma(0);
    Matrix values = SetCol(arma.draw.all);
  //WriteLn("TRACE"+_MID+" draw 3 "<<Matrix Tra(values));
    Mat2VMat(values)
  };


  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw =
  "Method of generation of arima block";
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    draw.scalar(numSim, _.ws::noise, _.ws::sigma.full)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setMcmcRow =
  "Sets _.store to the columns related to this block of a given row of a "
  "Markov Chain";
  Real setMcmcRow(Matrix mcmc, Real row) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Real setStore(getMcmcRow(mcmc, row))
  };

  ////////////////////////////////////////////////////////////////////////////
  //This note applys over all following methods 
  ////////////////////////////////////////////////////////////////////////////
  Text _explain.param ="\n"+
  "Used parameters are the currently stored, but you can set a previously "
  "simulated vector of parameters calling before to method "
  "setMcmcRow. You also can set an arbitrary row vector of parameters using "
  "method setStore, but then you must ensure that it's a valid set of "
  "values.";

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getARIMA =
  "Returns ARIMA definition of a given block of equations containinig a set "
  "of ARIMAStruct's, please don´t modified it!."+_explain.param;
  Set getARIMA(Real noiseBlockIndex) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Set segment = _.NoiseDistrib[noiseBlockIndex];
    segment->Arima
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getAuxARIMAInfo =
  "Returns auxiliar ARIMA information about a given block of equations "
  "containing aggreated dif, ar and ma polynomials and its degrees "
  "and other internal information that you should not touch."+_explain.param;
  Set getAuxARIMAInfo(Real noiseBlockIndex) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Set segment = _.NoiseDistrib[noiseBlockIndex];
    segment->ArimaAuxInfo
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.difEq.ARI.MA =
  "Solves difference equations of direct ARIMA process of a given block of "
  "regression equations:\n"
  " Z = (theta(B)/(phi(B)*delta(B)))*E "+_explain.param;
  Matrix difEq.ARI.MA
  (
    Real   noiseBlockIndex, 
    Matrix E, 
    Matrix E0, 
    Matrix Z0
  )
  ////////////////////////////////////////////////////////////////////////////
  {
    Set segment = _.NoiseDistrib[noiseBlockIndex];
    Set aux = segment->ArimaAuxInfo;
    If(Or(aux::difDegree,aux::p,aux::q),
    {
      DifEq(aux::ma/(aux::dif*aux::ar), E, E0, Z0)
    },
    {
      E
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.difEq.ARI.MA.0 =
  "Is equal than difEq.ARI.MA but using zeroes as initial values."+
  _explain.param;
  Matrix difEq.ARI.MA.0
  (
    Real   noiseBlockIndex, 
    Matrix E
  )
  ////////////////////////////////////////////////////////////////////////////
  {
    Set segment = _.NoiseDistrib[noiseBlockIndex];
    Set aux = segment->ArimaAuxInfo;
    If(Or(aux::difDegree,aux::p,aux::q),
    {
      Matrix E0 = Rand(aux::q,1,0,0);
      Matrix Z0 = Rand(aux::p+aux::difDegree,1,0,0);
      DifEq(aux::ma/(aux::dif*aux::ar), E, E0, Z0)
    },
    {
      E
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.difEq.MA.ARI =
  "Solves difference equations of inverse ARIMA process of a given block of "
  "regression equations:\n"
  " E = ((phi(B)*delta(B))/theta(B))*Z "+_explain.param;
  Matrix difEq.MA.ARI
  (
    Real   noiseBlockIndex, 
    Matrix Z, 
    Matrix Z0, 
    Matrix E0
  )
  ////////////////////////////////////////////////////////////////////////////
  {
    Set segment = _.NoiseDistrib[noiseBlockIndex];
    Set aux = segment->ArimaAuxInfo;
    If(Or(aux::difDegree,aux::p,aux::q),
    {
      DifEq((aux::dif*aux::ar)/aux::ma, Z, Z0, E0)
    },
    {
      Z
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.difEq.MA.ARI.0 =
  "Is equal than difEq.MA.ARI but using zeroes as initial values."+
  _explain.param;
  Matrix difEq.MA.ARI.0
  (
    Real   noiseBlockIndex, 
    Matrix Z
  )
  ////////////////////////////////////////////////////////////////////////////
  {
    Set segment = _.NoiseDistrib[noiseBlockIndex];
    Set aux = segment->ArimaAuxInfo;
    If(Or(aux::difDegree,aux::p,aux::q),
    {
      Matrix E0 = Rand(aux::q,       1,0,0);
      Matrix Z0 = Rand(aux::p+aux::difDegree,1,0,0);
      DifEq((aux::dif*aux::ar)/aux::ma, Z, Z0, E0)
    },
    {
      Z
    })
  }
};


//////////////////////////////////////////////////////////////////////////////
  BlockSamplerArima BlockSamplerArima.Default(Real unused)
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::Bsr::Gibbs::BlockSamplerArima blk = [[
  Code _scalarSampler = BysMcmc::Options::Scalar.Sampler::Slice;
  Set _.NoiseDistrib = Copy(Empty);
  Set _.arimaStructBlock = Copy(Empty);
  Text _MID = "";
  Real    _.C          = ?;
  Real    _.m          = ?;
  Real _defined = ?;
  Real _.updateAll = ?
]]};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.ArimaBlock =
"Builds a NameBlock that can draw a Gibbs sample of a ARIMA block of a "
"general regression model. Just ARIMA filtering is currently running but "
"ARMA simulation is still not implemented";
//////////////////////////////////////////////////////////////////////////////
  BlockSamplerArima ArimaBlock(Text name, 
                          Set NoiseDistrib, 
                          BysMcmc::McmcPartialHandler mcmcPartialHandler,
                          Real numBlock, 
                          Real firstCol,
                          BysMcmc::Config config)
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::Bsr::Gibbs::BlockSamplerArima blk = [[
  Code _scalarSampler = config::bsr.scalarSampler.armaBlock;
  //Selects noise with constant sigma
  Set _.NoiseDistrib = NoiseDistrib;
  Set _.arimaStructBlock = 
  {
  //WriteLn("TRACESelecting noise with known wariance");
    Select(NoiseDistrib, Real(BSR.NoiseDistrib segment)
    { Card(segment->Arima)>0 })
  };

  //Message identificator
  Text _MID = "["+name+"] ";
  //Number of variant variances (dimension of sigma block)
  Real    _.C          = Card(_.arimaStructBlock);
  Real    _.m          = VRows(_.NoiseDistrib[1]->Li);
  Code _.buildWorkSpace = _buildWorkSpace;
  //Defining the block in the Markov Chain
  Real _defined = {
    Real prepare(0);
    define
    (
      name,
      EvalSet(_.paramDesc, Text set.colName(ArmaParamDescStruct pd) { pd->name }),
      mcmcPartialHandler,
      numBlock,
      firstCol,
      config
    )};
  Real _.updateAll = 
  {
  //WriteLn("TRACE "+_MID+" initial _.paramDesc = "<<_.paramDesc);
    Matrix values = SetCol(EvalSet(_.paramDesc, Real (ArmaParamDescStruct pd)
    {
      pd->coef
    }));
  //WriteLn("TRACE "+_MID+" initial values = "<<values);
    setStore(values)
  }

]]};
