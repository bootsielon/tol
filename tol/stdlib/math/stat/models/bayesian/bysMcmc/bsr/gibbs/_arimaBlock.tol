/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// MODULE: Stat (Statistics)
// FILE: arimaBlock.tol
// PURPOSE: Declares method BysMcmc::Bsr::Gibbs::ArimaBlock
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Class @WorkSpace.Arima : @WorkSpace
//////////////////////////////////////////////////////////////////////////////
{
  Text get.blockSamplerClassName(Real void) { "@BlockArima" };
  VMatrix _.noise;
  VMatrix _.sigma.full;

  Static @WorkSpace.Arima Default(Real void)
  {
    @WorkSpace.Arima new = @WorkSpace.Arima[[
      VMatrix _.noise = Rand(0,0,0,0);
      VMatrix _.sigma.full = Rand(0,0,0,0) ]]
  };
  Static @WorkSpace.Arima New(
    VMatrix noise,
    VMatrix sigma.full)
  {
    @WorkSpace.Arima new = @WorkSpace.Arima[[
      VMatrix _.noise = noise;
      VMatrix _.sigma.full = sigma.full ]]
  }
};

/////////////////////////////////////////////////////////////////////////////
Class @BlockArima : @BlockSampler
/////////////////////////////////////////////////////////////////////////////
{
  //--------------------------------------------------------------------------
  // Mandatory members
  //--------------------------------------------------------------------------
  BysMcmc::Options::@Scalar.Sampler _scalarSampler;
  //Selects noise with constant sigma
  Set _.NoiseDistrib;
  Set _.arimaStructBlock;
  //Number of variant variances (dimension of sigma block)
  Real _.C;
  Real _.m;
  Real _.updateAll;

  //--------------------------------------------------------------------------
  //Auxiliar members
  //--------------------------------------------------------------------------
  @WorkSpace.Arima _.ws  = @WorkSpace.Arima::Default(0);
  Set       _.armaParamBlock = Copy(Empty);
  Real      _.N              = 0;
  Real      _.numDifData     = 0;
  Real      _.isNeutral      = True;
  VMatrix   _.noArmaId       = Rand(0,0,0,0);
  Set       _.paramDesc      = Copy(Empty); 
  VMatrix   _.difFilter      = Rand(0,0,0,0);
  Set       _.segment.free.index = Copy(Empty);
  VMatrix   _.U0 = Rand(0,1,0,0); 
  Matrix    _.U0.cache = Rand(0,0,0,0); 
  Matrix    _.U0.mcmc = Rand(0,0,0,0); 
  Set       _.U0.names = Copy(Empty);

  //--------------------------------------------------------------------------
  //Methods
  //--------------------------------------------------------------------------

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.enlargeSymVMatrix =
  "Puts a block symmetric matrix into a joint blocks with zeros out of the "
  "block cells";
  VMatrix enlargeSymVMatrix(VMatrix A, Matrix equIdxVec)
  ////////////////////////////////////////////////////////////////////////////
  {
    Matrix  triplet   = VMat2Triplet(A);
    VMatrix tr        = Triplet(triplet,_.m,_.m, equIdxVec, equIdxVec);
    Convert(tr,"Cholmod.R.Sparse")
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.enlargeRowsVMatrix =
  "Puts a block matrix into a joint blocks with zeros out of the "
  "block rows";
  VMatrix enlargeRowsVMatrix(VMatrix A, Matrix equIdxVec)
  ////////////////////////////////////////////////////////////////////////////
  {
    Matrix  triplet   = VMat2Triplet(Convert(A,"Cholmod.R.Sparse"));
    VMatrix tr        = Triplet(triplet,_.m,VColumns(A), equIdxVec);
    Convert(tr,"Cholmod.R.Sparse")
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.initializeNoArimaBlock =
  "Initiaizes ARIMA invariant information for a noise block without "
  "ARIMA struct";
  Real initializeNoArimaBlock(@BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" initializeNoArimaBlock ["+segment->Name+"] 1 "+Time);
  //WriteLn("TRACE"+_MID+" initialize block["<<resBlockNum_+"] 2.1 "+Time);
    Set equIdx = segment->EquIdx;
    Matrix  equIdxVec = SetCol(equIdx);

  //WriteLn("TRACE"+_MID+" initializeNoArimaBlock ["+segment->Name+"] 2 equIdx = "<<equIdx);
    Real m = Card(equIdx);
    Real numPar = 0;
    Real difDegree = 0;
    Real p = 0;
    Real q = 0;
    Polyn dif = 1;
    Polyn ar = 1;
    Polyn ma = 1;
    Real numDifData = m;
    VMatrix D = Eye(m);
    VMatrix u0 = Rand(0,0,0,0);
    Set segment->ArimaAuxInfo := 
    [[
      numPar, m, difDegree, p, q, numDifData, dif, ar, ma, D, u0
    ]];
    Real SetIndexByName(segment->ArimaAuxInfo);
  //WriteLn("TRACE"+_MID+" initializeNoArimaBlock before _.difFilter:"<<_.difFilter);
    VMatrix aux = enlargeSymVMatrix(D,equIdxVec);
  //WriteLn("TRACE"+_MID+" initializeNoArimaBlock before aux:"<<aux);
    VMatrix _.difFilter := _.difFilter + aux;
  //WriteLn("TRACE"+_MID+" initializeNoArimaBlock after _.difFilter:"<<_.difFilter);
    VMatrix _.noArmaId := 
      _.noArmaId + enlargeSymVMatrix(Eye(m),equIdxVec);
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.initializeArimaBlock =
  "Initiaizes ARIMA invariant information for a noise block with ARIMA "
  "struct";
  Real initializeArimaBlock(@BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" initializeArimaBlock ["+segment->Name+"] 1 "+Time);
    Set     equIdx    = segment->EquIdx;
    Matrix  equIdxVec = SetCol(equIdx);
  //WriteLn("TRACE "+_MID+" initialize 1 ");

    Real numPar = 0;
    Set For(1,Card(segment->Arima), Real(Real factorNum_)
    {
      Set arimaFactor = (segment->Arima)[factorNum_];
/*
      Real If(Degree(arimaFactor->AR)>2*arimaFactor->Periodicity,
      {
        Real CMsg::Coded::show(BysMcmc::_.cmsg::_.cannotDrawArima,
        [[
          _MID,
          segment->Name,
          factorNum_,
          "AR",
          arimaFactor->Periodicity,
          arimaFactor->AR
        ]]);
        1
      });
*/
      Set arParDsc = EvalSet(Monomes(1-arimaFactor->AR), Set set.arParDsc(Polyn mon)
      {
        Real deg = Degree(mon);
        Real c = Coef(mon,deg);
        Text name = "ArmaBlk::"+segment->Name+"::AR.F"+IntText(factorNum_)+".D"+IntText(deg);
          @ArmaParamDescStruct(name, 0, resBlockNum_, factorNum_, "AR", deg, c, 0, 0, 0)
      });
/*
      If(Degree(arimaFactor->MA)>2*arimaFactor->Periodicity,
      {
        Real CMsg::Coded::show(BysMcmc::_.cmsg::_.cannotDrawArima,
        [[
          _MID,
          segment->Name,
          factorNum_,
          "MA",
          arimaFactor->Periodicity,
          arimaFactor->MA
        ]]);
        1
      });
*/
      Set maParDsc = EvalSet(Monomes(1-arimaFactor->MA), Set set.maParDsc(Polyn mon)
      {
        Real deg = Degree(mon);
        Real c = Coef(mon,deg);
        Text name = "ArmaBlk::"+segment->Name+"::MA.F"+IntText(factorNum_)+".D"+IntText(deg);
          @ArmaParamDescStruct(name, 0, resBlockNum_, factorNum_, "MA", deg, c, 0, 0, 0)
      });
      Set Append(_.paramDesc,arParDsc);
      Set Append(_.paramDesc,maParDsc);
      Real numPar := numPar+Card(arParDsc)+Card(maParDsc);
      1
    });
  //WriteLn("TRACE"+_MID+" initializeArimaBlock ["+segment->Name+"] 2 equIdx = "<<equIdx);
    Real m = Card(equIdx);
    Polyn ar = ARIMAGetAR(segment->Arima);
    Polyn ma = ARIMAGetMA(segment->Arima);
    Polyn dif = ARIMAGetDIF(segment->Arima);
    Real p = Degree(ar);
    Real q = Degree(ma);
    Real difDegree = Degree(dif);
    Real If(Or(difDegree,p,q), _.isNeutral := False );
    If(difDegree>m, Real CMsg::Coded::show
      (BysMcmc::_.cmsg::_.nonEnoughtDataForARIMADif,[[_MID,segment->name,difDegree,m]]));
    Real numDifData = m-difDegree;
    VMatrix D = 
    {
      VMatrix aux1 = Pol2VMat(dif,m,m);
      Zeros(difDegree,m) <<
      SubRow(aux1, Range(difDegree+1,m,1))
    };
  //WriteLn("TRACE"+_MID+" initializeArimaBlock before _.difFilter:"<<_.difFilter);
    VMatrix _.difFilter := 
      _.difFilter + enlargeSymVMatrix(D,equIdxVec);
  //WriteLn("TRACE"+_MID+" initializeArimaBlock after _.difFilter:"<<_.difFilter);
    VMatrix If(!numPar,
      _.noArmaId := _.difFilter + enlargeSymVMatrix(Eye(m),equIdxVec));
  //WriteLn("TRACE"+_MID+" initializeArimaBlock after 2 _.difFilter:"<<_.difFilter);
    VMatrix Li_ar = Rand(0,0,0,0);
    VMatrix L_ma  = Rand(0,0,0,0);
    Set Li_ar_factors = Copy(Empty);
    Set L_ma_factors = Copy(Empty);
    VMatrix u0 = Rand(0,0,0,0);
  //WriteLn("TRACE"+_MID+" initializeArimaBlock 3 ");
    Set If(_.config::bsr.arimaStoreInitialValues, 
    {
    //WriteLn("TRACE"+_MID+" initializeArimaBlock 4.1 p="<<p);
      Set z0.names = For(1,p,Text(Real k)
      {
        Text name = segment->Name+".InitialValue.Noise."+IntText(k);
        Eval(name+"=name")
      });
    //WriteLn("TRACE"+_MID+" initializeArimaBlock 4.2 q="<<q);
      Set a0.names = For(1,q,Text(Real k)
      {
        Text name = segment->Name+".InitialValue.Residual."+IntText(k);
        Eval(name+"=name")
      });
      Set u0.names = z0.names<<a0.names;
    //WriteLn("TRACE"+_MID+" initializeArimaBlock after 4.3 u0.names=\n"<<u0.names);
      Append(_.U0.names, u0.names, True)
    });
  //WriteLn("TRACE"+_MID+" initializeArimaBlock 5 ");
    Set segment->ArimaAuxInfo := 
    [[
       numPar, m, difDegree, p, q, numDifData, 
       dif, ar, ma, Li_ar, L_ma ,Li_ar_factors, L_ma_factors,
       D, equIdxVec, u0
    ]];
    Real SetIndexByName(segment->ArimaAuxInfo);
    1
  };


  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.prepare =
  "Initializes ARIMA invariant information for all noise blocks and "
  "returns the total number of found ARMA parameters";
  Real prepare(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    WriteLn(_MID+" Initializing block");
    Real    _.N           := 0;
    Real    _.numDifData  := 0;
  //WriteLn("TRACE"+_MID+" prepare before _.difFilter:"<<_.difFilter);
    VMatrix _.difFilter   := Zeros(_.m,_.m, "Cholmod.R.Sparse");
  //WriteLn("TRACE"+_MID+" prepare after _.difFilter:"<<_.difFilter);
    VMatrix _.noArmaId    := Zeros(_.m,_.m, "Cholmod.R.Sparse");
    Set     _.paramDesc   := Copy(Empty);
  //WriteLn("TRACE"+_MID+"Initializing ARIMA filters");
  //WriteLn("TRACE "+_MID+" Initializing block 1");
    Set initAll = For(1,Card(_.NoiseDistrib), Real(Real resBlockNum_)
    {
      Set segment = _.NoiseDistrib[resBlockNum_];//@BSR.NoiseDistrib;
      Set aux = segment->ArimaAuxInfo;
    //WriteLn("TRACE"+_MID+" initialize block["<<resBlockNum_+"] 1 "+Time);
      If(!Card(segment->Arima), 
         initializeNoArimaBlock(segment), 
         initializeArimaBlock(segment));
      Real _.N   := _.N  +aux::numPar; 
      Real _.numDifData := _.numDifData+aux::numDifData; 
      aux::numPar
    });
  //WriteLn("TRACE "+_MID+" Initializing block 2 Card(_.arimaStructBlock)="<<Card(_.arimaStructBlock));
    Set _.armaParamBlock := 
    {
    //WriteLn("TRACESelecting noise with known wariance");
      Select(_.arimaStructBlock, Real(@BSR.NoiseDistrib segment)
      { (segment->ArimaAuxInfo)::numPar>0 })
    };
  //WriteLn("TRACE "+_MID+" Initializing block 4 ");
    WriteLn("  "+_MID+" Original data length = "<< _.m);
    WriteLn("  "+_MID+" Differenced data length = "<< _.numDifData);
    WriteLn("  "+_MID+" ARMA parameters = "<< _.N);
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Real _buildWorkSpace(@WorkSpace.Arima param)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix _.ws::_.noise := param::_.noise;
    VMatrix _.ws::_.sigma.full := param::_.sigma.full;
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real buildWorkSpace(@WorkSpace param)
  ////////////////////////////////////////////////////////////////////////////
  {
    _buildWorkSpace(param)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real hasFixed   = _.partialSampler::_.fixedParamNum  > 0;
  //WriteLn("TRACE "+_MID+" initialize hasFixed="<<hasFixed);
    Real hasReload  = _.partialSampler::_.reloadParamNum > 0;
  //WriteLn("TRACE "+_MID+" initialize hasReload="<<hasReload);
    Real hasPartial = hasFixed | hasReload;
    Real paramNum = 0;

    Real SetFixedAndReloadIndexes(@ArmaParamDescStruct prm)
    {
      Text name = ToName(prm->name);
      Real paramNum := paramNum + 1;
      Real prm->paramNum := paramNum;
      Real If(hasFixed,
      {
        prm->idxFixed:=FindIndexByName(_.partialSampler::_.fixedParam, name)
      });
      Real If(hasReload & Not(prm->idxFixed),
      {
        prm->idxReload:=FindIndexByName(_.partialSampler::_.reloadParam, name)
      });
      Set If(Not(prm->idxFixed) & Not(prm->idxReload),
      {
        Append(_.segment.free.index, [[Copy(paramNum)]])
      });
      1
    };
    Set EvalSet(_.paramDesc, SetFixedAndReloadIndexes);
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.covDecomp.FastChol =
  "Calculates the Choleski decomposition and its inverse for a block with "
  "ARIMA struct using ARMAProcess::FastCholeskiCovFactor over full ARMA "
  "structure";
  Real covDecomp.FastChol(@BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" covDecomp.FastChol ["+segment->Name+"] 1");
    Set     aux         = segment->ArimaAuxInfo;
    Real    m           = aux::m;
    NameBlock fastChol  = ARMAProcess::FastCholeskiCovFactor(aux::ar, aux::ma, m);
    Real If(VRows(fastChol::_.Li_ar)<=0, CMsg::Coded::show
      (BysMcmc::_.cmsg::_.invCholFac,[[_MID+ " AR factor of equations block "+segment->Name]]));
    Real If(VRows(fastChol::_.L_ma)<=0, CMsg::Coded::show
      (BysMcmc::_.cmsg::_.invCholFac,[[_MID+ " MA factor of equations block "+segment->Name]]));
    VMatrix aux::Li_ar := fastChol::_.Li_ar;
    VMatrix aux::L_ma  := fastChol::_.L_ma;
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filterJustBlock.FastChol =
  "Filters matrix by Choleski decomposition of ARIMA covarianze of a "
  "noise block that was decomposed using covDecomp.FastChol method";
  VMatrix filterJustBlock.FastChol(@BSR.NoiseDistrib segment, VMatrix Z)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" filterJustBlock.FastChol ["+segment->Name+"] 1");
    Set aux = segment->ArimaAuxInfo;
    CholeskiSolve(aux::L_ma,aux::Li_ar*Z,"PtL")
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.covDecomp.FastCholSea =
  "Calculates the Choleski decomposition and its inverse for a block with "
  "ARIMA struct using ARMAProcess::FastCholeskiCovFactor over each seasonal "
  "component of ARMA structure in an independent way";
  Real covDecomp.FastCholSea(@BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" covDecomp.FastCholSea ["+segment->Name+"] 1");
    Set     aux         = segment->ArimaAuxInfo;
    Real    m           = aux::m;
    Set aux::Li_ar_factors := Copy(Empty);
    Set aux::L_ma_factors  := Copy(Empty);
    Set EvalSet(segment->Arima, Real(@ARIMAStruct factor)
    {
      NameBlock fastChol  = ARMAProcess::FastCholeskiCovFactor(factor->AR, factor->MA, m);
      Real If(VRows(fastChol::_.Li_ar)<=0, CMsg::Coded::show
        (BysMcmc::_.cmsg::_.invCholFac,[[_MID+ " AR factor of equations block "+segment->Name]]));
      Real If(VRows(fastChol::_.L_ma)<=0, CMsg::Coded::show
        (BysMcmc::_.cmsg::_.invCholFac,[[_MID+ " MA factor of equations block "+segment->Name]]));
      Set Append(aux::Li_ar_factors, [[ fastChol::_.Li_ar ]]);
      Set Append(aux::L_ma_factors,  [[ fastChol::_.L_ma  ]]);
      1
    });
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filterJustBlock.FastCholSea =
  "Filters matrix by Choleski decomposition of ARIMA covarianze of a "
  "noise block that was decomposed using covDecomp.FastCholSea method";
  VMatrix filterJustBlock.FastCholSea(@BSR.NoiseDistrib segment, VMatrix Z)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" filterJustBlock.FastCholSea ["+segment->Name+"] 1");
    Set aux = segment->ArimaAuxInfo;
    VMatrix F = Z; 
    Set For(1,Card(segment->Arima), Real(Real k)
    {
      VMatrix F := CholeskiSolve(aux::L_ma_factors[k],aux::Li_ar_factors[k]*F,"PtL");
      1
    });
    F
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.covDecomp.DifEq =
  "Does bothing due to DifEq requires no previous action to filter";
  Real covDecomp.DifEq(@BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filterJustBlock.DifEq =
  "Filters matrix by Choleski decomposition of ARIMA covarianze of a "
  "noise block solving ARMA difference equations with zero as initial values";
  VMatrix filterJustBlock.DifEq(@BSR.NoiseDistrib segment, VMatrix Z)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" filterJustBlock.DifEq ["+segment->Name+"] 1");
    Set aux = segment->ArimaAuxInfo;
    DifEq(aux::ar/aux::ma,Z)
  };
/* */
  ////////////////////////////////////////////////////////////////////////////
  Real covDecomp(@BSR.NoiseDistrib segment)
  ////////////////////////////////////////////////////////////////////////////
  {
    Eval("covDecomp."+ _.config::bsr.arimaFilter+"(segment)")
  };
  ////////////////////////////////////////////////////////////////////////////
  VMatrix filterJustBlock(@BSR.NoiseDistrib segment, VMatrix Z)
  ////////////////////////////////////////////////////////////////////////////
  {
    Eval("filterJustBlock."+ _.config::bsr.arimaFilter+"(segment,Z)")
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.covDecompAll =
  "Calculates the inverse of Choleski decomposition of ARIMA blocks all "
  "together";
  Real covDecompAll(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set EvalSet(_.armaParamBlock, covDecomp);
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setStore =
  "Sets _.store to the specified row vector of values";
  Real setStore(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.N<=0,0,
    {
    //WriteLn("TRACE"+_MID+" setStore("<<Rows(values)+"x"<<Columns(values)+")");
      Real putStore(values);
      Real k = 1;
    //WriteLn("TRACE"+_MID+" setStore 1 _.store="<<Matrix VMat2Mat(_.store));
      Set Do EvalSet(_.paramDesc, Real setValue(@ArmaParamDescStruct pd)
      {
      //WriteLn("TRACE"+_MID+" setStore 2.0 pd="<<pd);
      //WriteLn("TRACE"+_MID+" setStore 2.1 k="<<k);
        Real deg = pd->degree;
      //WriteLn("TRACE"+_MID+" setStore 2.2 deg="<<deg);
        Real x = -VMatDat(_.store, k, 1);
      //WriteLn("TRACE"+_MID+" setStore 2.3 x="<<x);
        Real If(pd->arma=="AR", 
          PutCoef((_.NoiseDistrib[pd->resBlockNum]->Arima)[pd->factorNum]->AR,deg,x),
          PutCoef((_.NoiseDistrib[pd->resBlockNum]->Arima)[pd->factorNum]->MA,deg,x));
      //WriteLn("TRACE"+_MID+" setStore 2.5 arima["<<pd->factorNum+"]="<<(_.NoiseDistrib[pd->resBlockNum]->Arima)[pd->factorNum]);
        Real (k := k+1);
        1
      });
      Set Do EvalSet(_.armaParamBlock, Real set.arma(@BSR.NoiseDistrib segment)
      {
        Set   aux      = segment->ArimaAuxInfo;
        Polyn aux::ar := ARIMAGetAR (segment->Arima);
        Polyn aux::ma := ARIMAGetMA (segment->Arima);
      //WriteLn("TRACE"+_MID+" setStore("+segment->Name+") aux::ar="<<aux::ar);
      //WriteLn("TRACE"+_MID+" setStore("+segment->Name+") aux::ma="<<aux::ma);
        1
      });
      Real Do covDecompAll(0);
      1
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.show.arma =
  "Shows arma terms";
  Real show.arma(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set EvalSet(_.armaParamBlock, Real set.showArima(@BSR.NoiseDistrib segment)
    {
      WriteLn("ARIMA("+segment->Name+")=\n"<<segment->Arima);
      1
    });
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filter.deterministic =
  "Filters a matrix just by deterministic terms";
  VMatrix filter.deterministic(VMatrix Z)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" filter.deterministic before _.difFilter:"<<_.difFilter);
    VMatrix aux = _.difFilter*Z;
  //WriteLn("TRACE"+_MID+" filter.deterministic after _.difFilter:"<<_.difFilter);
    aux
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filter.arma =
  "Filters a matrix just by arma terms";
  VMatrix filter.arma(VMatrix DX)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" filter.arma 1 DX="<< DX);
    Set s = EvalSet(_.armaParamBlock, Set set.filterArima(@BSR.NoiseDistrib segment)
    {
    //WriteLn("TRACE"+_MID+" filter.arma 2 segment="<< segment->Name);
      VMatrix DXs = SubRow(DX, segment->EquIdx);
    //WriteLn("TRACE"+_MID+" filter.arma 3 DXs="<< DXs);
      VMatrix aux1 = filterJustBlock(segment,DXs);
    //WriteLn("TRACE"+_MID+" filter.arma 4 aux1="<< aux1);
      [[aux1, (segment->ArimaAuxInfo)::equIdxVec]]
    });
  //WriteLn("TRACE"+_MID+" filter.arma 5");
    MergeRows(_.m, s)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filter =
  "Filters a matrix by Choleski decomposition of ARIMA covarianze of a "
  "noise block";
  VMatrix filter(VMatrix Z)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.isNeutral, Z, {
  //WriteLn("TRACE"+_MID+" filter  Z="<<Z);
  //WriteLn("TRACE"+_MID+" filter 1 ("+Identify(Z)+")="<< Z);
    VMatrix filterNoArma = filter.deterministic(Z);
  //WriteLn("TRACE"+_MID+" filter 2 filterNoArima="<< filterNoArma);
    VMatrix Zf = If(!Card(_.armaParamBlock),
    {
    //WriteLn("TRACE"+_MID+" filter 3.1");
      filterNoArma
    },
    {
      VMatrix fltNoArma = _.noArmaId*filterNoArma;
    //WriteLn("TRACE"+_MID+" filter 3 fltNoArima="<<fltNoArma);
      VMatrix fltArma = filter.arma(filterNoArma);
    //WriteLn("TRACE"+_MID+" filter 4 fltArima="<< fltArma);
      VMatrix flt = fltNoArma+fltArma;
    //WriteLn("TRACE"+_MID+" filter 5 flt="<< flt);
      flt
    });
  //WriteLn("TRACE"+_MID+" filter  Zf="<<Zf);
    Zf
  })};


  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.scalar =
  "Method of generation of a ARMA block by using current scalar method,"
  " given by _scalarSampler, for each parameter";
  VMatrix draw.scalar(Real numSim, VMatrix noise, VMatrix sigma.full)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" draw.scalar [iter "<<numSim+"] 1 ");
    Matrix noise_ = VMat2Mat(noise);
    Real oldResBlockNum = -1;
    VMatrix If(_.config::bsr.arimaStoreInitialValues, 
    {
      VMatrix _.U0 := Rand(0,1,0,0)
    }); 
    Set arma.draw.all = 
    EvalSet(_.segment.free.index, Real arma.arms.draw(Real paramNum)
    {
      @ArmaParamDescStruct pd = _.paramDesc[paramNum];
    //WriteLn("TRACE"+_MID+" draw.scalar 2 pd="<<pd);
      Set segment = _.NoiseDistrib[pd->resBlockNum];
      Set arima  = segment->Arima;
    //WriteLn("TRACE"+_MID+" draw.scalar 2.1 segment->SigmaIndex="<<segment->SigmaIndex);
      Real sigma = If(segment->SigmaIndex<=0,1,
         Sqrt(VMatDat(sigma.full,segment->SigmaIndex,1)));
    //WriteLn("TRACE"+_MID+" draw.scalar 2.2");
      Polyn dif  = ARIMAGetDIF(arima);
      Set factor = arima[pd->factorNum];
      Set equIdx = segment->EquIdx;
      Set aux    = segment->ArimaAuxInfo;
      Set polRef = SetOfPolyn(If(pd->arma=="AR", factor->AR, factor->MA));
    //WriteLn("TRACE"+_MID+" draw.scalar 2.1 polRef[1]="<<polRef[1]);
      Real deg = pd->degree;
      Set bounds = ARMAProcess::StationarityBounds.2(polRef[1], factor->Periodicity, deg);
      Real L = bounds[1]+0.001;
      Real R = bounds[2]-0.001;
    //WriteLn("TRACE"+_MID+" draw.scalar 3 bounds=["<<L+","<<R+"]");
      Real m = aux::m;
      Real n = m - aux::difDegree;
      Matrix pdNoise_ = SubRow(noise_,equIdx);

      Real SetValue(Real x_)
      {
        Real x = If(1+x_==1, 0.000001, x_);
        Real pd->numEvalDens := pd->numEvalDens+1;
        Real PutCoef(polRef[1], deg, -x);
        Real isStationary = IsStationary(polRef[1]);
/*
        If(!isStationary, Real CMsg::Coded::show
          (BysMcmc::_.cmsg::_.nonStationaryDraw,[[_MID,pd->name,pol,x]]));
        WriteLn("TRACE"+_MID+" SetValue("<<x+") isStationary:"<<isStationary);
*/
        isStationary
      };

      Matrix z = Sub(DifEq(dif/1,pdNoise_),aux::difDegree+1,1,n,1);
      VMatrix z_ = Mat2VMat(z);
      Polyn  ar = ARIMAGetAR(arima);
      Polyn  ma = ARIMAGetMA(arima);
      NameBlock almagro = ARMAProcess::Eval.Almagro(ar,ma,z_,sigma);

      VMatrix u0 = If(oldResBlockNum == pd->resBlockNum,
      {
        aux::u0
      },
      {
        aux::u0 := almagro::Draw.U_cond_Z(0);
        If(_.config::bsr.arimaStoreInitialValues, 
        {
          _.U0 := _.U0 << aux::u0
        });
        aux::u0  
      });  
      Real oldResBlockNum := pd->resBlockNum;
      VMatrix z0 = almagro::Get.Z0(u0);
      VMatrix a0 = almagro::Get.A0(u0);
    //WriteLn("TRACE"+_MID+" draw.scalar almagro::_.p="<<almagro::_.p);
    //WriteLn("TRACE"+_MID+" draw.scalar almagro::_.q="<<almagro::_.p);
    //WriteLn("TRACE"+_MID+" draw.scalar almagro::_.z0="<<almagro::_.z0);
    //WriteLn("TRACE"+_MID+" draw.scalar almagro::_.a0="<<almagro::_.a0);
    //WriteLn("TRACE"+_MID+" draw.scalar u0="<<u0);
    //WriteLn("TRACE"+_MID+" draw.scalar z0="<<z0);
    //WriteLn("TRACE"+_MID+" draw.scalar a0="<<a0);

      Real LogDens.Almagro.Z_cond_U(Real x)
      {
        Real If(!SetValue(x), -1/0, {
          Polyn  ar = ARIMAGetAR(arima);
          Polyn  ma = ARIMAGetMA(arima);
          Real llh = Copy(almagro::LogLH.Z_cond_U(ar,ma,z0,a0));
          llh 
        }) 
      };
      Code LogDens = LogDens.Almagro.Z_cond_U;
      Real If(Or(pd->coef<L,pd->coef>R), { pd->coef := Rand(L,R) }, 0);
      
      Real pd->coef:= If(Degree(polRef[1])<=2,
      {
        _scalarSampler::sample(LogDens,L,R,pd->coef)
      },
      {
        AsymptoticSampler1D(LogDens,L,R)
      });

      Real isStationary = {
        Real PutCoef(polRef[1], deg, -pd->coef);
        Real isStationary = IsStationary(polRef[1]);
      //WriteLn("TRACE"+_MID+" pd->coef "<<pd->coef);
      //WriteLn("TRACE"+_MID+" isStationary "<<isStationary);
        isStationary
      };

      
    //WriteLn("TRACE"+_MID+" draw.scalar pd->coef="<<pd->coef);
      pd->coef
    });

    Matrix If(_.config::bsr.arimaStoreInitialValues,
    {
      Case(
      numSim==1,
      {
        _.U0.mcmc := Rand(0,VRows(_.U0),0,0);
        _.U0.cache := VMat2Mat(_.U0,True)
      },
      numSim%100,
      {
        _.U0.cache := _.U0.cache << VMat2Mat(_.U0,True)
      },
      1==1,
      {
        _.U0.mcmc := _.U0.mcmc << _.U0.cache;
        _.U0.cache := Rand(0,VRows(_.U0),0,0)
      })
    });
  //Real show.arma(0);
    Matrix values = SetCol(arma.draw.all);
  //WriteLn("TRACE"+_MID+" draw 3 "<<Matrix Tra(values));
    Mat2VMat(values)
  };


  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw =
  "Method of generation of arima block";
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    draw.scalar(numSim, _.ws::_.noise, _.ws::_.sigma.full)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setMcmcRow =
  "Sets _.store to the columns related to this block of a given row of a "
  "Markov Chain";
  Real setMcmcRow(Matrix mcmc, Real row) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Real setStore(getMcmcRow(mcmc, row))
  };

  ////////////////////////////////////////////////////////////////////////////
  //This note applys over all following methods 
  ////////////////////////////////////////////////////////////////////////////
  Static Text _explain.param ="\n"+
  "Used parameters are the currently stored, but you can set a previously "
  "simulated vector of parameters calling before to method "
  "setMcmcRow. You also can set an arbitrary row vector of parameters using "
  "method setStore, but then you must ensure that it's a valid set of "
  "values.";

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getARIMA =
  "Returns ARIMA definition of a given block of equations containinig a set "
  "of @ARIMAStruct's, please don´t modified it!."+_explain.param;
  Set getARIMA(Real noiseBlockIndex) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Set segment = _.NoiseDistrib[noiseBlockIndex];
    segment->Arima
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getAuxARIMAInfo =
  "Returns auxiliar ARIMA information about a given block of equations "
  "containing aggreated dif, ar and ma polynomials and its degrees "
  "and other internal information that you should not touch."+_explain.param;
  Set getAuxARIMAInfo(Real noiseBlockIndex) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Set segment = _.NoiseDistrib[noiseBlockIndex];
    segment->ArimaAuxInfo
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.difEq.ARI.MA =
  "Solves difference equations of direct ARIMA process of a given block of "
  "regression equations:\n"
  " Z = (theta(B)/(phi(B)*delta(B)))*E "+_explain.param;
  Matrix difEq.ARI.MA
  (
    Real   noiseBlockIndex, 
    Matrix E, 
    Matrix E0, 
    Matrix Z0
  )
  ////////////////////////////////////////////////////////////////////////////
  {
    Set segment = _.NoiseDistrib[noiseBlockIndex];
    Set aux = segment->ArimaAuxInfo;
    If(Or(aux::difDegree,aux::p,aux::q),
    {
      DifEq(aux::ma/(aux::dif*aux::ar), E, E0, Z0)
    },
    {
      E
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.difEq.ARI.MA.0 =
  "Is equal than difEq.ARI.MA but using zeroes as initial values."+
  _explain.param;
  Matrix difEq.ARI.MA.0
  (
    Real   noiseBlockIndex, 
    Matrix E
  )
  ////////////////////////////////////////////////////////////////////////////
  {
    Set segment = _.NoiseDistrib[noiseBlockIndex];
    Set aux = segment->ArimaAuxInfo;
    If(Or(aux::difDegree,aux::p,aux::q),
    {
      Matrix E0 = Rand(aux::q,1,0,0);
      Matrix Z0 = Rand(aux::p+aux::difDegree,1,0,0);
      DifEq(aux::ma/(aux::dif*aux::ar), E, E0, Z0)
    },
    {
      E
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.difEq.MA.ARI =
  "Solves difference equations of inverse ARIMA process of a given block of "
  "regression equations:\n"
  " E = ((phi(B)*delta(B))/theta(B))*Z "+_explain.param;
  Matrix difEq.MA.ARI
  (
    Real   noiseBlockIndex, 
    Matrix Z, 
    Matrix Z0, 
    Matrix E0
  )
  ////////////////////////////////////////////////////////////////////////////
  {
    Set segment = _.NoiseDistrib[noiseBlockIndex];
    Set aux = segment->ArimaAuxInfo;
    If(Or(aux::difDegree,aux::p,aux::q),
    {
      DifEq((aux::dif*aux::ar)/aux::ma, Z, Z0, E0)
    },
    {
      Z
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.difEq.MA.ARI.0 =
  "Is equal than difEq.MA.ARI but using zeroes as initial values."+
  _explain.param;
  Matrix difEq.MA.ARI.0
  (
    Real   noiseBlockIndex, 
    Matrix Z
  )
  ////////////////////////////////////////////////////////////////////////////
  {
    Set segment = _.NoiseDistrib[noiseBlockIndex];
    Set aux = segment->ArimaAuxInfo;
    If(Or(aux::difDegree,aux::p,aux::q),
    {
      Matrix E0 = Rand(aux::q,       1,0,0);
      Matrix Z0 = Rand(aux::p+aux::difDegree,1,0,0);
      DifEq((aux::dif*aux::ar)/aux::ma, Z, Z0, E0)
    },
    {
      Z
    })
  };

  //////////////////////////////////////////////////////////////////////////////
  Static @BlockArima Null(Real unused)
  //////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::Gibbs::@BlockArima blk = [[
    BysMcmc::Options::@Scalar.Sampler _scalarSampler = 
      BysMcmc::Options::Scalar.Sampler::Slice;
    Set _.NoiseDistrib = Copy(Empty);
    Set _.arimaStructBlock = Copy(Empty);
    Text _MID = "";
    Real    _.C          = ?;
    Real    _.m          = ?;
    Real _defined = ?;
    Real _.updateAll = ?
  ]]};

  //////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.New =
  "Builds a NameBlock that can draw a Gibbs sample of a ARIMA block of a "
  "general regression model. Just ARIMA filtering is currently running but "
  "ARMA simulation is still not implemented";
  //////////////////////////////////////////////////////////////////////////////
  Static @BlockArima New(
    Text name, 
    Set NoiseDistrib, 
    BysMcmc::@McmcPartialHandler mcmcPartialHandler,
    Real numBlock, 
    Real firstCol,
    BysMcmc::@Config config)
  //////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::Gibbs::@BlockArima blk = [[
    BysMcmc::Options::@Scalar.Sampler _scalarSampler = 
      config::bsr.scalarSampler.armaBlock;
    //Selects noise with constant sigma
    Set _.NoiseDistrib = NoiseDistrib;
    Set _.arimaStructBlock = 
    {
      BysMcmc::@Config _.config := Copy(config);

    //WriteLn("TRACESelecting noise with known wariance");
      Select(NoiseDistrib, Real(@BSR.NoiseDistrib segment)
      { Card(segment->Arima)>0 })
    };

    //Message identificator
    Text _MID = "["+name+"] ";
    //Number of variant variances (dimension of sigma block)
    Real    _.C          = Card(_.arimaStructBlock);
    Real    _.m          = VRows(_.NoiseDistrib[1]->Li);
    //Defining the block in the Markov Chain
    Real _defined = {
      Real prepare(0);
      define
      (
        name,
        EvalSet(_.paramDesc, Text set.colName(@ArmaParamDescStruct pd) { pd->name }),
        mcmcPartialHandler,
        numBlock,
        firstCol,
        config
      )};
    Real _.updateAll = 
    {
    //WriteLn("TRACE "+_MID+" initial _.paramDesc = "<<_.paramDesc);
      Matrix values = SetCol(EvalSet(_.paramDesc, Real (@ArmaParamDescStruct pd)
      {
        pd->coef
      }));
    //WriteLn("TRACE "+_MID+" initial values = "<<values);
      setStore(values)
    }

  ]]}

};
