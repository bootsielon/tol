/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// MODULE: Stat (Statistics)
// FILE: _inputMissingBlock.tol
// PURPOSE: Declares method BysMcmc::Bsr::Gibbs::InputMissingBlock
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.InputMissingBlock =
"Builds a NameBlock that can draw a Gibbs sample of a Input Missing block "
"of a Bayesian Sparse Regression model";
//////////////////////////////////////////////////////////////////////////////
  NameBlock InputMissingBlock(Text name, Set inputMissingBlock, 
                              Real numBlock, Real firstCol,
                              NameBlock config)
//////////////////////////////////////////////////////////////////////////////
{
  If(!Card(inputMissingBlock), [[
  NameBlock _.lin.blk = BysMcmc::Bsr::Gibbs::StdLinearBlock(
    name, 
    EvalSet(inputMissingBlock, Text(BSR.MissingBlock b){ b->Name }), 
    numBlock, 
    firstCol, 
    config);
  NameBlock _.blockDef = _.lin.blk::_.blockDef;
  Real initialize(Real unused){ 0 };
  VMatrix filter(VMatrix X) { X };
  VMatrix draw(Real numSim,NameBlock arima,VMatrix si,VMatrix beta,VMatrix Z) 
  { _.blockDef::_.store }
  ]], [[
  //Defining the block in the Markov Chain
  NameBlock _.lin.blk = BysMcmc::Bsr::Gibbs::StdLinearBlock(
    name, 
    EvalSet(inputMissingBlock, Text(BSR.MissingBlock b){ b->Name }), 
    numBlock, 
    firstCol, 
    config);
  NameBlock _.blockDef = _.lin.blk::_.blockDef;
  //Message identificator
  Text _MID = "["+_.blockDef::_.name+"] ";
  //Number of input missing variables (dimension of input missing block)
  Real _.N = Card(_.modelDef->InputMissingBlock);
  //Logarithm of density of last generated vector
  Real _.betaLogDens = -1/0;

  Real _.MH.useAfterIter = Max(1,config::bsr.linBlk.MH.useAfterIter);
  Real _.MH.maxRejected  = config::bsr.linBlk.MH.maxRejected;
  Real _.MH.maxConsecutive  = config::bsr.linBlk.MH.maxConsecutive;
  Real _.MH.tried = 0;
  Real _.MH.rejected = 0;
  Real _.MH.success = 0;
  Real _.MH.consecutive = 0;
  Real _.calculatedSimulation = 0;

  //Input missing pairs (equation,variable)
  Matrix _.tj = {
  //WriteLn("TRACE "+_MID+" 1");
    SetMat(Extract(inputMissingBlock, 3,4))
  };
  //Input missing pairs (equation,missing)
  Matrix _.tk = 
  {
  //WriteLn("TRACE "+_MID+" 2");
    SetMat(Extract(inputMissingBlock, 3,2))
  };
  //Input missing index j
  Set _.j = Traspose(Extract(inputMissingBlock, 4))[1];
  //Selecting input missing variables with prior information
  Set _.prior.sel = Select(inputMissingBlock, Real(BSR.MissingBlock b)
  {
    b->Prior != "None"
  });
  //Number of input missing prior equations
  Real _.prior.M = Card(_.prior.sel);
  //Average vector of input missing priors
  Matrix _.prior.nu = If(Not(_.prior.M),Rand(0,1,0,0),
  {
  //WriteLn("TRACE "+_MID+" 3");
    SetMat(Extract(_.prior.sel, 6))
  });
  //Inverse of standard deviation vector of input missing priors
  Matrix _.prior.si = If(Not(_.prior.M),Rand(0,1,0,0),
  {
  //WriteLn("TRACE "+_MID+" 4");
    Matrix s2 = SetMat(Extract(_.prior.sel, 7));
    RPow(s2,-1/2)
  });
  //Standarized output of input missing priors
  VMatrix _.prior.Y = If(Not(_.prior.M),Rand(0,1,0,0), 
    Mat2VMat(_.prior.nu $* _.prior.si));
  //Standarized input of input missing priors
  VMatrix _.prior.X = If(Not(_.prior.M),Rand(0,_.N,0,0),
  {
  //WriteLn("TRACE "+_MID+" _.prior.X 1");
  //WriteLn("TRACE "+_MID+" 5");
    Matrix aux1= SetMat(Traspose([[Set Range(1,_.prior.M,1)]]));
  //WriteLn("TRACE "+_MID+" 6");
    Matrix aux2= SetMat(Extract(_.prior.sel, 2));
    Matrix triplet =  aux1 | aux2 | _.prior.si;
  //WriteLn("TRACE "+_MID+" _.prior.X 2 triplet=\n"<<triplet);
    VMatrix tr = Triplet(triplet,_.prior.M,_.N);
  //WriteLn("TRACE "+_MID+" _.prior.X 3");
    VMatrix pX = Convert(tr,"Cholmod.R.Sparse");
  //WriteLn("TRACE "+_MID+" _.prior.X 4");
    pX
  });

  ////////////////////////////////////////////////////////////////////////////
  VMatrix getStore(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    _.lin.blk::_.blockDef::_.store
  };

  ///////////////////////////////////////////////////////////////////////////
  Real initialize(Real unused)
  ///////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" _.lin.blk.initialize 1");
    //Given initial values of block variables
  //WriteLn("TRACE "+_MID+" 7");
    VMatrix u = Mat2VMat(SetMat(Extract(inputMissingBlock, 6)));
    //Selecting input missing variables with left truncated prior information
    Set leftConstrainedPrior.sel = 
      Select(_.prior.sel, Real(BSR.MissingBlock b)
      {
        GT(b->MinBound,-1/0)
      });
    //Selecting input missing variables with right truncated prior information
    Set rightConstrainedPrior.sel = 
      Select(_.prior.sel, Real(BSR.MissingBlock b)
      {
        LT(b->MaxBound,1/0)
      });
  //WriteLn("TRACE "+_MID+" _.lin.blk.initialize 2");
    //Number of input missing with left constrained prior 
    Real left.R = Card(leftConstrainedPrior.sel);
    //Number of input missing with left constrained prior 
    Real right.R = Card(rightConstrainedPrior.sel);
    //Number of input missing with constrained prior 
    Real R = left.R + right.R;
    //Border of input missing constrains
    VMatrix prior.a = If(!R, Rand(0,0,0,0), 
    {
    //WriteLn("TRACE "+_MID+" 8");
      VMatrix aux1=If(!left.R,  Rand(0,1,0,0), 
        (-Mat2VMat(SetMat(Extract(leftConstrainedPrior.sel,  8)))));
    //WriteLn("TRACE "+_MID+" 9");
      VMatrix aux2=If(!right.R, Rand(0,1,0,0), 
        (+Mat2VMat(SetMat(Extract(rightConstrainedPrior.sel, 9)))));
      aux1<<aux2
    });
  //WriteLn("TRACE "+_MID+" _.lin.blk.initialize 3");
    //Coefficients of input missing constrains
    VMatrix prior.A = If(!R, Rand(0,0,0,0), 
    {
      Set left.range  = Range(1,        left.R, 1);
      Set right.range = Range(1+left.R, R,      1);
    //WriteLn("TRACE "+_MID+" 10");
      Matrix left  = If(!left.R, Rand(0,3,0,0), 
                                 SetMat(Traspose([[left.range]])) | 
                                 SetMat(Extract(leftConstrainedPrior.sel, 2)) | 
                                 Rand(left.R,1,-1,-1));
    //WriteLn("TRACE "+_MID+" 11");
      Matrix right = If(!right.R, Rand(0,3,0,0),
                                  SetMat(Traspose([[right.range]])) | 
                                  SetMat(Extract(rightConstrainedPrior.sel, 2)) | 
                                  Rand(right.R,1,+1,+1));
      Convert(Triplet(left<<right,R,_.N),"Cholmod.R.Sparse")
    });
  //WriteLn("TRACE "+_MID+" _.lin.blk.initialize 4");
    Real ok = _.lin.blk::initialize(u,prior.A,prior.a);
  //WriteLn("TRACE "+_MID+" _.lin.blk.initialize 5");
    ok
  };
  Real _initialized = initialize(0);

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.filter =
  "Filter regression input with current missing block values. You can set a "
  "previously simulated vector of paramters calling before to method "
  "setMcmcRow";
  VMatrix filter(VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(Not(_.blockDef::enabled), X,
    {
      Matrix tr = _.tj | VMat2Mat(_.blockDef::_.store);
      VMatrix U =Triplet(tr,VRows(X),VColumns(X));
      X+Convert(U,"Cholmod.R.Sparse")
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.buildLinearSystem =
  "Builds linear system related to input missing block";
  NameBlock buildLinearSystem(NameBlock arima, //ArimaBlock filter
                              VMatrix   si,    //SigmaBlock filter
                              VMatrix   beta,  //Non filtered LinearBlock parameters 
                              VMatrix   Z      // 
  )
  ////////////////////////////////////////////////////////////////////////////
  {
    Real    M = VRows(Z);
    VMatrix b_= SubRow(beta, _.j);
    Matrix  b = VMat2Mat(b_);
  //WriteLn("TRACE "+_MID+" draw 2 b="<<b);
    VMatrix B = (Convert(Triplet(_.tk | b, M, _.N),"Cholmod.R.Sparse"));
  //WriteLn("TRACE "+_MID+" draw 3 B="<<B);
    VMatrix Y01 = arima::filter(si*Z) << _.prior.Y;
  //WriteLn("TRACE "+_MID+" draw 4 Y01="<<Y01);
    VMatrix X01 = arima::filter(si*B) << _.prior.X;
    [[Y01, X01]]
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.gibbs =
  "Method of Gibss simulation of input missing block";
  VMatrix draw.gibbs(Real numSim, NameBlock ls)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.MH.consecutive := 0;
    Real _.lin.blk::solve(numSim, ls::Y01, ls::X01);
    VMatrix _.blockDef::_.store := _.lin.blk::draw(numSim);
    VMatrix e = ls::Y01-ls::X01*_.blockDef::_.store;
    Real _.betaLogDens := MatSum(Log(f01(VMat2Mat(e))));
    _.blockDef::_.store
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.metropolis_hastings =
  "Method of Metroplois-Hastings simulation of input missing block";
  VMatrix draw.metropolis_hastings(Real numSim, NameBlock ls)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" draw.metropolis_hastings 1");
/* * /
    WriteLn(" numSim="<<numSim+
            " _.MH.success="<<_.MH.success+
            " _.MH.tried="<<_.MH.tried+
            " _.MH.rejected="<<_.MH.rejected+
            " _.MH.consecutive="<<_.MH.consecutive);
/* */
    Real _.MH.consecutive := _.MH.consecutive + 1;
    Real m = VRows(Y);
    VMatrix b = getStore(0);
    VMatrix ep = ls::Y01-ls::X01*b;
    Real p0 = -0.5*VMatDat(MtMSqr(ep),1,1);
    Real q0 = _.lin.blk::_.betaLogDens;
    Real s0 = Sqrt(-2*p0/m);
  //WriteLn(" s0="<<s0+" p0="<<p0+" q0="<<q0);
    Real p1 = ?;
    Real q1 = ?;
    Real accept = False;
    Real i = 1;
    While(Not(accept) & (i<=_.MH.maxRejected),
    {
      Real t0 = Copy(Time);
      Real _.lin.blk::changed.X := False;
      VMatrix b := _.lin.blk::draw(numSim);
      VMatrix ep := ls::Y01-ls::X01*b;
      Real p1 := -0.5*VMatDat(MtMSqr(ep),1,1);
      Real s1 = Sqrt(-2*p1/m);
      Real q1 := _.lin.blk::_.betaLogDens;
      Real a = Rand(0,1);
      Real c = Exp((p1+q0)-(p0+q1));
      Real s = Sqrt(gsl_ran_chisq(m)/m);
      Real accept := Case(
        s1 <= 1, True,
        s1 <= s, True,
        1  == 1, a<c);
      Real tm = Copy(Time) - t0;
/* * /
      WriteLn(" i="<<i+
              " s1="<<s1+
              " p1="<<p1+
              " q1="<<q1+
              " c="<<c+
              " a="<<a+
              " s="<<s+
              " accept="<<accept+
              " time="<<tm);
/* */
      Real _.MH.tried := _.MH.tried +1 ;
      Real _.MH.rejected = _.MH.rejected + Not(accept);
      Real i := i+1
    });
    If(accept, 
    {
      Real _.MH.success := _.MH.success + 1;
      Real _.betaLogDens := p1;
      b
    }, 
    {
      draw.gibbs(numSim, ls)
    })  
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw =
  "Method of generation of input missing block";
  VMatrix draw(Real      numSim, 
               NameBlock arima, //ArimaBlock filter
               VMatrix   si,    //SigmaBlock filter
               VMatrix   beta,  //Non filtered Main Linear Block parameters 
               VMatrix   Z)     //Non filtered noise 
  ////////////////////////////////////////////////////////////////////////////
  {
    If(Not(_.blockDef::enabled), _.blockDef::_.store,
    {
      NameBlock ls = buildLinearSystem(arima,si,beta,Z);
      Real _.calculatedSimulation := _.calculatedSimulation+1;
      If(And(_.calculatedSimulation >_.MH.useAfterIter,
             _.MH.consecutive <= _.MH.maxConsecutive),
        draw.metropolis_hastings(numSim, ls),
        draw.gibbs              (numSim, ls))
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setStore =
  "Sets _.store to the specified row vector of values";
  Real setStore(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.blockDef::_.numCol<=0,0,{
      _.blockDef::setStore(values) 
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setMcmcRow =
  "Sets _.store to the columns related to this block of a given row of a "
  "Markov Chain";
  Real setMcmcRow(Matrix mcmc, Real row) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Real setStore(_.blockDef::getMcmcRow(mcmc, row))
  }

]])};
