/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// MODULE: Stat (Statistics)
// FILE: _mainLinearBlock.tol
// PURPOSE: Declares method BysMcmc::Bsr::Gibbs::MainLinearBlock
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
//Method _.buildWorkSpace must create _.ws as an instance of this class
Class WorkSpace.ArimaReg : WorkSpace.LinReg
////////////////////////////////////////////////////////////////////////////
{
  NameBlock _.arm.blk
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.MainLinearBlock =
"Builds a NameBlock that can draw a Gibbs sample of the Main Linear block "
"of a Bayesian Sparse Regression model";
//////////////////////////////////////////////////////////////////////////////
  StdLinearBlock MainLinearBlock(
    Text name, 
    Set  varNames, 
    McmcPartialHandler mcmcPartialHandler,
    Real numBlock, 
    Real firstCol,
    Config config)
//////////////////////////////////////////////////////////////////////////////
{
  If(!Card(varNames), 
  BysMcmc::Bsr::Gibbs::StdLinearBlock.Default(name,numBlock,firstCol,config),
  BysMcmc::Bsr::Gibbs::StdLinearBlock blk = [[

  ////////////////////////////////////////////////////////////////////////////
  Real _do_buildWorkSpace(VMatrix Y,    //Non filtered output
                          VMatrix X,    //Non filtered input
                          BysMcmc::BlockSampler arm.blk) //ArimaBlock filter
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" MainLinearBlock::_do_buildWorkSpace 0");
    BysMcmc::Bsr::Gibbs::WorkSpace.ArimaReg wsar = 
    [[
      VMatrix _.Y = Y;
      VMatrix _.X = X;
      NameBlock _.arm.blk = arm.blk
    ]];
  //WriteLn("TRACE"+_MID+" MainLinearBlock::_do_buildWorkSpace 1");
    NameBlock _.ws := wsar;
  //WriteLn("TRACE"+_MID+" MainLinearBlock::_do_buildWorkSpace 2");
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real _buildWorkSpace(VMatrix Y,    //Non filtered output
                       VMatrix X,    //Non filtered input
                       BysMcmc::BlockSampler arm.blk) //ArimaBlock filter
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" MainLinearBlock::_buildWorkSpace 0");
    If(!_.N1,
    {
    //WriteLn("TRACE"+_MID+" MainLinearBlock::_buildWorkSpace 1");
      _do_buildWorkSpace(Y,X,arm.blk)
    },
    {
    //WriteLn("TRACE"+_MID+" MainLinearBlock::_buildWorkSpace 2");
      VMatrix b1 = _.partialSampler::_.fixedValues;
      VMatrix X1 = SubCol(X, _.i1);
      VMatrix X2 = SubCol(X, _.i2);
      VMatrix Y2 = Y - X1*b1;
      _do_buildWorkSpace(Y2,X2,arm.blk)
    })
  };
  Code _.buildWorkSpace = _buildWorkSpace;

  //Defining the block in the Markov Chain
  Real _define = define(
    name, 
    varNames, 
    mcmcPartialHandler,
    numBlock, 
    firstCol, 
    config);


  ////////////////////////////////////////////////////////////////////////////
  VMatrix standarize(VMatrix _Z) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    _.ws::_.arm.blk::filter(_Z)
  }

]])};
