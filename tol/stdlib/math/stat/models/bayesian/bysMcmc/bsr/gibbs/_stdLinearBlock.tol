/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdLib (Standard Library of TOL)
// MODULE: Stat (Statistics)
// FILE: _stdLinearBlock.tol
// PURPOSE: Declares class hierarchy BysMcmc::Bsr::Gibbs::@BlockStdLin
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
Class @WorkSpace.LinReg : @WorkSpace
////////////////////////////////////////////////////////////////////////////
{
  Text get.blockSamplerClassName(Real void) { "generic linear blocks" };
  VMatrix _.Y; //Output matrix
  VMatrix _.X; //Input matrix
  Real rows(Real unused) { VRows(_.Y) }; //Data length
  VMatrix standarize(VMatrix _Z) { _Z };

  //////////////////////////////////////////////////////////////////////////
  Static @WorkSpace.LinReg Null(Real unused)
  //////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::Gibbs::@WorkSpace.LinReg aux = 
    [[
      VMatrix _.Y = Rand(0,0,0,0);
      VMatrix _.X = Rand(0,0,0,0)
    ]]
  }
};

////////////////////////////////////////////////////////////////////////////
Class @Solution.LinReg
////////////////////////////////////////////////////////////////////////////
{
  Real    _.numSim;
  VMatrix _.Y; //Output matrix
  VMatrix _.X; //Input matrix
  VMatrix _.nu;
  Real    _.err;

  //////////////////////////////////////////////////////////////////////////
  Static @Solution.LinReg New(
  //////////////////////////////////////////////////////////////////////////
    Real    numSim,
    VMatrix Y,
    VMatrix X,
    VMatrix nu,
    Real    err
  )
  {
    BysMcmc::Bsr::Gibbs::@Solution.LinReg aux = 
    [[
      Real    _.numSim = numSim;
      VMatrix _.Y      = Y;
      VMatrix _.X      = X;
      VMatrix _.nu     = nu;
      Real    _.err    = err
    ]]
  };

  //////////////////////////////////////////////////////////////////////////
  Static @Solution.LinReg Null(Real unused)
  //////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::Gibbs::@Solution.LinReg::New
      ( ?,Rand(0,0,0,0),Rand(0,0,0,0),Rand(0,0,0,0),? )
  }
};

//////////////////////////////////////////////////////////////////////////////
Class @BlockStdLinSub
//////////////////////////////////////////////////////////////////////////////
{
  Static Text _.autodoc.class =
  "Builds a NameBlock that can draw a Gibbs sample of an standarized linear "
  "block of a general regression model with variant input and ouput regression "
  "matrices and optional but fixed constraining inequations.";
  Text _MID;
  Set _.ws = Copy(Empty);
  //Transformed restrictions
  VMatrix _.D = Rand(0,0,0,0);
  //Cholesky decomposition of current information matrix that is not
  //explicitely stored
  VMatrix _.L  = Rand(0,0,0,0);
  VMatrix _.Ls = Rand(0,0,0,0);
  //Preconditioning
  VMatrix _.H  = Rand(0,0,0,0);
  VMatrix _.Hs = Rand(0,0,0,0);
  //If you know that design matrix will be the same for all simulations you
  //should to set this member as TRUE to avoid unneeded Cholesky 
  //factorizations
  Real design.is.constant = False;
  //Matrix of linear system in last iteration
  VMatrix _old.X  = Rand(0,0,0,0); 
  //
  @Solution.LinReg _.solution = 
    BysMcmc::Bsr::Gibbs::@Solution.LinReg::Null(0);

  Real changed.X = True;

  Real usePreconditioning = ?;
  Real cholesky.warningFreq = ?;
  Real truncMNormal.gibbsNumIter = ?;
  //Maximum accepted rounding error for Choleski operations
  Real _.eps  = ?;
  //Current number of simulations with high rounding error in solution
  Real _.cholSolRoundErrNumWarn = 0;
  //Current maximum of rounding error in solution
  Real _.cholSolMaxRoundErr     = 0;
  //Current number of iterations which initial point is not feasible
  Real _.nonFeasibleInitialPointNum = 0;
  //Logarithm of density of last generated vector
  Real _.logDens.Q = -1/0;

  Real _.cacheLength = ?;
  Real _.MH.useAfterIter = ?;
  Real _.MH.maxRejected  = ?;
  Real _.MH.maxConsecutive = ?;
  Real _.MH.tried = 0;
  Real _.MH.rejected = 0;
  Real _.MH.success = 0;
  Real _.MH.consecutive = 0;
  Real _.calculatedSimulation = 0;

  Real drop_val = ?;

  //Freedom degree
  Real    _.N = ?;
  //Number of restrictions
  Real    _.R  = 0;
  //Matrix of coefficients of constraining inequations
  VMatrix _.A  = Rand(0,0,0,0); 
  //The transpose of _.A
  VMatrix _.At = Rand(0,0,0,0);
  //Matrix of border of constraining inequations
  VMatrix _.a  = Rand(0,1,0,0);
  //Last known valid initial point for constrained simulation
  VMatrix _.beta0 = Rand(0,1,0,0);
  VMatrix _.beta = Rand(0,1,0,0);

  ////////////////////////////////////////////////////////////////////////////
  Real putMID(Text mid)
  ////////////////////////////////////////////////////////////////////////////
  {
    Text _MID := mid;
    1
  };

  ////////////////////////////////////////////////////////////////////////////
    VMatrix _drop(VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  { 
    Drop(X, drop_val)
  };
  
  ////////////////////////////////////////////////////////////////////////////
  Real isFeasible(VMatrix beta)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatMax(_.A*beta - _.a)<=0
  };

  ////////////////////////////////////////////////////////////////////////////
  //Returns true if given solution matches constrains and store them
  Real matchConstrains(VMatrix beta0, VMatrix A, VMatrix a)
  ////////////////////////////////////////////////////////////////////////////
  {   
  //WriteLn("TRACE "+_MID+" matchConstrains 1 beta0="<<beta0);
    Real ok = TRUE;

    VMatrix  _.beta := beta0;
    Real    _.N    := VRows(beta0);
  //WriteLn("TRACE "+_MID+" matchConstrains 2 _.N="<<_.N);
    Real    _.R    := VRows(A);
  //WriteLn("TRACE "+_MID+" matchConstrains 3 _.R="<<_.R);
    VMatrix _.A    := A; 
  //WriteLn("TRACE "+_MID+" matchConstrains 4 _.A="<<_.A);
    VMatrix _.At   := Tra(A);
  //WriteLn("TRACE "+_MID+" matchConstrains 5 _.At="<<_.At);
    VMatrix _.a    := a;
  //WriteLn("TRACE "+_MID+" matchConstrains 7");
    VMatrix _.beta0 := If(!_.R, beta0,
    {
    //WriteLn("TRACE "+_MID+" matchConstrains 8.1");
      Real givenMatch = isFeasible(beta0);
    //WriteLn("TRACE "+_MID+" matchConstrains 8.2");
      If(givenMatch, 
      {
        WriteLn(_MID+"Given init values matches constrain inequations.");
        beta0
      },
      {
        WriteLn(_MID+"Given init values doesn't match constrain inequations."
                "Trying zero solution ...", "W");
        Real zeroMatch = VMatMax(-_.a)<=0;
        If(zeroMatch, 
        {
          WriteLn(_MID+"Zero solution matches constrain inequations.");
          Rand(_.N,1,0,0)
        },
        {
          WriteLn(_MID+"Zero init values doesn't match constrain inequations."
                  "Trying Polytope::FindFeasible solution ...", "W");
          VMatrix ff = Polytope::FindFeasible(_.A, _.a, beta0, _.N*10, FALSE);
          Real ffMatch = isFeasible(ff);
          If(ffMatch, 
          {
            WriteLn(_MID+"Polytope::FindFeasible solution matches constrain inequations.");
            ff
          },
          {
            WriteLn(_MID+"Polytope::FindFeasible init values doesn't match constrain inequations.","W");
            Real ok := FALSE;
            beta0
          })
        })
      })
    });
  //WriteLn("TRACE "+_MID+" matchConstrains 9");
    ok
  };

  ////////////////////////////////////////////////////////////////////////////
  //Update Cholesky factorization matrix _.L 
  //If design matrix is assumed as constant does it just the first time
  Real factorize(VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" factorize X("<<VRows(X)+"x"<<VColumns(X)+"):"<<X);
    If(And(design.is.constant,VRows(_.L)), 0,
    {
    //WriteLn("TRACE"+_MID+" factorize 1");
      Real changed.X := If(Or(VColumns(X)!=VColumns(_old.X),
                              VRows   (X)!=VRows   (_old.X)), -1,
      {
      //WriteLn("TRACE"+_MID+" factorize 2.1");
        1+VMatMax(Abs(X-_old.X))-1
      });
    //WriteLn("TRACE"+_MID+" factorize 3");
      If(!changed.X ,0,
      {
      //WriteLn("TRACE"+_MID+" factorize 4.1");
        Real density = VNonNullCells(X)/(VRows(X)*VColumns(X));
      //WriteLn("TRACE "+_MID+" factorize 4.2 density = "<<density);
        If(And(usePreconditioning,VRows(_.L)),
        {
        //WriteLn("TRACE"+_MID+" factorize 5.1");
          VMatrix Hs = _.Ls;
          VMatrix H  = _.L;
        //WriteLn("TRACE"+_MID+" factorize 5.2");
          VMatrix G  = Tra(CholeskiSolve(H,Tra(X),"PtL"));
        //WriteLn("TRACE"+_MID+" factorize 5.3");
          Real density.G = VNonNullCells(G)/(VRows(G)*VColumns(G));
        //WriteLn("TRACE "+_MID+" factorize density G = "<<density.G);
        //WriteLn("TRACE"+_MID+" factorize 5.4");
          VMatrix S  = CholeskiFactor(G,"XtX");
        //WriteLn("TRACE"+_MID+" factorize 5.5");
          VMatrix Ss = CholeskiSolve(S,Convert(S, "Cholmod.R.Sparse"),"P");
        //WriteLn("TRACE"+_MID+" factorize 5.6");
          VMatrix _.Ls := Hs*Ss;
        //WriteLn("TRACE"+_MID+" factorize 5.7");
          VMatrix _.L  := _.Ls;
          1 
        },        
        {
        //WriteLn("TRACE"+_MID+" factorize 6.1");
          Real numErr = Copy(NError);
          VMatrix _.L := If(density<.13, 
          {
          //WriteLn("TRACE"+_MID+" factorize 6.2.1 X("<<VRows(X)+"x"<<VColumns(X)+"):"<<X);
            CholeskiFactor(X,"XtX")
          },
          {/*
            Text path = TolAppDataPath+"tmp/"+ToName(_MID)+"_dense_factorize.oza";
            WriteLn(_MID+"Dense factorization matrix will be stored into "+path);
            Real Ois.Store([[X]],path); */
          //WriteLn("TRACE"+_MID+" factorize 6.2.3");
            VMatrix X_   = Convert(X,"Blas.R.Dense");
          //WriteLn("TRACE"+_MID+" factorize 6.2.4");
            VMatrix XtX_ = MtMSqr(X_);
          //WriteLn("TRACE"+_MID+" factorize 6.2.5");
            VMatrix XtX = Convert(XtX_,"Cholmod.R.Sparse");
          //WriteLn("TRACE"+_MID+" factorize 6.2.6");
            CholeskiFactor(XtX,"X")
          });
          Real If(Copy(NError)>numErr,
          {
            Text path = TolAppDataPath+"tmp/"+ToName(_MID)+"_error_factorize.oza";
            WriteLn(_MID+"Failed factorization matrix will be stored into "+path);
            Ois.Store([[X]],path)
          });
          VMatrix If(_.R, 
          {
          //WriteLn("TRACE"+_MID+" factorize 7.1");
            _.Ls := CholeskiSolve(_.L,Convert(_.L, "Cholmod.R.Sparse"),"P")
          });
        //WriteLn("TRACE"+_MID+" factorize 8.1");
          VMatrix _old.X := X;
          1
        })
      })
    }) 
  };

  ////////////////////////////////////////////////////////////////////////////
  //Solves the linear system corresponding to the standarized linear regression
  Real solve(Real numSim, VMatrix Y, VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" solve 1.1 Y("<<VRows(Y)+"x"<<VColumns(Y)+")");
  //WriteLn("TRACE "+_MID+" solve 1.2 X("<<VRows(X)+"x"<<VColumns(X)+")");
    Real Do factorize(X);
  //WriteLn("TRACE "+_MID+" solve 2");
    Real If(VRows(_.L)<=0, CMsg::Coded::show
      (BysMcmc::_.cmsg::_.invCholFac,[[_MID,""]]));
  //WriteLn("TRACE "+_MID+" solve 3");
    Real If(numSim==1, _.cholSolRoundErrNumWarn := 0 );

  //WriteLn("TRACE "+_MID+" solve 4");
    VMatrix XtY  = Tra(Tra(Y)*X);
  //WriteLn("TRACE "+_MID+" solve 5 XtY="<<Matrix(VMat2Mat(Tra(XtY))));
    VMatrix nu = CholeskiSolve(_.L,XtY,"PtLLtP");
  //WriteLn("TRACE "+_MID+" solve 6 nu="<<Matrix(VMat2Mat(Tra(nu))));
    Real    err = VMatMax(Abs(XtY-Tra(Tra(X*nu)*X)));
  //WriteLn("TRACE "+_MID+" solve 7 err="<<err);
    Real If(err>=_.eps, 
    {
      Real _.cholSolRoundErrNumWarn := _.cholSolRoundErrNumWarn+1;
      Real _.cholSolMaxRoundErr := Max(_.cholSolMaxRoundErr,err);
      0
    });
    Real If(numSim & !(numSim%cholesky.warningFreq),
    {
      If(_.cholSolRoundErrNumWarn,
        WriteLn(_MID+"Cholesky solving had rounding error in interval ["<<
          _.eps + ","<<_.cholSolMaxRoundErr+" for "<<_.cholSolRoundErrNumWarn+
          " times of "<<numSim,"W"));
      If(_.nonFeasibleInitialPointNum,
        WriteLn(_MID+"Initial point was not feasible for "<<_.nonFeasibleInitialPointNum+
          " times of "<<numSim,"W"));
      0
    });
  //WriteLn("TRACE "+_MID+" solve 8");
    BysMcmc::Bsr::Gibbs::@Solution.LinReg _.solution := 
      BysMcmc::Bsr::Gibbs::@Solution.LinReg::New(numSim,Y,X,nu,err);
  //WriteLn("TRACE "+_MID+" solve 9");
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.gibbs.unconstrained =
  "Method of generation of a linear block in unconstrained case";
  VMatrix draw.gibbs.unconstrained(Real numSim, VMatrix nu)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" draw.unconstrained 1");
    VMatrix z = Gaussian(_.N,1,0,1);
  //WriteLn("TRACE "+_MID+" draw.unconstrained 2 z="<<VMat2Mat(z));
    Real _.logDens.Q := -0.5*VMatDat(MtMSqr(z),1,1);
  //WriteLn("TRACE "+_MID+" draw.unconstrained 3 nu="<<VMat2Mat(nu));
    VMatrix _.beta:=nu+CholeskiSolve(_.L,z,"LtP");
  //WriteLn("TRACE "+_MID+" draw.unconstrained 2 _.beta="<<VMat2Mat(_.beta));
    Copy(_.beta)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.gibbs.constrained =
  "Method of generation of a linear block in constrained case";
  VMatrix draw.gibbs.constrained(Real numSim, VMatrix nu)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 1");
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 1.1 _.A("<<VRows(_.A)+"x"<<VColumns(_.A)+")");
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 1.2 _.a("<<VRows(_.a)+"x"<<VColumns(_.a)+")");
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 1.3 nu ("<<VRows( nu)+"x"<<VColumns( nu)+")");
    VMatrix d   = _.a - _.A*nu;
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 2");
    VMatrix If(changed.X, _.D  := Tra(CholeskiSolve(_.L,_.At,"PtL")));
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 3");
    VMatrix z0  = Tra(Tra(_.beta-nu)*_.Ls);
    Real feasible0 = Polytope::IsFeasible(_.D,d,z0);
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 3.1 feasible0="<<feasible0);
    Real If(!feasible0,
    {
    //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 3.2");
      Real _.nonFeasibleInitialPointNum := _.nonFeasibleInitialPointNum +1;
    //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 3.3");
      VMatrix z0 := Polytope::FindFeasible(_.D, d, z0, 10*_.N, FALSE);
    //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 3.4");
      1
    });
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 4 truncMNormal.gibbsNumIter="<<truncMNormal.gibbsNumIter);
    VMatrix z = TruncStdGaussian(_.D,d,z0,1,truncMNormal.gibbsNumIter);
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 5");
    Real feasible = Polytope::IsFeasible(_.D,d,z);
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 6 feasible="<<feasible);
    Real If(feasible,
    {
    //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 7");
      VMatrix _.beta0 := _.beta;
      1
    },
    {
      WriteLn(_MID+" Found a point that doesn't match constrains Max(D*z-d)="<<
        VMatMax(_.D*z-d)+"\n Trying again");
      If(!VRows(_.beta0),0,
      {
      //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 8");
        VMatrix z0 := Tra(Tra(_.beta0-nu)*_.Ls);
      //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 9");
        VMatrix z := TruncStdGaussian(_.D,d,z0,1,truncMNormal.gibbsNumIter);
        1
      });
      1
    }) ;
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 10");
    Real _.logDens.Q := -0.5*VMatDat(MtMSqr(z),1,1);
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 11");
    VMatrix  _.beta := nu + CholeskiSolve(_.L,z,"LtP");
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 12 _.beta="<<VMat2Mat(_.beta));
    Copy(_.beta)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.gibbs.drawer =
  "Method of generation of a linear block in any case";
  VMatrix gibbs.drawer(Real numSim, VMatrix nu)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.R, draw.gibbs.constrained  (numSim, nu), 
            draw.gibbs.unconstrained(numSim, nu))  
  };

  ////////////////////////////////////////////////////////////////////////////
  //Return standarized residuals of linear reggression for a given vector of
  //parameters 
  VMatrix getStdResiduals(VMatrix b)
  ////////////////////////////////////////////////////////////////////////////
  {
    @WorkSpace.LinReg ws = _.ws[1];
  //WriteLn("TRACE "+_MID+" @BlockStdLinSub::getStdResiduals");
    ws::standarize(ws::_.Y-ws::_.X*b)    
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.gibbs =
  "Method of Gibss simulation of output missing block";
  VMatrix draw.gibbs(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    @WorkSpace.LinReg ws = _.ws[1];
  //WriteLn("TRACE "+_MID+" @BlockStdLinSub::draw.gibbs");
  //WriteLn("TRACE "+_MID+" draw.gibbs 1 ws::_.Y=" << ws::_.Y);
    VMatrix Y01 = ws::standarize(ws::_.Y);
  //WriteLn("TRACE "+_MID+" draw.gibbs 2 Y01=" << Y01);
  //WriteLn("TRACE "+_MID+" draw.gibbs 3 ws::_.X=" << ws::_.X);
    VMatrix X01 = ws::standarize(ws::_.X);
  //WriteLn("TRACE "+_MID+" draw.gibbs 4 X01=" << X01);
    Real solve(numSim, Y01, X01);
  //WriteLn("TRACE "+_MID+" draw.gibbs 2");
    gibbs.drawer(numSim, _.solution::_.nu)
  };

  
  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.mh =
  "Method of Metroplois-Hastings simulation of output missing block";
  VMatrix draw.mh(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    @WorkSpace.LinReg ws = _.ws[1];
  //WriteLn("TRACE "+_MID+" @BlockStdLinSub::draw.mh");
  //WriteLn("TRACE "+_MID+" draw.mh 1");
/* * /
    WriteLn(" numSim="<<numSim+
            " _.MH.success="<<_.MH.success+
            " _.MH.tried="<<_.MH.tried+
            " _.MH.rejected="<<_.MH.rejected+
            " _.MH.consecutive="<<_.MH.consecutive);
/* */
    Real m = VRows(ws::_.Y);
  //WriteLn("TRACE "+_MID+" draw.mh 1");
  //WriteLn("TRACE "+_MID+" draw.mh 2");
    VMatrix e0 = getStdResiduals(_.beta);
  //WriteLn("TRACE "+_MID+" draw.mh 4");
    Real p0 = -0.5*VMatDat(MtMSqr(e0),1,1);

    Real mh.s = 0.5;
    VMatrix z = Gaussian(_.N,1,0,mh.s);
    VMatrix b1 = _.beta + CholeskiSolve(_.L,z,"LtP");
    Real isFeasible = Polytope::IsFeasible(_.A,_.a,b1);
    Real p1 = 1/0;
    Real a = 1;
    Real c = 0;
    Real accept = If(!isFeasible, 0,
    {
      VMatrix e1 = getStdResiduals(b1);
      Real p1 := -0.5*VMatDat(MtMSqr(e1),1,1);
      Real a := Rand(0,1);
      Real c := Exp(p1-p0);
      a<=c
    });
  //WriteLn("TRACE "+_MID+" a="<<a+" c="<<c+" accept="<<accept);
    If(accept, b1, _.beta)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw =
  "Method of generation of output missing block";
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" draw 1");
    Real _.calculatedSimulation := _.calculatedSimulation+1;
    If(And(_.calculatedSimulation >_.MH.useAfterIter,
           _.MH.consecutive <= _.MH.maxConsecutive),
    {
      Real _.MH.consecutive := _.MH.consecutive + 1;
      draw.mh   (numSim)
    },
    {
      Real _.MH.consecutive := 0;
      draw.gibbs(numSim)
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Static @BlockStdLinSub New(Text mid)
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::Gibbs::@BlockStdLinSub new = 
    [[ Text _MID = mid ]]
  }

};

//////////////////////////////////////////////////////////////////////////////
Class @BlockStdLinSubMTM : @MultiTryMetropolis, @BlockStdLinSub
//Implementation of multiple try Metropolis to an ARIMA model.
//Initial values of ARIMA difference equation are treated as a complementary 
//Gibbs block that will be simulated after each simulation or ARMA parameters
//////////////////////////////////////////////////////////////////////////////
{
  
  ////////////////////////////////////////////////////////////////////////////
  Static @BlockStdLinSubMTM New(Text mid)
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::Gibbs::@BlockStdLinSubMTM new = 
    [[ Text _MID = mid ]]
  };

  ////////////////////////////////////////////////////////////////////////////
  //Initialize all members to be congruent with a given ARIMA model
  Real initialize(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    //This is the theorical acceptance ratio for single-try
    setDefault(0);
    Real _.s := 0.1;
    Real _.sFactor := 1.001;
    Real _.k := Round(Sqrt(_.N));
    True
  };
  
  ////////////////////////////////////////////////////////////////////////////
  //MEMBERS AND METHODS INHERITED FROM @BlockStdLinSub
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.mh =
  "Method of Metroplois-Hastings simulation of output missing block";
  VMatrix draw.mh(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+"@BlockStdLinSubMTM::draw.mh");
    drawMultipleTry(0)
  };

  ////////////////////////////////////////////////////////////////////////////
  //MEMBERS AND METHODS INHERITED FROM @MultiTryMetropolis
  ////////////////////////////////////////////////////////////////////////////

  //Number of variables to be simulated
  Real get.n(Real void) { Copy(_.N) };
  //Returns current drawn values
  VMatrix get.x(Real void) { Copy(_.beta) };
  //Sets current drawn values
  Real set.x(VMatrix x) { VMatrix _.beta := Copy(x); True };

  ////////////////////////////////////////////////////////////////////////////
  //After each simulation does conversion to ARIMA if needed, and draws the 
  //Gibbs block of ARMA initial values
  Real doAfterDraw(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(Not(_.num_draw%_.cacheLength),
      WriteLn("  "+_MID+" Multiple-Try-Metropolis acceptance ratio="
      <<_.acceptRatio+" scale factor="<<_.s+" number of tries="<<_.k) );
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  //If L is Cholesky decomposition of Covariance matrix (COV = L * L') then
  //this function returns L * e
  //In this case _.L is the Choleski decomposition of information matrix
  VMatrix prodLVector (VMatrix vector)
  ////////////////////////////////////////////////////////////////////////////
  {  CholeskiSolve(_.L,vector,"LtP") };
  
  ////////////////////////////////////////////////////////////////////////////
  //target log-density (black-box)
  Real pi_logDens(VMatrix z)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real ok = If(!_.R, True, Polytope::IsFeasible(_.A,_.a,z));
  //WriteLn("TRACE "+_MID+"@BlockStdLinSubMTM::pi_logDens isFeasible="<<ok);
    Real logPi = If(!ok, -1/0,
    { 
       VMatrix e = getStdResiduals(z);
       -0.5*VMatDat(MtMSqr(e),1,1)
    });
  //WriteLn("TRACE "+_MID+"@BlockStdLinSubMTM::pi_logDens logPi="<<logPi);
    logPi
  }
};


//////////////////////////////////////////////////////////////////////////////
Class @BlockStdLin: @BlockSampler
//////////////////////////////////////////////////////////////////////////////
{
  Static Text _.autodoc.description =
  "Builds a NameBlock that can draw a Gibbs sample of an standarized linear "
  "block of a general regression model with variant input and ouput regression "
  "matrices and optional but fixed constraining inequations.";
  //--------------------------------------------------------------------------
  // Mandatory members
  //--------------------------------------------------------------------------
  //Work space stores all data needed to draw samples that are variant for
  //each simulation

  //--------------------------------------------------------------------------
  //Auxiliar members
  //--------------------------------------------------------------------------
  BysMcmc::Bsr::Gibbs::@BlockStdLinSub _.fullBlock = 
    BysMcmc::Bsr::Gibbs::@BlockStdLinSub::New(_MID+"[_.fullBlock] ");
  BysMcmc::Bsr::Gibbs::@BlockStdLinSubMTM _.freeBlock = 
    BysMcmc::Bsr::Gibbs::@BlockStdLinSubMTM::New(_MID+"[_.freeBlock] ");

  Set _.i1 = Copy(Empty); //_.partialSampler::getNonFreeIndex(0);
  Set _.i2 = Copy(Empty); //_.partialSampler::getFreeIndex(0);
  Real _.N1 = ?;
  Real _.N2 = ?;

  //Indexes of inequations related to free variables
  Set _.r2 = Copy(Empty);

  //--------------------------------------------------------------------------
  //Methods
  //--------------------------------------------------------------------------


  ////////////////////////////////////////////////////////////////////////////
  @WorkSpace.LinReg getWorkSpaceLinReg(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    WriteLn("Not implemented method "+_MID+"::getWorkSpaceLinReg",
            "E");
    BysMcmc::Bsr::Gibbs::@WorkSpace.LinReg::Null(0)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize.subBlocks(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    Real _.fullBlock::putMID(_MID+"[_.fullBlock] ");
    Real _.freeBlock::putMID(_MID+"[_.freeBlock] ");
    Set _.i1 := _.partialSampler::getNonFreeIndex(0);
    Set _.i2 := _.partialSampler::getFreeIndex(0);
    Real _.N1 := Card(_.i1);
    Real _.N2 := Card(_.i2);
    Real _.freeBlock::usePreconditioning := 
      _.config::bsr.linBlk.usePreconditioning;
    Real _.freeBlock::cholesky.warningFreq := 
      _.config::bsr.cholesky.warningFreq;
    Real _.freeBlock::truncMNormal.gibbsNumIter := Case(
      _.N2<=10, 10,
      _.N2<=100, 5, 
      1==1,      Max(1,_.config::bsr.truncMNormal.gibbsNumIter));
    Real _.freeBlock::drop_val := 
      _.config::bsr.linBlk.X.drop;
    Real _.freeBlock::_.eps := 
      _.config::bsr.cholesky.epsilon*_.N2*(_.N2+1);
    Real _.freeBlock::_.MH.useAfterIter := 
      Max(1,_.config::bsr.linBlk.MH.useAfterIter);
    Real _.freeBlock::_.MH.maxRejected := 
      _.config::bsr.linBlk.MH.maxRejected;
    Real _.freeBlock::_.MH.maxConsecutive := 
      _.config::bsr.linBlk.MH.maxConsecutive;
    Real _.freeBlock::_.cacheLength := 
      _.config::mcmc.cacheLength;
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    initialize.subBlocks(0)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real matchConstrains(VMatrix beta0, VMatrix A, VMatrix a)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 0");
    If(!_.N1,  
    {
    //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 1.1");
      Real ok = _.freeBlock::matchConstrains(beta0,A,a);
    //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 1.2");
      Real putStoreV(_.freeBlock::_.beta0);
      Real _.freeBlock::initialize(0);
    //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 1.3");
      ok
    },
    {
    //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 2.1");
      Real ok1 = _.fullBlock::matchConstrains(beta0,A,a);
    //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 2.2");
    //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 2.3");
      VMatrix b1 = SubRow(_.fullBlock::_.beta0, _.i1);
      Real ok2 = If(!ok1, False,
      {
        Case(!_.N2, True,
        !VRows(A),
        {
          VMatrix b2 = SubRow(_.fullBlock::_.beta0, _.i2);
          _.freeBlock::matchConstrains(b2,Rand(0,_.N2,0,0),Rand(0,1,0,0))
        },
        1==1,  
        {
        //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 2.4");
          VMatrix b2 = SubRow(_.fullBlock::_.beta0, _.i2);
        //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 2.5");
          VMatrix A1 = SubCol(A, _.i1);
        //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 2.6");
          VMatrix A2_ = SubCol(A, _.i2);
          VMatrix a2_ = a - A1*b1;
        //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 2.7");
          Matrix aux = VMat2Mat(Abs(A2_)*Rand(_.N2,1,1,1));
          Matrix nz  = NE(aux,Rand(_.fullBlock::_.R,1,0,0));
          Matrix idx = SetCol(Range(1,_.fullBlock::_.R,1));
          Set nz_idx = MatSet(Tra(nz $* idx))[1];
          Set _.r2 = Select(nz_idx,Real(Real j) { j>0 });
          VMatrix A2 = SubRow(A2_,_.r2);
          VMatrix a2 = SubRow(a2_,_.r2);
        //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 2.8");
          _.freeBlock::matchConstrains(b2,A2,a2)
        })
      });
    //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 2.9");
      VMatrix b_ = _.partialSampler::mergeWithFreeSample(_.freeBlock::_.beta0); 
    //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 2.10");
      Real putStoreV(b_);
    //WriteLn("TRACE"+_MID+" @BlockStdLin::matchConstrains 2.11");
      Real _.freeBlock::initialize(0);
      ok2
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set _.freeBlock::_.ws := [[ getWorkSpaceLinReg(0) ]];
  //WriteLn("TRACE"+_MID+" @BlockStdLin::draw 0");
    If(!_.N1,  
    {
    //WriteLn("TRACE"+_MID+" @BlockStdLin::draw 1.1");
    _.freeBlock::draw(numSim)
    },
    {
      Real ok = If(!_.N2, True,
      {
      //WriteLn("TRACE"+_MID+" @BlockStdLin::draw 2.1");
        VMatrix b1 = SubRow(_.partialSampler::_.values, _.i1);
        Real If(_.freeBlock::_.R,
        {
        //WriteLn("TRACE"+_MID+" @BlockStdLin::draw 2.2");
          VMatrix A1 = SubCol(_.fullBlock::_.A, _.i1);
        //WriteLn("TRACE"+_MID+" @BlockStdLin::draw 2.3");
          VMatrix a2_ = _.fullBlock::_.a - A1*b1;
          VMatrix _.freeBlock::_.a := SubRow(a2_,_.r2);
          True
        });
      //WriteLn("TRACE"+_MID+" @BlockStdLin::draw 2.4");
        True
      });
      _.freeBlock::draw(numSim)
    })
  }
};



//////////////////////////////////////////////////////////////////////////////
Class @BlockStdLinEmpty : @BlockStdLin
//////////////////////////////////////////////////////////////////////////////
{
  VMatrix draw(Real numSim) { Rand(0,1,0,0) };
  Real initialize.subBlocks(Real unused) { True };
  Real matchConstrains(VMatrix beta0, VMatrix A, VMatrix a) { True };

  //////////////////////////////////////////////////////////////////////////////
  Static @BlockStdLinEmpty New(
   Text name, 
   Real numBlock, 
   Real firstCol, 
   BysMcmc::@Config config)
  //////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::Gibbs::@BlockStdLinEmpty aux = 
    [[
      Real _defined = define(name, Empty, BysMcmc::@McmcPartialHandler::Null(0),
                            numBlock, firstCol, config)
    ]]
  }
};

