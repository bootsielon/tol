/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdLib (Standard Library of TOL)
// MODULE: Stat (Statistics)
// FILE: _stdLinearBlock.tol
// PURPOSE: Declares class hierarchy BysMcmc::Bsr::Gibbs::StdLinearBlock
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
//Method _.buildWorkSpace must create _.ws as an instance of this class
Class WorkSpace.LinReg
////////////////////////////////////////////////////////////////////////////
{
  VMatrix _.Y; //Output matrix
  VMatrix _.X; //Input matrix
  //Data length
  Real rows(Real unused)     
  {
    VRows(_.Y)
  }
};


////////////////////////////////////////////////////////////////////////////
Struct Solution.LinReg
////////////////////////////////////////////////////////////////////////////
{
  Real    numSim;
  VMatrix Y; //Output matrix
  VMatrix X; //Input matrix
  VMatrix nu;
  Real    err
};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.StdLinearSubBlock =
"Builds a NameBlock that can draw a Gibbs sample of an standarized linear "
"block of a general regression model with variant input and ouput regression "
"matrices and optional but fixed constraining inequations.";
//////////////////////////////////////////////////////////////////////////////
Class StdLinearSubBlock
//////////////////////////////////////////////////////////////////////////////
{
  Text _MID;
  //Transformed restrictions
  VMatrix _.D = Rand(0,0,0,0);
  //Cholesky decomposition of current information matrix that is not
  //explicitely stored
  VMatrix _.L  = Rand(0,0,0,0);
  VMatrix _.Ls = Rand(0,0,0,0);
  //Preconditioning
  VMatrix _.H  = Rand(0,0,0,0);
  VMatrix _.Hs = Rand(0,0,0,0);
  //If you know that design matrix will be the same for all simulations you
  //should to set this member as TRUE to avoid unneeded Cholesky 
  //factorizations
  Real design.is.constant = False;
  //Matrix of linear system in last iteration
  VMatrix _old.X  = Rand(0,0,0,0); 
  //
  Set _.solution = Copy(Empty);

  Real changed.X = True;

  Real usePreconditioning = ?;
  Real cholesky.warningFreq = ?;
  Real truncMNormal.gibbsNumIter = ?;
  //Maximum accepted rounding error for Choleski operations
  Real _.eps  = ?;
  //Current number of simulations with high rounding error in solution
  Real _.cholSolRoundErrNumWarn = 0;
  //Current maximum of rounding error in solution
  Real _.cholSolMaxRoundErr     = 0;
  //Logarithm of density of last generated vector
  Real _.logDens.Q = -1/0;
  //Stores the associated drawing method
  Real noDraw(Real unused) { ? };
  Code gibbs.drawer = noDraw;

  Real _.MH.useAfterIter = ?;
  Real _.MH.maxRejected  = ?;
  Real _.MH.maxConsecutive = ?;
  Real _.MH.tried = 0;
  Real _.MH.rejected = 0;
  Real _.MH.success = 0;
  Real _.MH.consecutive = 0;
  Real _.calculatedSimulation = 0;

  Real drop_val = ?;

  //Freedom degree
  Real    _.N = ?;
  //Number of restrictions
  Real    _.R  = 0;
  //Matrix of coefficients of constraining inequations
  VMatrix _.A  = Rand(0,0,0,0); 
  //The transpose of _.A
  VMatrix _.At = Rand(0,0,0,0);
  //Matrix of border of constraining inequations
  VMatrix _.a  = Rand(0,0,0,0);
  //Last known valid initial point for constrained simulation
  VMatrix _.beta0 = Rand(0,0,0,0);
  VMatrix _.beta = Rand(0,0,0,0);

  ////////////////////////////////////////////////////////////////////////////
  Real putMID(Text mid)
  ////////////////////////////////////////////////////////////////////////////
  {
    Text _MID := mid;
    1
  };

  ////////////////////////////////////////////////////////////////////////////
    VMatrix _drop(VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  { 
    Drop(X, drop_val)
  };

  ////////////////////////////////////////////////////////////////////////////
  //Returns true if given solution matches constrains and store them
  Real matchConstrains(VMatrix beta0, VMatrix A, VMatrix a)
  ////////////////////////////////////////////////////////////////////////////
  {   
  //WriteLn("TRACE "+_MID+" matchConstrains 1 beta0="<<beta0);
    Real ok = TRUE;

    VMatrix  _.beta := beta0;
    Real    _.N    := VRows(beta0);
  //WriteLn("TRACE "+_MID+" matchConstrains 2 _.N="<<_.N);
    Real    _.R    := VRows(A);
  //WriteLn("TRACE "+_MID+" matchConstrains 3 _.R="<<_.R);
    VMatrix _.A    := A; 
  //WriteLn("TRACE "+_MID+" matchConstrains 4 _.A="<<_.A);
    VMatrix _.At   := Tra(A);
  //WriteLn("TRACE "+_MID+" matchConstrains 5 _.At="<<_.At);
    VMatrix _.a    := a;
  //WriteLn("TRACE "+_MID+" matchConstrains 7");
    Code    gibbs.drawer := If(_.R, draw.gibbs.constrained, 
                                    draw.gibbs.unconstrained);
    VMatrix _.beta0 := If(!_.R, beta0,
    {
    //WriteLn("TRACE "+_MID+" matchConstrains 8.1");
      Real givenMatch = VMatMax(_.A*beta0 - _.a)<=0;
    //WriteLn("TRACE "+_MID+" matchConstrains 8.2");
      If(givenMatch, 
      {
        WriteLn(_MID+"Given init values matches constrain inequations.");
        beta0
      },
      {
        WriteLn(_MID+"Given init values doesn't match constrain inequations."
                "Trying zero solution ...", "W");
        Real zeroMatch = VMatMax(-_.a)<=0;
        If(zeroMatch, 
        {
          WriteLn(_MID+"Zero solution matches constrain inequations.");
          Rand(_.N,1,0,0)
        },
        {
          WriteLn(_MID+"Zero init values doesn't match constrain inequations.","W");
          Real ok := FALSE;
          beta0
        })
      })
    });
  //WriteLn("TRACE "+_MID+" matchConstrains 9");
    ok
  };

  ////////////////////////////////////////////////////////////////////////////
  //Update Cholesky factorization matrix _.L 
  //If design matrix is assumed as constant does it just the first time
  Real factorize(VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" factorize X("<<VRows(X)+"x"<<VColumns(X)+")");
    If(And(design.is.constant,VRows(_.L)), 0,
    {
      Real changed.X := If(Or(VColumns(X)!=VColumns(_old.X),
                               VRows   (X)!=VRows   (_old.X)), -1,
      {
        1+VMatMax(Abs(X-_old.X))-1
      });
      If(!changed.X ,0,
      {
        Real density = VNonNullCells(X)/(VRows(X)*VColumns(X));
      //WriteLn("TRACE "+_MID+" factorize density = "<<density);
        If(And(usePreconditioning,VRows(_.L)),
        {
          VMatrix Hs = _.Ls;
          VMatrix H  = _.L;
          VMatrix G  = Tra(CholeskiSolve(H,Tra(X),"PtL"));
          Real density.G = VNonNullCells(G)/(VRows(G)*VColumns(G));
        //WriteLn("TRACE "+_MID+" factorize density G = "<<density.G);
          VMatrix S  = CholeskiFactor(G,"XtX");
          VMatrix Ss = CholeskiSolve(S,Convert(S, "Cholmod.R.Sparse"),"P");
          VMatrix _.Ls := Hs*Ss;
          VMatrix _.L  := _.Ls;
          1 
        },        
        {
        //WriteLn("TRACE"+_MID+" factorize changed="<<changed.X );
          Real numErr = Copy(NError);
          VMatrix _.L := If(density<.13, 
          {
            CholeskiFactor(X,"XtX")
          },
          {/*
            Text path = TolAppDataPath+"tmp/"+ToName(_MID)+"_dense_factorize.oza";
            WriteLn(_MID+"Dense factorization matrix will be stored into "+path);
            Real Ois.Store([[X]],path); */
            VMatrix X_   = Convert(X,"Blas.R.Dense");
            VMatrix XtX_ = MtMSqr(X_);
            VMatrix XtX = Convert(XtX_,"Cholmod.R.Sparse");
            CholeskiFactor(XtX,"X")
          });
          Real If(Copy(NError)>numErr,
          {
            Text path = TolAppDataPath+"tmp/"+ToName(_MID)+"_error_factorize.oza";
            WriteLn(_MID+"Failed factorization matrix will be stored into "+path);
            Ois.Store([[X]],path)
          });
          VMatrix If(_.R, 
          {
            _.Ls := CholeskiSolve(_.L,Convert(_.L, "Cholmod.R.Sparse"),"P")
          });
          VMatrix _old.X := X;
          1
        })
      })
    }) 
  };

  ////////////////////////////////////////////////////////////////////////////
  //Solves the linear system corresponding to the standarized linear regression
  Real solve(Real numSim, VMatrix Y, VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" solve 1 ");
    Real Do factorize(X);
    Real If(VRows(_.L)<=0, CMsg::Coded::show
      (BysMcmc::_.cmsg::_.invCholFac,[[_MID,""]]));
    //WriteLn("TRACE "+_MID+" solve 3");
    Real If(numSim==1, _.cholSolRoundErrNumWarn := 0 );

  //WriteLn("TRACE "+_MID+" solve 4");
    VMatrix XtY  = Tra(Tra(Y)*X);
  //WriteLn("TRACE "+_MID+" solve 5 XtY="<<Matrix(VMat2Mat(Tra(XtY))));
    VMatrix nu = CholeskiSolve(_.L,XtY,"PtLLtP");
  //WriteLn("TRACE "+_MID+" solve 6 nu="<<Matrix(VMat2Mat(Tra(nu))));
    Real    err = VMatMax(Abs(XtY-Tra(Tra(X*nu)*X)));
  //WriteLn("TRACE "+_MID+" solve 7 err="<<err);
    Real If(err>=_.eps, 
    {
      Real _.cholSolRoundErrNumWarn := _.cholSolRoundErrNumWarn+1;
      Real _.cholSolMaxRoundErr := Max(_.cholSolMaxRoundErr,err);
      0
    });
    Real If(numSim & !(numSim%cholesky.warningFreq),
    {
      If(_.cholSolRoundErrNumWarn,
        WriteLn(_MID+"Cholesky solving had rounding error in interval ["<<
          _.eps + ","<<_.cholSolMaxRoundErr+" for "<<_.cholSolRoundErrNumWarn+
          " times of "<<numSim,"W"));
      0
    });
  //WriteLn("TRACE "+_MID+" solve 8");
    Set _.solution := 
      BysMcmc::Bsr::Gibbs::Solution.LinReg(numSim, Y, X, nu, err);
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.gibbs.unconstrained =
  "Method of generation of a linear block in unconstrained case";
  VMatrix draw.gibbs.unconstrained(Real numSim, VMatrix nu)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" draw.unconstrained 1");
    VMatrix z = Gaussian(_.N,1,0,1);
    Real _.logDens.Q := -0.5*VMatDat(MtMSqr(z),1,1);
    VMatrix _.beta:=nu+CholeskiSolve(_.L,z,"LtP");
    Copy(_.beta)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.gibbs.constrained =
  "Method of generation of a linear block in constrained case";
  VMatrix draw.gibbs.constrained(Real numSim, VMatrix nu)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" draw.constrained 1");
    VMatrix d   = _.a - _.A*nu;
  //WriteLn("TRACE "+_MID+" draw.constrained 2");
    VMatrix If(changed.X, _.D  := Tra(CholeskiSolve(_.L,_.At,"PtL")));
  //WriteLn("TRACE "+_MID+" draw.constrained 3");
    VMatrix z0  = Tra(Tra(_.beta-nu)*_.Ls);
  //WriteLn("TRACE "+_MID+" draw.constrained 4");
    VMatrix z = TruncStdGaussian(_.D,d,z0,1,truncMNormal.gibbsNumIter);
  //WriteLn("TRACE "+_MID+" draw.constrained 5");
    Real distBorder = VMatMax(_.D*z-d);
  //WriteLn("TRACE "+_MID+" draw.constrained 6");
    Real If(distBorder<=0,
    {
    //WriteLn("TRACE "+_MID+" draw.constrained 7");
      VMatrix _.beta0 := _.beta;
      1
    },
    {
      WriteLn(_MID+" Found a point that doesn't match constrains Max(D*z-d)="<<
        VMatMax(_.D*z-d)+"\n Trying again");
      If(!VRows(_.beta0),0,
      {
      //WriteLn("TRACE "+_MID+" draw.constrained 8");
        VMatrix z0 := Tra(Tra(_.beta0-nu)*_.Ls);
      //WriteLn("TRACE "+_MID+" draw.constrained 9");
        VMatrix z  := TruncStdGaussian(_.D,d,z0,1,truncMNormal.gibbsNumIter);
        1
      });
      1
    });
  //WriteLn("TRACE "+_MID+" draw.constrained 10");
    Real _.logDens.Q := -0.5*VMatDat(MtMSqr(z),1,1);
  //WriteLn("TRACE "+_MID+" draw.constrained 11");
    VMatrix  _.beta := nu + CholeskiSolve(_.L,z,"LtP");
  //WriteLn("TRACE "+_MID+" draw.constrained 12");
    Copy(_.beta)
  };

  ////////////////////////////////////////////////////////////////////////////
  //Default behaviour assumes standarized linear regression
  VMatrix do.nothing(VMatrix _Z) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    _Z 
  };

  Code standarize = do.nothing;

  ////////////////////////////////////////////////////////////////////////////
  //Default behaviour assumes standarized linear regression
  NameBlock noWorkSpace(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    NameBlock none = [[ Real _unused = unused ]]
  };

  Code getWorkSpace = noWorkSpace;

  ////////////////////////////////////////////////////////////////////////////
  //Return standarized residuals of linear reggression for a given vector of
  //parameters 
  VMatrix getStdResiduals(VMatrix b)
  ////////////////////////////////////////////////////////////////////////////
  {
    NameBlock ws = getWorkSpace(0);
    standarize(ws::_.Y-ws::_.X*b)    
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.gibbs =
  "Method of Gibss simulation of output missing block";
  VMatrix draw.gibbs(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    NameBlock ws = getWorkSpace(0);
    Real _.MH.consecutive := 0;
  //WriteLn("TRACE "+_MID+" draw.gibbs 1 ws::_.Y=" << ws::_.Y);
    VMatrix Y01 = standarize(ws::_.Y);
  //WriteLn("TRACE "+_MID+" draw.gibbs 2 Y01=" << Y01);
  //WriteLn("TRACE "+_MID+" draw.gibbs 3 ws::_.X=" << ws::_.X);
    VMatrix X01 = standarize(ws::_.X);
  //WriteLn("TRACE "+_MID+" draw.gibbs 4 X01=" << X01);
    Real solve(numSim, Y01, X01);
  //WriteLn("TRACE "+_MID+" draw.gibbs 2");
    gibbs.drawer(numSim, _.solution->nu)
  };

  
  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.mh =
  "Method of Metroplois-Hastings simulation of output missing block";
  VMatrix draw.mh(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    NameBlock ws = getWorkSpace(0);
  //WriteLn("TRACE "+_MID+" draw.mh 1");
/* * /
    WriteLn(" numSim="<<numSim+
            " _.MH.success="<<_.MH.success+
            " _.MH.tried="<<_.MH.tried+
            " _.MH.rejected="<<_.MH.rejected+
            " _.MH.consecutive="<<_.MH.consecutive);
/* */
    Real m = VRows(ws::_.Y);
    Real _.MH.consecutive := _.MH.consecutive + 1;
    VMatrix b = _.beta;
    VMatrix ep = getStdResiduals(b);
    Real p0 = -0.5*VMatDat(MtMSqr(ep),1,1);
    Real q0 = _.logDens.Q;
    Real s0 = Sqrt(-2*p0/m);
  //WriteLn(" s0="<<s0+" p0="<<p0+" q0="<<q0);
    Real p1 = ?;
    Real q1 = ?;
    Real accept = False;
    Real i = 1;
    While(Not(accept) & (i<=_.MH.maxRejected),
    {
      Real t0 = Copy(Time);
      Real changed.X := False;
      VMatrix b := gibbs.drawer(numSim, _.solution->nu);
      VMatrix ep := getStdResiduals(b);
      Real p1 := -0.5*VMatDat(MtMSqr(ep),1,1);
      Real s1 = Sqrt(-2*p1/m);
      Real q1 := _.logDens.Q;
      Real a = Rand(0,1);
      Real c = Exp((p1+q0)-(p0+q1));
      Real s = Sqrt(gsl_ran_chisq(m)/m);
      Real accept := Case(
        s1 <= 1, True,
        s1 <= s, True,
        1  == 1, a<c);
      Real tm = Copy(Time) - t0;
/* * /
      WriteLn(" i="<<i+
              " s1="<<s1+
              " p1="<<p1+
              " q1="<<q1+
              " c="<<c+
              " a="<<a+
              " s="<<s+
              " accept="<<accept+
              " time="<<tm);
/* */
      Real _.MH.tried := _.MH.tried +1 ;
      Real _.MH.rejected := _.MH.rejected + Not(accept);
      Real i := i+1
    });
    If(accept, 
    {
      Real _.MH.success := _.MH.success + 1;
      b
    }, 
    {
      draw.gibbs(numSim)
    })  
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw =
  "Method of generation of output missing block";
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" draw 1");
    Real _.calculatedSimulation := _.calculatedSimulation+1;
  //WriteLn("TRACE "+_MID+" draw 4");
    If(And(_.calculatedSimulation >_.MH.useAfterIter,
           _.MH.consecutive <= _.MH.maxConsecutive),
       draw.mh   (numSim),
       draw.gibbs(numSim))
  }

};


//////////////////////////////////////////////////////////////////////////////
StdLinearSubBlock StdLinearSubBlock.Build(Text mid)
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::Bsr::Gibbs::StdLinearSubBlock freeBlock = 
  [[ Text _MID = mid ]];
  freeBlock
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.StdLinearBlock =
"Builds a NameBlock that can draw a Gibbs sample of an standarized linear "
"block of a general regression model with variant input and ouput regression "
"matrices and optional but fixed constraining inequations.";
//////////////////////////////////////////////////////////////////////////////
Class StdLinearBlock: BlockSampler
//////////////////////////////////////////////////////////////////////////////
{

  ////////////////////////////////////////////////////////////////////////////
  //Default behaviour assumes standarized linear regression
  VMatrix standarize(VMatrix _Z) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    _Z 
  };

  ////////////////////////////////////////////////////////////////////////////
  NameBlock getWorkSpace(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    _.ws
  };

  BysMcmc::Bsr::Gibbs::StdLinearSubBlock _.fullBlock = 
    BysMcmc::Bsr::Gibbs::StdLinearSubBlock.Build(_MID+"[_.fullBlock] ");
  BysMcmc::Bsr::Gibbs::StdLinearSubBlock _.freeBlock = 
    BysMcmc::Bsr::Gibbs::StdLinearSubBlock.Build(_MID+"[_.freeBlock] ");

  Set _.i1 = Copy(Empty); //_.partialSampler::getNonFreeIndex(0);
  Set _.i2 = Copy(Empty); //_.partialSampler::getFreeIndex(0);
  Real _.N1 = ?;
  Real _.N2 = ?;

  ////////////////////////////////////////////////////////////////////////////
  Real initialize.subBlocks(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    Set _.i1 := _.partialSampler::getNonFreeIndex(0);
    Set _.i2 := _.partialSampler::getFreeIndex(0);
    Real _.N1 := Card(_.i1);
    Real _.N2 := Card(_.i2);
    Code _.freeBlock::standarize := standarize;
    Code _.freeBlock::getWorkSpace := getWorkSpace;
    Real _.freeBlock::usePreconditioning := 
      _.config::bsr.linBlk.usePreconditioning;
    Real _.freeBlock::cholesky.warningFreq := 
      _.config::bsr.cholesky.warningFreq;
    Real _.freeBlock::truncMNormal.gibbsNumIter := 
      _.config::bsr.truncMNormal.gibbsNumIter;
    Real _.freeBlock::drop_val := 
      _.config::bsr.linBlk.X.drop;
    Real _.freeBlock::_.eps := 
      _.config::bsr.cholesky.epsilon*_.N2*(_.N2+1);
    Real _.freeBlock::_.MH.useAfterIter := 
      Max(1,_.config::bsr.linBlk.MH.useAfterIter);
    Real _.freeBlock::_.MH.maxRejected := 
      _.config::bsr.linBlk.MH.maxRejected;
    Real _.freeBlock::_.MH.maxConsecutive := 
      _.config::bsr.linBlk.MH.maxConsecutive;
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    initialize.subBlocks(0)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real matchConstrains(VMatrix beta0, VMatrix A, VMatrix a)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(!_.N1,  
    {
      Real ok = _.freeBlock::matchConstrains(beta0,A,a);
      Real putStoreV(_.freeBlock::_.beta0);
      ok
    },
    {
      Real ok1 = _.fullBlock::matchConstrains(beta0,A,a);
      Real ok2 = If(!ok1, False,
      {
        VMatrix b1 = _.partialSampler::_.fixedValues;
        VMatrix b2 = SubRow(_.fullBlock::_.beta0, _.i2);
        VMatrix A1 = SubCol(A, _.i1);
        VMatrix A2 = SubCol(A, _.i2);
        VMatrix a2 = a - A1*b1;
        Real _.freeBlock::matchConstrains(b2,A2,a2)
      });
      VMatrix b_ = _.partialSampler::mergeWithFreeSample(_.freeBlock::_.beta0); 
      Real putStoreV(b_);
      ok2
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" StdLinearBlock::draw 0");
    If(!_.N1,  
    {
    //WriteLn("TRACE"+_MID+" StdLinearBlock::draw 1.1");
    _.freeBlock::draw(numSim)
    },
    {
    //WriteLn("TRACE"+_MID+" StdLinearBlock::draw 2.1");
      VMatrix b1 = _.partialSampler::_.fixedValues;
    //WriteLn("TRACE"+_MID+" StdLinearBlock::draw 2.2");
      VMatrix A1 = SubCol(_.fullBlock::_.A, _.i1);
    //WriteLn("TRACE"+_MID+" StdLinearBlock::draw 2.3");
      VMatrix _.freeBlock::_.a := _.fullBlock::_.a - A1*b1;
    //WriteLn("TRACE"+_MID+" StdLinearBlock::draw 2.4");
      _.freeBlock::draw(numSim)
    })
  }

};


//////////////////////////////////////////////////////////////////////////////
StdLinearBlock StdLinearBlock.Default(Text name, 
                                      Real numBlock, 
                                      Real firstCol, 
                                      Config config)
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::Bsr::Gibbs::StdLinearBlock aux = 
  [[
    Real _define = define(name, Empty, BysMcmc::McmcPartialHandler.Default(0),
                          numBlock, firstCol, config);
    VMatrix draw(Real numSim) { Rand(0,1,0,0) };
    Real buildWorkSpace(Real unused) { True };
    Code _.buildWorkSpace = buildWorkSpace;
    Real initialize.subBlocks(Real unused) { True };
    Real matchConstrains(VMatrix beta0, VMatrix A, VMatrix a) { True }
  ]];
  aux
};
