/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdLib (Standard Library of TOL)
// MODULE: Stat (Statistics)
// FILE: _stdLinearBlock.tol
// PURPOSE: Declares class hierarchy BysMcmc::Bsr::Gibbs::BlockStdLin
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
Class WorkSpace.LinReg
////////////////////////////////////////////////////////////////////////////
{
  VMatrix _.Y; //Output matrix
  VMatrix _.X; //Input matrix
  Real rows(Real unused) { VRows(_.Y) }; //Data length
  VMatrix standarize(VMatrix _Z) { _Z };

  //////////////////////////////////////////////////////////////////////////
  Static WorkSpace.LinReg Null(Real unused)
  //////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::Gibbs::WorkSpace.LinReg aux = 
    [[
      VMatrix _.Y = Rand(0,0,0,0);
      VMatrix _.X = Rand(0,0,0,0)
    ]]
  }
};

////////////////////////////////////////////////////////////////////////////
Class Solution.LinReg
////////////////////////////////////////////////////////////////////////////
{
  Real    _.numSim;
  VMatrix _.Y; //Output matrix
  VMatrix _.X; //Input matrix
  VMatrix _.nu;
  Real    _.err;

  //////////////////////////////////////////////////////////////////////////
  Static Solution.LinReg New(
  //////////////////////////////////////////////////////////////////////////
    Real    numSim,
    VMatrix Y,
    VMatrix X,
    VMatrix nu,
    Real    err
  )
  {
    BysMcmc::Bsr::Gibbs::Solution.LinReg aux = 
    [[
      Real    _.numSim = numSim;
      VMatrix _.Y      = Y;
      VMatrix _.X      = X;
      VMatrix _.nu     = nu;
      Real    _.err    = err
    ]]
  };

  //////////////////////////////////////////////////////////////////////////
  Static Solution.LinReg Null(Real unused)
  //////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::Gibbs::Solution.LinReg::New
      ( ?,Rand(0,0,0,0),Rand(0,0,0,0),Rand(0,0,0,0),? )
  }
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.BlockStdLinSub =
"Builds a NameBlock that can draw a Gibbs sample of an standarized linear "
"block of a general regression model with variant input and ouput regression "
"matrices and optional but fixed constraining inequations.";
//////////////////////////////////////////////////////////////////////////////
Class BlockStdLinSub
//////////////////////////////////////////////////////////////////////////////
{
  Text _MID;
  //Transformed restrictions
  VMatrix _.D = Rand(0,0,0,0);
  //Cholesky decomposition of current information matrix that is not
  //explicitely stored
  VMatrix _.L  = Rand(0,0,0,0);
  VMatrix _.Ls = Rand(0,0,0,0);
  //Preconditioning
  VMatrix _.H  = Rand(0,0,0,0);
  VMatrix _.Hs = Rand(0,0,0,0);
  //If you know that design matrix will be the same for all simulations you
  //should to set this member as TRUE to avoid unneeded Cholesky 
  //factorizations
  Real design.is.constant = False;
  //Matrix of linear system in last iteration
  VMatrix _old.X  = Rand(0,0,0,0); 
  //
  Solution.LinReg _.solution = 
    BysMcmc::Bsr::Gibbs::Solution.LinReg::Null(0);

  Real changed.X = True;

  Real usePreconditioning = ?;
  Real cholesky.warningFreq = ?;
  Real truncMNormal.gibbsNumIter = ?;
  //Maximum accepted rounding error for Choleski operations
  Real _.eps  = ?;
  //Current number of simulations with high rounding error in solution
  Real _.cholSolRoundErrNumWarn = 0;
  //Current maximum of rounding error in solution
  Real _.cholSolMaxRoundErr     = 0;
  //Current number of iterations which initial point is not feasible
  Real _.nonFeasibleInitialPointNum = 0;
  //Logarithm of density of last generated vector
  Real _.logDens.Q = -1/0;

  Real _.MH.useAfterIter = ?;
  Real _.MH.maxRejected  = ?;
  Real _.MH.maxConsecutive = ?;
  Real _.MH.tried = 0;
  Real _.MH.rejected = 0;
  Real _.MH.success = 0;
  Real _.MH.consecutive = 0;
  Real _.calculatedSimulation = 0;

  Real drop_val = ?;

  //Freedom degree
  Real    _.N = ?;
  //Number of restrictions
  Real    _.R  = 0;
  //Matrix of coefficients of constraining inequations
  VMatrix _.A  = Rand(0,0,0,0); 
  //The transpose of _.A
  VMatrix _.At = Rand(0,0,0,0);
  //Matrix of border of constraining inequations
  VMatrix _.a  = Rand(0,1,0,0);
  //Last known valid initial point for constrained simulation
  VMatrix _.beta0 = Rand(0,1,0,0);
  VMatrix _.beta = Rand(0,1,0,0);

  ////////////////////////////////////////////////////////////////////////////
  Real putMID(Text mid)
  ////////////////////////////////////////////////////////////////////////////
  {
    Text _MID := mid;
    1
  };

  ////////////////////////////////////////////////////////////////////////////
    VMatrix _drop(VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  { 
    Drop(X, drop_val)
  };
  
  ////////////////////////////////////////////////////////////////////////////
  Real isFeasible(VMatrix beta)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatMax(_.A*beta - _.a)<=0
  };

  ////////////////////////////////////////////////////////////////////////////
  //Returns true if given solution matches constrains and store them
  Real matchConstrains(VMatrix beta0, VMatrix A, VMatrix a)
  ////////////////////////////////////////////////////////////////////////////
  {   
  //WriteLn("TRACE "+_MID+" matchConstrains 1 beta0="<<beta0);
    Real ok = TRUE;

    VMatrix  _.beta := beta0;
    Real    _.N    := VRows(beta0);
  //WriteLn("TRACE "+_MID+" matchConstrains 2 _.N="<<_.N);
    Real    _.R    := VRows(A);
  //WriteLn("TRACE "+_MID+" matchConstrains 3 _.R="<<_.R);
    VMatrix _.A    := A; 
  //WriteLn("TRACE "+_MID+" matchConstrains 4 _.A="<<_.A);
    VMatrix _.At   := Tra(A);
  //WriteLn("TRACE "+_MID+" matchConstrains 5 _.At="<<_.At);
    VMatrix _.a    := a;
  //WriteLn("TRACE "+_MID+" matchConstrains 7");
    VMatrix _.beta0 := If(!_.R, beta0,
    {
    //WriteLn("TRACE "+_MID+" matchConstrains 8.1");
      Real givenMatch = isFeasible(beta0);
    //WriteLn("TRACE "+_MID+" matchConstrains 8.2");
      If(givenMatch, 
      {
        WriteLn(_MID+"Given init values matches constrain inequations.");
        beta0
      },
      {
        WriteLn(_MID+"Given init values doesn't match constrain inequations."
                "Trying zero solution ...", "W");
        Real zeroMatch = VMatMax(-_.a)<=0;
        If(zeroMatch, 
        {
          WriteLn(_MID+"Zero solution matches constrain inequations.");
          Rand(_.N,1,0,0)
        },
        {
          WriteLn(_MID+"Zero init values doesn't match constrain inequations.","W");
          Real ok := FALSE;
          beta0
        })
      })
    });
  //WriteLn("TRACE "+_MID+" matchConstrains 9");
    ok
  };

  ////////////////////////////////////////////////////////////////////////////
  //Update Cholesky factorization matrix _.L 
  //If design matrix is assumed as constant does it just the first time
  Real factorize(VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" factorize X("<<VRows(X)+"x"<<VColumns(X)+"):"<<X);
    If(And(design.is.constant,VRows(_.L)), 0,
    {
    //WriteLn("TRACE"+_MID+" factorize 1");
      Real changed.X := If(Or(VColumns(X)!=VColumns(_old.X),
                              VRows   (X)!=VRows   (_old.X)), -1,
      {
      //WriteLn("TRACE"+_MID+" factorize 2.1");
        1+VMatMax(Abs(X-_old.X))-1
      });
    //WriteLn("TRACE"+_MID+" factorize 3");
      If(!changed.X ,0,
      {
      //WriteLn("TRACE"+_MID+" factorize 4.1");
        Real density = VNonNullCells(X)/(VRows(X)*VColumns(X));
      //WriteLn("TRACE "+_MID+" factorize 4.2 density = "<<density);
        If(And(usePreconditioning,VRows(_.L)),
        {
        //WriteLn("TRACE"+_MID+" factorize 5.1");
          VMatrix Hs = _.Ls;
          VMatrix H  = _.L;
        //WriteLn("TRACE"+_MID+" factorize 5.2");
          VMatrix G  = Tra(CholeskiSolve(H,Tra(X),"PtL"));
        //WriteLn("TRACE"+_MID+" factorize 5.3");
          Real density.G = VNonNullCells(G)/(VRows(G)*VColumns(G));
        //WriteLn("TRACE "+_MID+" factorize density G = "<<density.G);
        //WriteLn("TRACE"+_MID+" factorize 5.4");
          VMatrix S  = CholeskiFactor(G,"XtX");
        //WriteLn("TRACE"+_MID+" factorize 5.5");
          VMatrix Ss = CholeskiSolve(S,Convert(S, "Cholmod.R.Sparse"),"P");
        //WriteLn("TRACE"+_MID+" factorize 5.6");
          VMatrix _.Ls := Hs*Ss;
        //WriteLn("TRACE"+_MID+" factorize 5.7");
          VMatrix _.L  := _.Ls;
          1 
        },        
        {
        //WriteLn("TRACE"+_MID+" factorize 6.1");
          Real numErr = Copy(NError);
          VMatrix _.L := If(density<.13, 
          {
          //WriteLn("TRACE"+_MID+" factorize 6.2.1 X("<<VRows(X)+"x"<<VColumns(X)+"):"<<X);
            CholeskiFactor(X,"XtX")
          },
          {/*
            Text path = TolAppDataPath+"tmp/"+ToName(_MID)+"_dense_factorize.oza";
            WriteLn(_MID+"Dense factorization matrix will be stored into "+path);
            Real Ois.Store([[X]],path); */
          //WriteLn("TRACE"+_MID+" factorize 6.2.3");
            VMatrix X_   = Convert(X,"Blas.R.Dense");
          //WriteLn("TRACE"+_MID+" factorize 6.2.4");
            VMatrix XtX_ = MtMSqr(X_);
          //WriteLn("TRACE"+_MID+" factorize 6.2.5");
            VMatrix XtX = Convert(XtX_,"Cholmod.R.Sparse");
          //WriteLn("TRACE"+_MID+" factorize 6.2.6");
            CholeskiFactor(XtX,"X")
          });
          Real If(Copy(NError)>numErr,
          {
            Text path = TolAppDataPath+"tmp/"+ToName(_MID)+"_error_factorize.oza";
            WriteLn(_MID+"Failed factorization matrix will be stored into "+path);
            Ois.Store([[X]],path)
          });
          VMatrix If(_.R, 
          {
          //WriteLn("TRACE"+_MID+" factorize 7.1");
            _.Ls := CholeskiSolve(_.L,Convert(_.L, "Cholmod.R.Sparse"),"P")
          });
        //WriteLn("TRACE"+_MID+" factorize 8.1");
          VMatrix _old.X := X;
          1
        })
      })
    }) 
  };

  ////////////////////////////////////////////////////////////////////////////
  //Solves the linear system corresponding to the standarized linear regression
  Real solve(Real numSim, VMatrix Y, VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" solve 1.1 Y("<<VRows(Y)+"x"<<VColumns(Y)+")");
  //WriteLn("TRACE "+_MID+" solve 1.2 X("<<VRows(X)+"x"<<VColumns(X)+")");
    Real Do factorize(X);
  //WriteLn("TRACE "+_MID+" solve 2");
    Real If(VRows(_.L)<=0, CMsg::Coded::show
      (BysMcmc::_.cmsg::_.invCholFac,[[_MID,""]]));
  //WriteLn("TRACE "+_MID+" solve 3");
    Real If(numSim==1, _.cholSolRoundErrNumWarn := 0 );

  //WriteLn("TRACE "+_MID+" solve 4");
    VMatrix XtY  = Tra(Tra(Y)*X);
  //WriteLn("TRACE "+_MID+" solve 5 XtY="<<Matrix(VMat2Mat(Tra(XtY))));
    VMatrix nu = CholeskiSolve(_.L,XtY,"PtLLtP");
  //WriteLn("TRACE "+_MID+" solve 6 nu="<<Matrix(VMat2Mat(Tra(nu))));
    Real    err = VMatMax(Abs(XtY-Tra(Tra(X*nu)*X)));
  //WriteLn("TRACE "+_MID+" solve 7 err="<<err);
    Real If(err>=_.eps, 
    {
      Real _.cholSolRoundErrNumWarn := _.cholSolRoundErrNumWarn+1;
      Real _.cholSolMaxRoundErr := Max(_.cholSolMaxRoundErr,err);
      0
    });
    Real If(numSim & !(numSim%cholesky.warningFreq),
    {
      If(_.cholSolRoundErrNumWarn,
        WriteLn(_MID+"Cholesky solving had rounding error in interval ["<<
          _.eps + ","<<_.cholSolMaxRoundErr+" for "<<_.cholSolRoundErrNumWarn+
          " times of "<<numSim,"W"));
      If(_.nonFeasibleInitialPointNum,
        WriteLn(_MID+"Initial point was not feasible for "<<_.nonFeasibleInitialPointNum+
          " times of "<<numSim,"W"));
      0
    });
  //WriteLn("TRACE "+_MID+" solve 8");
    BysMcmc::Bsr::Gibbs::Solution.LinReg _.solution := 
      BysMcmc::Bsr::Gibbs::Solution.LinReg::New(numSim,Y,X,nu,err);
  //WriteLn("TRACE "+_MID+" solve 9");
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.gibbs.unconstrained =
  "Method of generation of a linear block in unconstrained case";
  VMatrix draw.gibbs.unconstrained(Real numSim, VMatrix nu)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" draw.unconstrained 1");
    VMatrix z = Gaussian(_.N,1,0,1);
    Real _.logDens.Q := -0.5*VMatDat(MtMSqr(z),1,1);
    VMatrix _.beta:=nu+CholeskiSolve(_.L,z,"LtP");
    Copy(_.beta)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.gibbs.constrained =
  "Method of generation of a linear block in constrained case";
  VMatrix draw.gibbs.constrained(Real numSim, VMatrix nu)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 1.1 _.A("<<VRows(_.A)+"x"<<VColumns(_.A)+")");
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 1.2 _.a("<<VRows(_.a)+"x"<<VColumns(_.a)+")");
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 1.3 nu ("<<VRows( nu)+"x"<<VColumns( nu)+")");
    VMatrix d   = _.a - _.A*nu;
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 2");
    VMatrix If(changed.X, _.D  := Tra(CholeskiSolve(_.L,_.At,"PtL")));
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 3");
    VMatrix z0  = Tra(Tra(_.beta-nu)*_.Ls);
    VMatrix If(Not(Polytope::IsFeasible(_.D,d,z0)),
    {
      Real _.nonFeasibleInitialPointNum := _.nonFeasibleInitialPointNum +1;
      z0 := Polytope::FindFeasible(_.D, d, z0, 10*_.N, FALSE)
    });
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 4");
    VMatrix z = TruncStdGaussian(_.D,d,z0,1,truncMNormal.gibbsNumIter);
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 5");
    Real distBorder = VMatMax(_.D*z-d);
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 6");
    Real If(distBorder<=0,
    {
    //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 7");
      VMatrix _.beta0 := _.beta;
      1
    },
    {
      WriteLn(_MID+" Found a point that doesn't match constrains Max(D*z-d)="<<
        VMatMax(_.D*z-d)+"\n Trying again");
      If(!VRows(_.beta0),0,
      {
      //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 8");
        VMatrix z0 := Tra(Tra(_.beta0-nu)*_.Ls);
      //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 9");
        VMatrix z := TruncStdGaussian(_.D,d,z0,1,truncMNormal.gibbsNumIter);
        1
      });
      1
    }) ;
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 10");
    Real _.logDens.Q := -0.5*VMatDat(MtMSqr(z),1,1);
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 11");
    VMatrix  _.beta := nu + CholeskiSolve(_.L,z,"LtP");
  //WriteLn("TRACE "+_MID+" draw.gibbs.constrained 12");
    Copy(_.beta)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.gibbs.drawer =
  "Method of generation of a linear block in any case";
  VMatrix gibbs.drawer(Real numSim, VMatrix nu)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.R, draw.gibbs.constrained  (numSim, nu), 
            draw.gibbs.unconstrained(numSim, nu))  
  };

  ////////////////////////////////////////////////////////////////////////////
  //Return standarized residuals of linear reggression for a given vector of
  //parameters 
  VMatrix getStdResiduals(WorkSpace.LinReg ws, VMatrix b)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" BlockStdLinSub::getStdResiduals");
    ws::standarize(ws::_.Y-ws::_.X*b)    
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.gibbs =
  "Method of Gibss simulation of output missing block";
  VMatrix draw.gibbs(WorkSpace.LinReg ws, Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" BlockStdLinSub::draw.gibbs");
    Real _.MH.consecutive := 0;
  //WriteLn("TRACE "+_MID+" draw.gibbs 1 ws::_.Y=" << ws::_.Y);
    VMatrix Y01 = ws::standarize(ws::_.Y);
  //WriteLn("TRACE "+_MID+" draw.gibbs 2 Y01=" << Y01);
  //WriteLn("TRACE "+_MID+" draw.gibbs 3 ws::_.X=" << ws::_.X);
    VMatrix X01 = ws::standarize(ws::_.X);
  //WriteLn("TRACE "+_MID+" draw.gibbs 4 X01=" << X01);
    Real solve(numSim, Y01, X01);
  //WriteLn("TRACE "+_MID+" draw.gibbs 2");
    gibbs.drawer(numSim, _.solution::_.nu)
  };

  
  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.mh =
  "Method of Metroplois-Hastings simulation of output missing block";
  VMatrix draw.mh(WorkSpace.LinReg ws, Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" BlockStdLinSub::draw.mh");
  //WriteLn("TRACE "+_MID+" draw.mh 1");
/* * /
    WriteLn(" numSim="<<numSim+
            " _.MH.success="<<_.MH.success+
            " _.MH.tried="<<_.MH.tried+
            " _.MH.rejected="<<_.MH.rejected+
            " _.MH.consecutive="<<_.MH.consecutive);
/* */
    Real m = VRows(ws::_.Y);
  //WriteLn("TRACE "+_MID+" draw.mh 1");
    Real _.MH.consecutive := _.MH.consecutive + 1;
  //WriteLn("TRACE "+_MID+" draw.mh 2");
    VMatrix b = _.beta;
  //WriteLn("TRACE "+_MID+" draw.mh 3");
    VMatrix ep = getStdResiduals(ws, b);
  //WriteLn("TRACE "+_MID+" draw.mh 4");
    Real p0 = -0.5*VMatDat(MtMSqr(ep),1,1);
  //WriteLn("TRACE "+_MID+" draw.mh 5");
    Real q0 = _.logDens.Q;
  //WriteLn("TRACE "+_MID+" draw.mh 6");
    Real s0 = Sqrt(-2*p0/m);
  //WriteLn(" s0="<<s0+" p0="<<p0+" q0="<<q0);
  //WriteLn("TRACE "+_MID+" draw.mh 7");
    Real p1 = ?;
    Real q1 = ?;
  //WriteLn("TRACE "+_MID+" draw.mh 8");
    Real accept = False;
  //WriteLn("TRACE "+_MID+" draw.mh 9");
    Real i = 1;
  //WriteLn("TRACE "+_MID+" draw.mh 10");
    While(Not(accept) & (i<=_.MH.maxRejected),
    {
      Real t0 = Copy(Time);
      Real changed.X := False;
      VMatrix b := gibbs.drawer(numSim, _.solution::_.nu);
      VMatrix ep := getStdResiduals(ws,b);
      Real p1 := -0.5*VMatDat(MtMSqr(ep),1,1);
      Real s1 = Sqrt(-2*p1/m);
      Real q1 := _.logDens.Q;
      Real a = Rand(0,1);
      Real c = Exp((p1+q0)-(p0+q1));
      Real s = s0*Sqrt(gsl_ran_chisq(m)/m);
      Real accept := Case(
      //s1 <= 1, True,
        s1 <= s, True,
        1  == 1, a<c);
      Real tm = Copy(Time) - t0;
/* * /
      WriteLn(" i="<<i+
              " s1="<<s1+
              " p1="<<p1+
              " q1="<<q1+
              " c="<<c+
              " a="<<a+
              " s="<<s+
              " accept="<<accept+
              " time="<<tm);
/* */
      Real _.MH.tried := _.MH.tried +1 ;
      Real _.MH.rejected := _.MH.rejected + Not(accept);
      Real i := i+1
    });
  //WriteLn("TRACE "+_MID+" draw.mh 11");
    If(accept, 
    {
      Real _.MH.success := _.MH.success + 1;
      b
    }, 
    {
      draw.gibbs(ws,numSim)
    })  
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw =
  "Method of generation of output missing block";
  VMatrix draw(WorkSpace.LinReg ws, Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" draw 1");
    Real _.calculatedSimulation := _.calculatedSimulation+1;
  //WriteLn("TRACE "+_MID+" draw 4");
    If(And(_.calculatedSimulation >_.MH.useAfterIter,
           _.MH.consecutive <= _.MH.maxConsecutive),
       draw.mh   (ws,numSim),
       draw.gibbs(ws,numSim))
  };

  ////////////////////////////////////////////////////////////////////////////
  Static BlockStdLinSub New(Text mid)
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::Gibbs::BlockStdLinSub freeBlock = 
    [[ Text _MID = mid ]]
  }

};



//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.BlockStdLin =
"Builds a NameBlock that can draw a Gibbs sample of an standarized linear "
"block of a general regression model with variant input and ouput regression "
"matrices and optional but fixed constraining inequations.";
//////////////////////////////////////////////////////////////////////////////
Class BlockStdLin: BlockSampler
//////////////////////////////////////////////////////////////////////////////
{
  //--------------------------------------------------------------------------
  // Mandatory members
  //--------------------------------------------------------------------------
  //Work space stores all data needed to draw samples that are variant for
  //each simulation

  //--------------------------------------------------------------------------
  //Auxiliar members
  //--------------------------------------------------------------------------
  BysMcmc::Bsr::Gibbs::BlockStdLinSub _.fullBlock = 
    BysMcmc::Bsr::Gibbs::BlockStdLinSub::New(_MID+"[_.fullBlock] ");
  BysMcmc::Bsr::Gibbs::BlockStdLinSub _.freeBlock = 
    BysMcmc::Bsr::Gibbs::BlockStdLinSub::New(_MID+"[_.freeBlock] ");

  Set _.i1 = Copy(Empty); //_.partialSampler::getNonFreeIndex(0);
  Set _.i2 = Copy(Empty); //_.partialSampler::getFreeIndex(0);
  Real _.N1 = ?;
  Real _.N2 = ?;

  //--------------------------------------------------------------------------
  //Methods
  //--------------------------------------------------------------------------


  ////////////////////////////////////////////////////////////////////////////
  WorkSpace.LinReg getWorkSpaceLinReg(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    WriteLn("Not implemented method "+_MID+"::getWorkSpaceLinReg",
            "E");
    BysMcmc::Bsr::Gibbs::WorkSpace.LinReg::Null(0)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize.subBlocks(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    Real _.fullBlock::putMID(_MID+"[_.fullBlock] ");
    Real _.freeBlock::putMID(_MID+"[_.freeBlock] ");
    Set _.i1 := _.partialSampler::getNonFreeIndex(0);
    Set _.i2 := _.partialSampler::getFreeIndex(0);
    Real _.N1 := Card(_.i1);
    Real _.N2 := Card(_.i2);
    Real _.freeBlock::usePreconditioning := 
      _.config::bsr.linBlk.usePreconditioning;
    Real _.freeBlock::cholesky.warningFreq := 
      _.config::bsr.cholesky.warningFreq;
    Real _.freeBlock::truncMNormal.gibbsNumIter := 
      _.config::bsr.truncMNormal.gibbsNumIter;
    Real _.freeBlock::drop_val := 
      _.config::bsr.linBlk.X.drop;
    Real _.freeBlock::_.eps := 
      _.config::bsr.cholesky.epsilon*_.N2*(_.N2+1);
    Real _.freeBlock::_.MH.useAfterIter := 
      Max(1,_.config::bsr.linBlk.MH.useAfterIter);
    Real _.freeBlock::_.MH.maxRejected := 
      _.config::bsr.linBlk.MH.maxRejected;
    Real _.freeBlock::_.MH.maxConsecutive := 
      _.config::bsr.linBlk.MH.maxConsecutive;
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Real unused) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    initialize.subBlocks(0)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real matchConstrains(VMatrix beta0, VMatrix A, VMatrix a)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 0");
    If(!_.N1,  
    {
    //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 1.1");
      Real ok = _.freeBlock::matchConstrains(beta0,A,a);
    //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 1.2");
      Real putStoreV(_.freeBlock::_.beta0);
    //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 1.3");
      ok
    },
    {
    //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 2.1");
      Real ok1 = _.fullBlock::matchConstrains(beta0,A,a);
    //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 2.2");
    //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 2.3");
      VMatrix b1 = SubRow(_.fullBlock::_.beta0, _.i1);
      Real ok2 = If(!ok1, False,
      {
        If(!_.N2, True,
        {
        //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 2.4");
          VMatrix b2 = SubRow(_.fullBlock::_.beta0, _.i2);
        //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 2.5");
          VMatrix A1 = SubCol(A, _.i1);
        //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 2.6");
          VMatrix A2 = SubCol(A, _.i2);
        //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 2.7");
          VMatrix a2 = a - A1*b1;
        //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 2.8");
          Real _.freeBlock::matchConstrains(b2,A2,a2)
       })
      });
    //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 2.9");
      VMatrix b_ = _.partialSampler::mergeWithFreeSample(_.freeBlock::_.beta0); 
    //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 2.10");
      Real putStoreV(b_);
    //WriteLn("TRACE"+_MID+" BlockStdLin::matchConstrains 2.11");
      ok2
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::Gibbs::WorkSpace.LinReg ws = getWorkSpaceLinReg(0);
  //WriteLn("TRACE"+_MID+" BlockStdLin::draw 0");
    If(!_.N1,  
    {
    //WriteLn("TRACE"+_MID+" BlockStdLin::draw 1.1");
    _.freeBlock::draw(ws, numSim)
    },
    {
      Real ok = If(!_.N2, True,
      {
      //WriteLn("TRACE"+_MID+" BlockStdLin::draw 2.1");
        VMatrix b1 = SubRow(_.partialSampler::_.values, _.i1);
      //WriteLn("TRACE"+_MID+" BlockStdLin::draw 2.2");
        VMatrix A1 = SubCol(_.fullBlock::_.A, _.i1);
      //WriteLn("TRACE"+_MID+" BlockStdLin::draw 2.3");
        VMatrix _.freeBlock::_.a := _.fullBlock::_.a - A1*b1;
      //WriteLn("TRACE"+_MID+" BlockStdLin::draw 2.4");
        True
      });
      _.freeBlock::draw(ws, numSim)
    })
  }
};

//////////////////////////////////////////////////////////////////////////////
Class BlockStdLinEmpty : BlockStdLin
//////////////////////////////////////////////////////////////////////////////
{
  VMatrix draw(Real numSim) { Rand(0,1,0,0) };
  Real buildWorkSpace(Real unused) { True };
  Code _.buildWorkSpace = buildWorkSpace;
  Real initialize.subBlocks(Real unused) { True };
  Real matchConstrains(VMatrix beta0, VMatrix A, VMatrix a) { True };

  //////////////////////////////////////////////////////////////////////////////
  Static BlockStdLinEmpty New(
   Text name, 
   Real numBlock, 
   Real firstCol, 
   BysMcmc::Config config)
  //////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Bsr::Gibbs::BlockStdLinEmpty aux = 
    [[
      Real _defined = define(name, Empty, BysMcmc::McmcPartialHandler::Null(0),
                            numBlock, firstCol, config)
    ]]
  }
};

