/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// FILE: _nonLinBlock.tol
// PURPOSE: Declares method BysMcmc::Bsr::Gibbs::NonLinBlock
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
Class BlockSamplerNonLin : BlockSampler
/////////////////////////////////////////////////////////////////////////////
{
  //--------------------------------------------------------------------------
  // Mandatory members
  //--------------------------------------------------------------------------
  //Scalar sampler
  Code _scalarSampler;
  //Basic BSR that will be modified by filter
  NameBlock _.bsr;
  //Filter evaluator
  NameBlock _.filter;
  //Name of affected segment in BSR
  Text _.segmentName;
  //Number of affected segment in BSR
  Real _.segmentNum;
  //Affected segment in BSR
  Set _.segment;
  //For input filters is +1, for output ones -1
  Real _.isInputFilter;
  //Default value for custom partial draw
  Matrix _default.custom.partial.draw;
  //Optional filter method to be called before to call draw.scalar
  //This method will be called just before to call draw method of corresponding 
  //internal non linear block in order to select which parameters will be drawn. 
  //It will return a matrix with custom partial sampling in selected indexes and ? in
  //other ones that will be sampled by non linear block in the standard way
  Code _.custom.partial.draw;
  //Optional filter method that returns log of prior density for one parameter
  //Real get.priorLogDens(Real paramIdx)
  Code _.get.priorLogDens;
  //Names of affected parameters in linear block 
  //(just for input filters)
  Set _.linBlkNames;
  //Positions of columns of affected parameters in linear block 
  //(just for input filters)
  Set _.filterColIdx;
  //Total number of affected parameters in linear block 
  //It's 0 for output filters
  Real _.filterColNum;
  Real _.m;
  Matrix _.W;
  Matrix _.Z;
  Matrix _.Fi;

  //--------------------------------------------------------------------------
  //Methods
  //--------------------------------------------------------------------------

  ////////////////////////////////////////////////////////////////////////////
  //Called by BysMcmc::Bsr::Gibbs::NonLinMaster at initialization time
  Real initialize(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real ok = _.filter::initialize(0);
    Real setStore(_.filter::get.parameter(0));
    ok
  };
  
  ///////////////////////////////////////////////////////////////////////////
    NameBlock get.evaluator(Real  unused)
  ///////////////////////////////////////////////////////////////////////////
  {
    Set segment = _.segment;
    Set aux     = _.segment->ArimaAuxInfo;
    Set arima   = _.segment->Arima;
    NameBlock sigBlk    = _.bsr::_.sig.blk;
    VMatrix si = SubRow(SubCol(sigBlk::_.sigmaInv,
                _.segment->EquIdx), _.segment->EquIdx);

    NameBlock bsr = _.bsr;
    NameBlock filter = _.filter;
    Matrix u = VMat2Mat(_.store);
    Matrix omega= If(!_.isInputFilter, Col(1),
      SubRow(VMat2Mat(_.bsr::_.mln.blk::_.store), _.filterColIdx));

    Matrix _.W := VMat2Mat(SubRow(bsr::_.noise,_.segment->EquIdx));
    Matrix _.Z := _.W + _.Fi * omega;
    Matrix Z = _.Z;

    Code _getPriorLogDens = _.get.priorLogDens;

    NameBlock [[
    Set       _.segment   = segment;
    VMatrix   _.fullNoise = bsr::_.noise;
    NameBlock _.arimaBlk  = bsr::_.arm.blk;
    NameBlock _.sigBlk    = bsr::_.sig.blk;
    Code _filterEval     = filter::eval;
    Code _get.priorLogDens = _getPriorLogDens;
    Matrix _.u = u;
    Matrix _.omega= omega;
    Matrix _.Z = Z;

    VMatrix _.si = si;
    Polyn _.dif   = ARIMAGetDIF(arima);
    Real _.d = aux::difDegree;
    Real _.p = aux::p;
    Real _.q = aux::q;
    Real _.m = aux::m;
    Real _.n = _.m - _.d;

    //Parameter index
    Real _.i = 1;
    
    Matrix EvalFilteredNoise(Real x)
    {
      Real old = MatDat(_.u,_.i,1);
      Real Do PutMatDat(_.u,_.i,1,x);
      Matrix Fi = _filterEval(_.u);
      Real Do PutMatDat(_.u,_.i,1,old);
      Matrix fn = VMat2Mat(_.si*Mat2VMat(_.Z-Fi*_.omega));
      fn
    };
    Real LogDens.WhiteNoise(Real x)
    {
      Matrix ei = EvalFilteredNoise(x);
      Real ld = -0.5*MatDat(MtMSqr(ei),1,1);
    //WriteLn("TRACE LogDens.WhiteNoise("+_.colNames[_.i]+","<<x+")="<<ld);
      ld+_get.priorLogDens(_.i)
    };
    Real LogDens.ARMA(Real x)
    {
      Matrix Zi = EvalFilteredNoise(x);
      VMatrix Zi_ = Mat2VMat(Zi);
      VMatrix ei_ = _.arimaBlk::filterJustBlock(_.segment, Zi_);
      Matrix  ei  = VMat2Mat(ei_);
      Real ld = -0.5*MatDat(MtMSqr(ei),1,1);
    //WriteLn("TRACE LogDens.ARMA("+_.colNames[_.i]+","<<x+")="<<ld);
      ld+_get.priorLogDens(_.i)
    };
    Real LogDens.ARIMA(Real x)
    {
      Matrix Zi = EvalFilteredNoise(x);
    //WriteLn("TRACE Zi("<<Rows(Zi)+","<<Columns(Zi)+")");
      Matrix Wi = Rand(_.d,1,0,0) << Sub(DifEq(_.dif/1,Zi),_.d+1,1,_.n,1);
    //WriteLn("TRACE Wi("<<Rows(Wi)+","<<Columns(Wi)+")");
      VMatrix Wi_ = Mat2VMat(Wi);
      VMatrix ei_ = _.arimaBlk::filterJustBlock(_.segment, Wi_);
    //WriteLn("TRACE ei_("<<VRows(ei_)+","<<VColumns(ei_)+")");
      Matrix  ei  = VMat2Mat(Sub(ei_,_.d+1,1,_.n,1));
    //WriteLn("TRACE ei("<<Rows(ei)+","<<Columns(ei)+")");
      Real ld = -0.5*MatDat(MtMSqr(ei),1,1);
    //WriteLn("TRACE LogDens.ARIMA("+_.colNames[_.i]+","<<x+")="<<ld);
      ld+_get.priorLogDens(_.i)
    };
    Code LogDens = Case(
      Or(Not(_.arimaBlk::enabled),And(Not(_.p),Not(_.q))), 
        LogDens.WhiteNoise,
      _.d==0,                     
        LogDens.ARMA,
      1==1,                     
        LogDens.ARIMA )
  ]]};

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.scalar =
  "Method of generation of a non linear block by using current scalar method,"
  " given by scalarSampler for each parameter";
  VMatrix draw.scalar(Real numSim) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+"draw.scalar 1 ");

  //WriteLn("TRACE"+_MID+"draw.scalar 1.6 d="<<d+" p="<<p+" q="<<q+" m="<<m+" n="<<n);
  //WriteLn("TRACE"+_MID+"draw.scalar 2");
    
    NameBlock ev = get.evaluator(0);
    Matrix mrgDraw = _.custom.partial.draw(0);
    Set draw.all = For(1, Rows(mrgDraw), Real(Real i)
    {
      Real mrg = MatDat(mrgDraw,i,1);
      If(Not(IsUnknown(mrg)), mrg, {
      Real ev::_.i := i;
    //WriteLn("TRACE"+_MID+"draw.scalar.one 2.["+IntText(i)+"].3");
      Real x = MatDat(ev::_.u,i,1);
    //WriteLn("TRACE"+_MID+"draw.scalar.one 2.["+IntText(i)+"].4");
      Set bounds = _.filter::get.bounds(i,ev::_.u);
      Real x0 = bounds[1];
      Real x1 = bounds[2];
      Real If(Or(x<x0,x>x1), x := Rand(x0,x1) );
    //WriteLn("TRACE"+_MID+"draw.scalar.one 2.["+IntText(i)+"].5");
      Real x:= _scalarSampler(ev::LogDens,x0,x1,x);
    //WriteLn("TRACE draw.scalar x= "<<x);
    //WriteLn("TRACE"+_MID+"draw.scalar.one 2.["+IntText(i)+"].6");
      Real PutMatDat(ev::_.u,i,1,x);
    //WriteLn("TRACE"+_MID+"draw.scalar.one x="<<x);
      x
    })});
  //WriteLn("TRACE"+_MID+"draw.scalar 3");
  //Real show.arma(0);
    Mat2VMat(SetCol(draw.all))
  };

  ////////////////////////////////////////////////////////////////////////////
  Real _buildWorkSpace(Real unused_)
  ////////////////////////////////////////////////////////////////////////////
  {
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw =
  "Method of generation of non linear block ";
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+"draw 1");
    draw.scalar(numSim)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real do.filter(VMatrix Y)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+"do.filter 1");
    Matrix Y_ = VMat2Mat(SubRow(Y,_.segment->EquIdx));
  //WriteLn("TRACE"+_MID+"do.filter 2");
    Matrix Yflt = Y_-_.Fi;
  //WriteLn("TRACE"+_MID+"do.filter 3");
    Real ok = PutVMatBlock(Y, (_.segment->EquIdx)[1], 1, Yflt);
  //WriteLn("TRACE"+_MID+"do.filter 4");
    ok
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setStore =
  "Sets _.store to the specified row vector of values";
  Real setStore(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+"::setStore 1 values("<<Rows(values)+"x"<<Columns(values)+")");
    Real putStore(values);
    Real If(_.N==0, True,
    {
    //WriteLn("TRACE "+_MID+"::setStore 3");
      Matrix _.Fi := _.filter::eval(VMat2Mat(_.store));
    //WriteLn("TRACE "+_MID+"::setStore 4");
      Real ok = If(!_.isInputFilter, 0,
      {
      //WriteLn("TRACE "+_MID+"::setStore 5");
        SetMin(For(1,_.filterColNum,Real(Real column)
        {
          _.bsr::setSegmentInputCol(
            SubCol(_.Fi,[[column]]), _.segmentNum, _.filterColIdx[column])
        }))
       });
    //WriteLn("TRACE "+_MID+"::setStore 6");
      ok
    })
  }
};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.NonLinBlock =
"Builds a NameBlock that can draw a MCMC sample of a generic Gibbs block "
"defined by a non linear filter over the output or a set of inputs of a "
"given BSR model.\n"
"Arguments are:\n"
"  NameBlock usrFilter: Evaluates the non linear filter of inputs or "
   "output. Must have next mandatory methods:\n"
"    Text get.name(Real unused): Identifies the filter\n"
"    Text get.segmentName(Real unused): Identifies the segment\n"
"    Text get.colNames(Real unused): Parameters of non linear block\n"
"    Set get.linBlkNames(Real unused): Parameters of linear block \n"
"      This method must exist just for input filters.\n"
"    Set get.bounds(i,u): Returns left and right bounds for i-th \n"
"      parameter for current values of the rest of them.\n"
"    Matrix eval(Matrix param): Returns the filter matrix\n"
"  MasterSampler bsr: Result of calling BasicMaster\n"
"  Real numBlock: The order of this block in full MCMC.\n"
"  Real firstCol: First column of this block in full MCMC\n"
"  Config config: User configuration parameters\n";
//////////////////////////////////////////////////////////////////////////////
  BlockSampler NonLinBlock(
    //Filter evaluator
    NameBlock usrFilter, 
    //Basic BSR that will be modified by filter
    NameBlock bsr,
    //Number of block in non linear master
    Real numBlock, 
    //First column in MCMC
    Real firstCol,
    //Configuration parameters
    BysMcmc::Config config)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE NonLinBlock 0 ");
  BysMcmc::Bsr::Gibbs::BlockSamplerNonLin blk = [[
  Code _.buildWorkSpace = _buildWorkSpace;
  //Scalar sampler
  Code _scalarSampler = config::bsr.scalarSampler.nonLinBlock;
  //Basic BSR that will be modified by filter
  NameBlock _.bsr = bsr;
  //Filter evaluator
  NameBlock _.filter = usrFilter;
  
  //Defining the block in the Markov Chain
  Real _defined = define
  (
    _.filter::get.name(0),
    _.filter::get.colNames(0),
    bsr::_.mcmcPartialHandler,
    numBlock,
    firstCol,
    config
  );
  //Name of affected segment in BSR
  Text _.segmentName = _.filter::get.segmentName(0);
  //Number of affected segment in BSR
  Real _.segmentNum = FindIndexByName((_.bsr::_.modelDef)->NoiseDistrib,
                                      _.segmentName);
  //Affected segment in BSR
  Set _.segment = If(!_.segmentNum,
  {
    Real CMsg::Coded::show(BysMcmc::_.cmsg::_.notFoundSegment,
    [[
      _MID,
      _.segmentName
    ]]);
    Copy(Empty)
  },
  {
    ((_.bsr::_.modelDef)->NoiseDistrib)[_.segmentNum]
  });
  //For input filters is +1, for output ones -1
  Real _.isInputFilter = If(FunctionExist("Set","_.filter::get.linBlkNames"),
  {
    If(Card(_.filter::get.linBlkNames(0)),1,0)
  },
  {
    0
  });
  //Default value for custom partial draw
  Matrix _default.custom.partial.draw = Rand(Card(_.colNames), 1, ?, ?);
  //Optional filter method to be called before to call draw.scalar
  //This method will be called just before to call draw method of corresponding 
  //internal non linear block in order to select which parameters will be drawn. 
  //It will return a matrix with custom partial sampling in selected indexes and ? in
  //other ones that will be sampled by non linear block in the standard way
  Code _.custom.partial.draw = If(
  FunctionExist("Matrix","_.filter::custom.partial.draw"),
  {
    WriteLn(_MID+"Using specified custom.partial.draw method");
    _.filter::custom.partial.draw
  },
  {
    WriteLn(_MID+"Using default custom.partial.draw method");
    Matrix custom.partial.draw(Real unused) { _default.custom.partial.draw } 
  });
  //Optional filter method that returns log of prior density for one parameter
  //Real get.priorLogDens(Real paramIdx)
  Code _.get.priorLogDens = If(FunctionExist("Real","_.filter::get.priorLogDens"),
    _.filter::get.priorLogDens,
    Real (Real paramIdx) { 0 } );
  //Names of affected parameters in linear block 
  //(just for input filters)
  Set _.linBlkNames = If(!_.isInputFilter, Copy(Empty),
  {
    _.filter::get.linBlkNames(0)
  });
  //Positions of columns of affected parameters in linear block 
  //(just for input filters)
  Set _.filterColIdx = If(!_.isInputFilter, Copy(Empty),
  {
    _.bsr::_.mln.blk::getStoreColIndexes(_.linBlkNames)
  });
  //Total number of affected parameters in linear block 
  //It's 0 for output filters
  Real _.filterColNum = Card(_.filterColIdx);
  Real _.m = Card(_.segment->EquIdx);
  Matrix _.W   = Rand(_.m,1,0,0);
  Matrix _.Z   = Rand(_.m,1,0,0);
  Matrix _.Fi  = Rand(_.m,1,0,0)
]]};


