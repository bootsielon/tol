/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// FILE: _nonLinBlock.tol
// PURPOSE: Declares method BysMcmc::Bsr::Gibbs::NonLinBlock
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.NonLinBlock =
"Builds a NameBlock that can draw a MCMC sample of a generic Gibbs block "
"defined by a non linear filter over the output or a set of inputs of a "
"given BSR model.\n"
"Arguments are:\n"
"  NameBlock filterEval: Evaluates the non linear filter of inputs or "
   "output. Must have next mandatory methods:\n"
"    Text get.name(Real unused): Identifies the filter\n"
"    Text get.segmentName(Real unused): Identifies the segment\n"
"    Text get.colNames(Real unused): Parameters of non linear block\n"
"    Set get.linBlkNames(Real unused): Parameters of linear block \n"
"      This method must exist just for input filters.\n"
"    Set get.bounds(i,u): Returns left and right bounds for i-th \n"
"      parameter for current values of the rest of them.\n"
"    Matrix eval(Matrix param): Returns the filter matrix\n"
"  MasterSampler bsr: Result of calling BasicMaster\n"
"  Real numBlock: The order of this block in full MCMC.\n"
"  Real firstCol: First column of this block in full MCMC\n"
"  Config config: User configuration parameters\n";
//////////////////////////////////////////////////////////////////////////////
  BlockSampler NonLinBlock(
    //Filter evaluator
    NameBlock filterEval, 
    //Basic BSR that will be modified by filter
    NameBlock bsr,
    //Number of block in non linear master
    Real numBlock, 
    //First column in MCMC
    Real firstCol,
    //Configuration parameters
    NameBlock config)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE NonLinBlock 0 ");
  BysMcmc::BlockSampler blk = [[
  //Scalar sampler
  Code _scalarSampler = config::bsr.scalarSampler.nonLinBlock;
  //Basic BSR that will be modified by filter
  NameBlock _.bsr = bsr;
  //Filter evaluator
  NameBlock _.filterEval = filterEval;
  
  //Defining the block in the Markov Chain
  Real _defined = define
  (
    _.filterEval::get.name(0),
    _.filterEval::get.colNames(0),
    bsr::_.mcmcPartialHandler,
    numBlock,
    firstCol,
    config
  );
  //Name of affected segment in BSR
  Text _.segmentName = _.filterEval::get.segmentName(0);
  //Number of affected segment in BSR
  Real _.segmentNum = FindIndexByName((_.bsr::_.modelDef)->NoiseDistrib,
                                      _.segmentName);
  //Affected segment in BSR
  Set _.segment = If(!_.segmentNum,
  {
    Real CMsg::Coded::show(BysMcmc::_.cmsg::_.notFoundSegment,
    [[
      _MID,
      _.segmentName
    ]]);
    Copy(Empty)
  },
  {
    ((_.bsr::_.modelDef)->NoiseDistrib)[_.segmentNum]
  });
  //For input filters is +1, for output ones -1
  Real _.isInputFilter = If(FunctionExist("Set","_.filterEval::get.linBlkNames"),
  {
    If(Card(_.filterEval::get.linBlkNames(0)),1,0)
  },
  {
    0
  });
  //Default value for marginal draw
  Matrix _defaultMarginalDraw = Rand(Card(_.colNames), 1, ?, ?);
  //Optional filter method to be called before to call draw.scalar
  //This method will be called just before to call draw method of corresponding 
  //internal non linear block in order to select which parameters will be drawn. 
  //It will return a matrix with marginal sampling in selected indexes and ? in
  //other ones that will be sampled by non linear block in the standard way
  Code _.marginalDraw = If(FunctionExist("Matrix","_.filterEval::marginalDraw"),
  {
    WriteLn(_MID+"Using specified marginalDraw method");
    _.filterEval::marginalDraw
  },
  {
    WriteLn(_MID+"Using default marginalDraw method");
    Matrix marginalDraw(Real unused) { _defaultMarginalDraw } 
  });
  //Optional filter method that returns log of prior density for one parameter
  //Real get.priorLogDens(Real paramIdx)
  Code _.get.priorLogDens = If(FunctionExist("Real","_.filterEval::get.priorLogDens"),
    _.filterEval::get.priorLogDens,
    Real (Real paramIdx) { 0 } );
  //Names of affected parameters in linear block 
  //(just for input filters)
  Set _.linBlkNames = If(!_.isInputFilter, Copy(Empty),
  {
    _.filterEval::get.linBlkNames(0)
  });
  //Positions of columns of affected parameters in linear block 
  //(just for input filters)
  Set _.filterColIdx = If(!_.isInputFilter, Copy(Empty),
  {
    _.bsr::_.mln.blk::getStoreColIndexes(_.linBlkNames)
  });
  //Total number of affected parameters in linear block 
  //It's 0 for output filters
  Real _.filterColNum = Card(_.filterColIdx);
  Real _.m = Card(_.segment->EquIdx);
  Matrix _.W   = Rand(_.m,1,0,0);
  Matrix _.Z   = Rand(_.m,1,0,0);
  Matrix _.Fi  = Rand(_.m,1,0,0);

  ////////////////////////////////////////////////////////////////////////////
  //Called by BysMcmc::Bsr::Gibbs::NonLinMaster at initialization time
  Real initialize(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real ok = _.filterEval::initialize(0);
    Real setStore(_.filterEval::get.parameter(0));
    ok
  };
  
  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw.scalar =
  "Method of generation of a non linear block by using current scalar method,"
  " given by scalarSampler for each parameter";
  VMatrix draw.scalar(Real numSim) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+"draw.scalar 1 ");
    VMatrix   fullNoise = _.bsr::_.noise;
    NameBlock arimaBlk  = _.bsr::_.arm.blk;
    NameBlock sigBlk    = _.bsr::_.sig.blk;
    Matrix u = VMat2Mat(_.store);
  //WriteLn("TRACE"+_MID+"draw.scalar 1.1 _.isInputFilter = "<<_.isInputFilter);
    Matrix omega= If(!_.isInputFilter, Col(1),
      SubRow(VMat2Mat(_.bsr::_.mln.blk::_.store), _.filterColIdx));
  //WriteLn("TRACE"+_MID+"draw.scalar 1.2 omega("<<Rows(omega)+"x"<<Columns(omega));
  //WriteLn("TRACE"+_MID+"draw.scalar 1.3 _.Fi("<<Rows(_.Fi)+"x"<<Columns(_.Fi));
    Matrix _.W := VMat2Mat(SubRow(fullNoise,_.segment->EquIdx));
  //WriteLn("TRACE"+_MID+"draw.scalar 1.4 _.W("<<Rows(_.W)+"x"<<Columns(_.W));
    Matrix _.Z := _.W + _.Fi * omega;
  //WriteLn("TRACE"+_MID+"draw.scalar 1.5 _.Z("<<Rows(_.Z)+"x"<<Columns(_.Z));
    Set segment = _.segment;
    Set aux     = _.segment->ArimaAuxInfo;
    Set arima   = _.segment->Arima;
    Polyn dif   = ARIMAGetDIF(arima);
    //
    VMatrix si = SubRow(SubCol(sigBlk::_.sigmaInv,_.segment->EquIdx),_.segment->EquIdx);
    Real d = aux::difDegree;
    Real p = aux::p;
    Real q = aux::q;
    Real m = aux::m;
    Real n = m - d;
  //WriteLn("TRACE"+_MID+"draw.scalar 1.6 d="<<d+" p="<<p+" q="<<q+" m="<<m+" n="<<n);
  //WriteLn("TRACE"+_MID+"draw.scalar 2");
    Matrix mrgDraw = _.marginalDraw(0);
    Set draw.all = For(1, Rows(mrgDraw), Real(Real i)
    {
      Real mrg = MatDat(mrgDraw,i,1);
      If(Not(IsUnknown(mrg)), mrg, {
    //WriteLn("TRACE"+_MID+"draw.scalar.one 2.["+IntText(i)+"].1");
      Set bounds = _.filterEval::get.bounds(i,u);
      Code fltEv = _.filterEval::eval;
      Code get.priorLogDens = _.get.priorLogDens;
      Matrix Z = _.Z;
      Real x0 = bounds[1];
      Real x1 = bounds[2];
    //WriteLn("TRACE"+_MID+"draw.scalar.one 2.["+IntText(i)+"].2");
    //WriteLn("TRACE"+_MID+"draw.scalar.one arimaBlk::enabled=["<<arimaBlk::enabled+"]");
    //WriteLn("TRACE"+_MID+"draw.scalar.one d=["<<d+"]");
    //WriteLn("TRACE"+_MID+"draw.scalar.one p=["<<p+"]");
    //WriteLn("TRACE"+_MID+"draw.scalar.one q=["<<q+"]");
    //WriteLn("TRACE"+_MID+"draw.scalar.one bounds=["<<x0+","<<x1+"]");
    //WriteLn("TRACE"+_MID+"draw.scalar.one omega="<<omega);
      Matrix EvalFilteredNoise(Real x)
      {
        Real old = MatDat(u,i,1);
        Real Do PutMatDat(u,i,1,x);
        Matrix Fi = fltEv(u);
        Real Do PutMatDat(u,i,1,old);
        Matrix fn = VMat2Mat(si*Mat2VMat(Z-Fi*omega));
        fn
      };
      Real LogDens.WhiteNoise(Real x)
      {
        Matrix ei = EvalFilteredNoise(x);
        Real ld = -0.5*MatDat(MtMSqr(ei),1,1);
      //WriteLn("TRACE LogDens.WhiteNoise("+_.colNames[i]+","<<x+")="<<ld);
        ld+get.priorLogDens(i)
      };
      Real LogDens.ARMA(Real x)
      {
        Matrix Zi = EvalFilteredNoise(x);
        VMatrix Zi_ = Mat2VMat(Zi);
        VMatrix ei_ = arimaBlk::filterJustBlock(segment, Zi_);
        Matrix  ei  = VMat2Mat(ei_);
        Real ld = -0.5*MatDat(MtMSqr(ei),1,1);
      //WriteLn("TRACE LogDens.ARMA("+_.colNames[i]+","<<x+")="<<ld);
        ld+get.priorLogDens(i)
      };
      Real LogDens.ARIMA(Real x)
      {
        Matrix Zi = EvalFilteredNoise(x);
      //WriteLn("TRACE Zi("<<Rows(Zi)+","<<Columns(Zi)+")");
        Matrix Wi = Rand(d,1,0,0) << Sub(DifEq(dif/1,Zi),d+1,1,n,1);
      //WriteLn("TRACE Wi("<<Rows(Wi)+","<<Columns(Wi)+")");
        VMatrix Wi_ = Mat2VMat(Wi);
        VMatrix ei_ = arimaBlk::filterJustBlock(segment, Wi_);
      //WriteLn("TRACE ei_("<<VRows(ei_)+","<<VColumns(ei_)+")");
        Matrix  ei  = VMat2Mat(Sub(ei_,d+1,1,n,1));
      //WriteLn("TRACE ei("<<Rows(ei)+","<<Columns(ei)+")");
        Real ld = -0.5*MatDat(MtMSqr(ei),1,1);
      //WriteLn("TRACE LogDens.ARIMA("+_.colNames[i]+","<<x+")="<<ld);
        ld+get.priorLogDens(i)
      };
      Code LogDens = Case(
        Or(Not(arimaBlk::enabled),And(Not(p),Not(q))), 
          LogDens.WhiteNoise,
        d==0,                     
          LogDens.ARMA,
        1==1,                     
          LogDens.ARIMA );
    //WriteLn("TRACE"+_MID+"draw.scalar.one 2.["+IntText(i)+"].3");
      Real x = MatDat(u,i,1);
    //WriteLn("TRACE"+_MID+"draw.scalar.one 2.["+IntText(i)+"].4");
      Real If(Or(x<x0,x>x1), x := Rand(x0,x1) );
    //WriteLn("TRACE"+_MID+"draw.scalar.one 2.["+IntText(i)+"].5");
      Real x:= _scalarSampler(LogDens,x0,x1,x);
    //WriteLn("TRACE draw.scalar x= "<<x);
    //WriteLn("TRACE"+_MID+"draw.scalar.one 2.["+IntText(i)+"].6");
      Real PutMatDat(u,i,1,x);
    //WriteLn("TRACE"+_MID+"draw.scalar.one x="<<x);
      x
    })});
  //WriteLn("TRACE"+_MID+"draw.scalar 3");
  //Real show.arma(0);
    Mat2VMat(SetCol(draw.all))
  };

  ////////////////////////////////////////////////////////////////////////////
  Real _buildWorkSpace(Real unused_)
  ////////////////////////////////////////////////////////////////////////////
  {
    True
  };
  Code _.buildWorkSpace = _buildWorkSpace;

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw =
  "Method of generation of non linear block ";
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+"draw 1");
    draw.scalar(numSim)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real do.filter(VMatrix Y)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE"+_MID+"do.filter 1");
    Matrix Y_ = VMat2Mat(SubRow(Y,_.segment->EquIdx));
  //WriteLn("TRACE"+_MID+"do.filter 2");
    Matrix Yflt = Y_-_.Fi;
  //WriteLn("TRACE"+_MID+"do.filter 3");
    Real ok = PutVMatBlock(Y, (_.segment->EquIdx)[1], 1, Yflt);
  //WriteLn("TRACE"+_MID+"do.filter 4");
    ok
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setStore =
  "Sets _.store to the specified row vector of values";
  Real setStore(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+"::setStore 1 values("<<Rows(values)+"x"<<Columns(values)+")");
    Real putStore(values);
    Real If(_.N==0, True,
    {
    //WriteLn("TRACE "+_MID+"::setStore 3");
      Matrix _.Fi := _.filterEval::eval(VMat2Mat(_.store));
    //WriteLn("TRACE "+_MID+"::setStore 4");
      Real ok = If(!_.isInputFilter, 0,
      {
      //WriteLn("TRACE "+_MID+"::setStore 5");
        SetMin(For(1,_.filterColNum,Real(Real column)
        {
          _.bsr::setSegmentInputCol(
            SubCol(_.Fi,[[column]]), _.segmentNum, _.filterColIdx[column])
        }))
       });
    //WriteLn("TRACE "+_MID+"::setStore 6");
      ok
    })
  }

]]};


