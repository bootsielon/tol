/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// FILE: _nonLinMaster.tol
// PURPOSE: Declares method BysMcmc::Bsr::Gibbs::BasicMaster
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.NonLinMaster =
"Builds a NameBlock that can draw a Gibbs sample of a Bayesian Sparse "
"Regression model with non linear blocks by passing it to method "
"BysMcmc::BuildCycler";
NameBlock NonLinMaster(BSR.ModelDef modelDef, 
                       Set nonLinFilter,
                       NameBlock config)
//////////////////////////////////////////////////////////////////////////////
{[[

  //--------------------------------------------------------------------------
  // Read only members
  //--------------------------------------------------------------------------
  //The basic BSR master
  NameBlock _.bsrMst = BysMcmc::Bsr::Gibbs::BasicMaster(modelDef, config);
  //Model identifier is inherited from basic BSR
  Text _.name = modelDef->DocInfo->Model.Name;  
  //Setting NameBlock description
  Text _.autodoc.description="Gibbs sampler for model "+_.name;
  //Identifier prefix for messages
  Text _MID = "[BSR."+_.name+"] ";
  //The basic BSR master used as a block
  BlockSampler _.bsrBlk = BysMcmc::Bsr::Gibbs::BsrAsBlock
  (
    _.bsrMst,
    1,
    1,
    config
  );
  //The non linear blocks created from given filters
  Set _.nonLinBlk = 
  {
  //WriteLn("TRACE "+_MID+"::_.nonLinBlk 1 Card(nonLinFilter)="<<Card(nonLinFilter));
    Real firstCol = Card(_.bsrMst::get.colNames(0))+1;
  //WriteLn("TRACE "+_MID+"::_.nonLinBlk 2 firstCol="<<firstCol);
    Set aux = For(1,Card(nonLinFilter), NameBlock(Real numBlk)
    {
    //WriteLn("TRACE "+_MID+"::_.nonLinBlk 3.1 numBlk="<<numBlk);
      NameBlock nlf = nonLinFilter[numBlk];
      BysMcmc::BlockSampler nlb = BysMcmc::Bsr::Gibbs::NonLinBlock
      (
        nlf, 
        _.bsrMst,
        numBlk+1, 
        firstCol,
        config
      );
      Real If(ObjectExist("Set","nlf::_.externalInfo"),
      {
        Set nlf::_.externalInfo := [[ _.bsrMst, nlb ]];
        1
      });
      Real firstCol := nlb::_.lastCol+1;
      Eval(ToName(nlb::_.name)+"=nlb")
    });
    aux
  };
  //All blocks in expected order
  Set _.blocks = [[ _.bsrBlk ]] << _.nonLinBlk;

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real sel.extFlt(BysMcmc::BlockSampler nlb)
    {
      !(nlb::_.isInputFilter)
    };
    Set _.bsrMst::_.externalFilter := Select(_.nonLinBlk, sel.extFlt);
    Real ok.1 = _.bsrMst::initialize(0);
    Real init.blk(BysMcmc::BlockSampler nlb)
    {
      nlb::initialize(0)
    };
    Real ok.2 = SetMin(EvalSet(_.nonLinBlk, init.blk));
    And(ok.1, ok.2)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.draw =
  "Applies draw method of each block";
  VMatrix draw(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix bsrDraw = _.bsrBlk::draw(numSim);
    VMatrix nonLinDraw = Group("ConcatRows",
    EvalSet(_.nonLinBlk, VMatrix(NameBlock nlb)
    {
      nlb::draw(numSim)
    }));
    bsrDraw << nonLinDraw
  };

  //--------------------------------------------------------------------------
  // Public methods used by NameBlock BuildCycler 
  //--------------------------------------------------------------------------
 
  Text get.name(Real unused) 
  { 
    _.name
  }; 
  Text get.session(Real unused) 
  { 
    _.bsrMst::_.modelDef->DocInfo->Session.Name
  }; 
  Text get.path(Real unused) 
  { 
    _.bsrMst::_.modelDef->DocInfo->Path 
  }; 
  Set get.colNames(Real unused) 
  { 
    Set gcn (BysMcmc::BlockSampler block)
    {
      block::_.colNames
    };
    BinGroup("<<",EvalSet(_.blocks, gcn))
  };

  //--------------------------------------------------------------------------
  // Public methods for end user access and tools
  //--------------------------------------------------------------------------

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setStore =
  "Set values of all blocks from a given row vector of values";
  Real setStore(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+"::setStore 1 values("<<Rows(values)+"x"<<Columns(values)+")");
    Real _.bsrMst::setStore(values);
  //WriteLn("TRACE "+_MID+"::setStore 2");
    Real store.blk(BysMcmc::BlockSampler block)
    {
    //WriteLn("TRACE "+_MID+"::setStore 3 "+block::_.name);
      If(Or(!(block::enabled),
              block::_.N<=0),0,
         block::setStore(block::getMcmc(values)))
    };
    Set EvalSet(_.blocks, store.blk);
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.eval =
  "Set values of all blocks from a given row vector of values";
  Set eval(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Real Do setStore(values);
    _.bsrMst::eval(values)
  }

]]};      
/////////////////////////////////////////////////////////////////////////////
PutDescription(_.autodoc.member.NonLinMaster,NonLinMaster);
/////////////////////////////////////////////////////////////////////////////

