/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// FILE: _nonLinMaster.tol
// PURPOSE: Declares method BysMcmc::Bsr::Gibbs::BasicMaster
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.NonLinMaster =
"Builds a NameBlock that can draw a Gibbs sample of a Bayesian Sparse "
"Regression model with non linear blocks";
MasterSampler NonLinMaster(BSR.ModelDef modelDef, 
                           Set nonLinFilter,
                           Config config)
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::MasterSampler bsrMst = BysMcmc::Bsr::Gibbs::BasicMaster(modelDef, config);
  BysMcmc::MasterSampler master = [[

  BysMcmc::Config _.config = config;
  //--------------------------------------------------------------------------
  // Read only members
  //--------------------------------------------------------------------------
  //The basic BSR master
  BysMcmc::MasterSampler _.bsrMst = bsrMst;
  //Model identifier is inherited from basic BSR
  Text _.name = modelDef->DocInfo->Model.Name;  

  Text get.name(Real unused) 
  { 
    _.name
  }; 
  Text get.session(Real unused) 
  { 
    _.bsrMst::_.modelDef->DocInfo->Session.Name
  }; 
  Text get.path(Real unused) 
  { 
    _.bsrMst::_.modelDef->DocInfo->Path 
  }; 

  //Setting NameBlock description
  Text _.autodoc.description="Gibbs sampler for model "+_.name;
  //Identifier prefix for messages
  Text _MID = "[NLBSR."+_.name+"] ";
  //The basic BSR master used as a block
  BysMcmc::BlockSampler _.bsrBlk = BysMcmc::Bsr::Gibbs::BsrAsBlock
  (
    _.bsrMst,
    1,
    1,
    config
  );
  //The non linear blocks created from given filters
  Set _.nonLinBlk = 
  {
  //WriteLn("TRACE "+_MID+"::_.nonLinBlk 1 Card(nonLinFilter)="<<Card(nonLinFilter));
    Real firstCol = Card(_.bsrMst::get.colNames(0))+1;
  //WriteLn("TRACE "+_MID+"::_.nonLinBlk 2 firstCol="<<firstCol);
    Set aux = For(1,Card(nonLinFilter), NameBlock(Real numBlk)
    {
    //WriteLn("TRACE "+_MID+"::_.nonLinBlk 3.1 numBlk="<<numBlk);
      NameBlock nlf = nonLinFilter[numBlk];
      BysMcmc::BlockSampler nlb = BysMcmc::Bsr::Gibbs::NonLinBlock
      (
        nlf, 
        _.bsrMst,
        numBlk+1, 
        firstCol,
        config
      );
      Real If(ObjectExist("Set","nlf::_.externalInfo"),
      {
        Set nlf::_.externalInfo := [[ _.bsrMst, nlb ]];
        1
      });
      Real firstCol := nlb::_.lastCol+1;
      Eval(ToName(nlb::_.name)+"=nlb")
    });
    aux
  };
  //All blocks in expected order
  Set _.blocks = [[ _.bsrBlk ]] << _.nonLinBlk;

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real sel.extFlt(BysMcmc::BlockSampler nlb)
    {
      !(nlb::_.isInputFilter)
    };
    Set _.bsrMst::_.externalFilter := Select(_.nonLinBlk, sel.extFlt);
    initialize.blocks(unused)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.eval =
  "Set values of all blocks from a given row vector of values";
  Set eval(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Real Do setStore(values);
    _.bsrMst::eval(values)
  }

]]};      
