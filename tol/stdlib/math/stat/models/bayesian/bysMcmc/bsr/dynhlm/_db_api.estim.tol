//////////////////////////////////////////////////////////////////////////////
// FILE    : _db_api.estim.tol
// PURPOSE : Implements model estimation related methods of NameBlock 
//           BysMcmc::Bsr::DynHlm::DBApi
//////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
//Stores in database CODA report information of a given estimation
Real SaveParamStats(Text dbName, Text model, Text session, @Estimation estim)
////////////////////////////////////////////////////////////////////////////
{
  WriteLn("[SaveParamStats] Storing in data base diagnostics about "
    "estimated parameters");
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  Real BysMcmc::Bsr::DynHlm::DBApi::SqlExecTrace(
  "DELETE FROM "+dbName+"."+_table::ParamStats+"\n"
  "WHERE id_model='"+model+"' AND id_session='"+session+"';\n");
  Set summary  = estim::report::coda.summary;
  Set raftery_ = estim::report::coda.raftery.diag;
  Set raftery  = If(Card(raftery_)==Card(summary)+1, raftery_, Copy(Empty));
  Real SqlStartCachedInsert(0);  
  Set For(1,Card(estim::report::coda.summary),Real save.param(Real k)
  {
    Set cs = summary[k];
    Set cr = If(Card(raftery), raftery[k], 
                BysMcmc::@BysInf.Coda.Diag.Raftery("",?,?,?,?,?,?));
    WriteLn("[SaveParamStats] Storing "+cs->varName_);
    Set token = Tokenizer(Replace(cs->varName_,"::",":"),":");
    Text gibbs_blk = token[1];
    Text id_node = token[2];
    Text id_parameter = token[3]+If(Card(token)==3,"",
      SetSum(For(4,Card(token),Text build.member(Real tk) 
      {"::"+token[tk]} )));
    Real BysMcmc::Bsr::DynHlm::DBApi::SqlCachedInsert(
    dbName+"."+_table::ParamStats,
    "'"+
     model+"','"+
     session+"','"+
     id_node+"','"+
     id_parameter+"','"+
     gibbs_blk+"',"<<
     IntText(k)+","<<
     SqlFormatReal(cs->mean_)+","<<
     SqlFormatReal(cs->sd_)+","<<
     SqlFormatReal(cs->naive.se_)+","<<
     SqlFormatReal(cs->tmser.se_)+","<<
     SqlFormatReal(cs->q.001_)+","<<
     SqlFormatReal(cs->q.025_)+","<<
     SqlFormatReal(cs->q.250_)+","<<
     SqlFormatReal(cs->q.500_)+","<<
     SqlFormatReal(cs->q.750_)+","<<
     SqlFormatReal(cs->q.975_)+","<<
     SqlFormatReal(cs->q.999_)+","<<
     SqlFormatReal(cr->length_)+","<<
     SqlFormatReal(cr->burnin_)+","<<
     SqlFormatReal(cr->size_)+","<<
     SqlFormatReal(cr->size.min_)+","<<
     SqlFormatReal(cr->dep.factor_)+","<<
     SqlFormatReal(cr->remain_))
  });
  Real SqlStopCachedInsert(0);
  1
};

/////////////////////////////////////////////////////////////////////////////
//Builds linear block effects for a row vector of parameters related to the
//given set of variable names corresponding to the BSR-HLM estimation with
//the specified series.handler
Set GetLinearBlkEffects(Set colNames_, 
                        Matrix param, 
                        @MasterSampler sampler, 
                        NameBlock series.handler)
/////////////////////////////////////////////////////////////////////////////
{
  WriteLn("[GetLinearBlkEffects] Building series of linear block effects");
  Set colNames = EvalSet(colNames_,Text(Text name) 
  { 
    Text expr = ToName(name)+"=name";
    Eval(expr) 
  });
  Real SetIndexByName(colNames);

  Set LinearBlk.Effects = EvalSet(series.handler::_.obs.node, Set(NameBlock nsh)
  {
    Real outIsATimeSerie = ObjectExist("Serie",  "nsh::_.output::_.serie");
    Real outIsAVector    = ObjectExist("Matrix", "nsh::_.output::_.vector");
    WriteLn("[GetLinearBlkEffects] Building node "+nsh::_.id_node);
    Set effect = EvalSet(nsh::_.input, Anything(NameBlock inp)
    {
      Text inpName = Name(inp);
      Case(
      outIsATimeSerie,
      {
        WriteLn("[GetLinearBlkEffects] Building time series input "+inpName);
        Ratio tf = If(!ObjectExist("Ratio","inp::_.transferFunction"),1/1,
          inp::_.transferFunction);
        Polyn omega = Numerator  (tf);
        Polyn delta = Denominator(tf);
        Real p = Degree(omega);
        Real q = Degree(delta);
        Real h = Max(p,q);
        Real noTransFunFlag = h==0;
       
        Serie eff = Case(
        Not(inp::_.enabled), 
        {
          inp::_.serie*0
        },
        noTransFunFlag,
        {
          Real coef = 
          {
            Text varName = "LinearBlk::"+nsh::_.id_node+"::"+inpName+"::Coef";
            Text varNameTol = ToName(varName);
            Real k = FindIndexByName(colNames, varNameTol);
            If(!k, WriteLn("Cannot find lineal parameter called "+
              varNameTol+" in set \n"<<colNames,"E"));
            MatDat(param,1,k)
          };
          inp::_.serie * coef
        },
        1==1,
        {
          Polyn omega.estim = SetSum(EvalSet(Monomes(omega),Polyn(Polyn mon)
          {
            Text varName = "OmegaBlk::"+nsh::_.id_node+"::"+
                           inpName+"::NumDeg."+IntText(Degree(mon));
            Text varNameTol = ToName(varName);
            Real k = FindIndexByName(colNames, varNameTol);
            If(!k, WriteLn("Cannot find omega parameter called "+
              varNameTol+" in set \n"<<colNames,"E"));
            MatDat(param,1,k)
          }));
          Polyn delta.estim = SetSum(EvalSet(Monomes(1-delta),Polyn(Polyn mon)
          {
            Text varName = "DeltaBlk::"+nsh::_.id_node+"::"+
                           inpName+"::DenDeg."+IntText(Degree(mon));
            Text varNameTol = ToName(varName);
            Real k = FindIndexByName(colNames, varNameTol);
            If(!k, WriteLn("Cannot find delta parameter called "+
              varNameTol+" in set \n"<<colNames,"E"));
            MatDat(param,1,k)
          }));
          Set denIni.estim = For(1,h,Real denIni.param(Real lag)
          {
            Text varName = "DeltaBlk::"+nsh::_.id_node+"::"+
                           inpName+"::DenIni."+IntText(h-lag);
            Text varNameTol = ToName(varName);
            Real k = FindIndexByName(colNames, varNameTol);
            If(!k, WriteLn("Cannot find delta init value parameter called "+
              varNameTol+" in set \n"<<colNames,"E"));
            MatDat(param,1,k)
          });
          If(!h, 
          {
            DifEq(tf, inp::_.serie)
          },
          {
            Date fst.ser = First(inp::_.serie);
            Date fst.p   = Succ(fst.ser, Dating(inp::_.serie), p);
            Date fst.q   = Succ(fst.p,   Dating(inp::_.serie),-q);
            Serie denIni.ser = MatSerSet(SetRow(denIni.estim), Dating(inp::_.serie), fst.q)[1];
            DifEq(omega.estim/delta.estim, inp::_.serie, denIni.ser)
          })
        });
        Eval("Serie "+inpName+".Effect = eff")
      },
      outIsAVector,
      {
        WriteLn("[GetLinearBlkEffects] Building vector input "+inpName);
         Ratio tf = If(!ObjectExist("Ratio","inp::_.transferFunction"),1/1,
          inp::_.transferFunction);
        Polyn omega = Numerator  (tf);
        Polyn delta = Denominator(tf);
        Real p = Degree(omega);
        Real q = Degree(delta);
        Real h = Max(p,q);
        Real noTransFunFlag = h==0;

        Matrix eff = Case(
        Not(inp::_.enabled), 
        {
          inp::_.vector*0
        },
        noTransFunFlag,
        {
          Real coef = 
          {
            Text varName = "LinearBlk::"+nsh::_.id_node+"::"+inpName+"::Coef";
            Text varNameTol = ToName(varName);
            Real k = FindIndexByName(colNames, varNameTol);
            If(!k, WriteLn("Cannot find lineal parameter called "+
              varNameTol+" in set \n"<<colNames,"E"));
            MatDat(param,1,k)
          };
          inp::_.vector * coef
        });
        Eval("Matrix "+inpName+".Effect = eff")
      },
      {
        WriteLn("[GetLinearBlkEffects] Invalid input "+inpName, "E");
        Real Stop
      })
    });
    Set Eval("Set "+nsh::_.id_node+".Effect=effect")
  })
};


////////////////////////////////////////////////////////////////////////////
//Estimates a BSR-HLM model and stores in data base status information 
//during process and CODA diagnostics over parameters at the end
//Returns the MCMC, the CODA report and the evaluation time series and 
//effects using parameter average.
NameBlock GetModelDef(Text dbName, 
                      Text model, 
                      Text session, 
                      Text resultRootPath,
                      NameBlock seriesHandler, 
                      BysMcmc::@Config config)
////////////////////////////////////////////////////////////////////////////
{
  Real BysMcmc::Bsr::DynHlm::DBApi::useNodeInMissingIdentifier := 
    config::DBApi.useNodeInMissingIdentifier;
  NameBlock _table = BysMcmc::Bsr::DynHlm::DBApi::_.table;
  //Resets model-session register at EstimStatus table
  Real BysMcmc::Bsr::DynHlm::DBApi::SqlExecTrace(
  "DELETE FROM "+dbName+"."+_table::EstimStatus+"\n"
  "WHERE id_model='"+model+"' AND id_session='"+session+"';\n");
  Real BysMcmc::Bsr::DynHlm::DBApi::SqlExecTrace(
  "INSERT INTO "+dbName+"."+_table::EstimStatus+"\n"
  "VALUES('"+
    model+"','"+
    session+"',"+
    "1,"+
    "NULL,"+   //te_path_data_out
    "NULL,"+   //nu_mcmc_var
    IntText(config::mcmc.burnin)+","+
    IntText(config::mcmc.sampleLength)+","+
    IntText(config::mcmc.cacheLength)+","+
    "0,"+      //nu_mcmc_currentLength
    "NULL,"+   //vl_mcmc_time_avg
    "0,"+      //nu_error
    "0,"+      //nu_warning
    "NULL,"+   //dh_loading
    "NULL,"+   //dh_parsing
    "NULL,"+   //dh_initializing
    "NULL,"+   //dh_simulating
    "NULL,"+   //dh_reporting
    "NULL,"+   //dh_evaluating
    "NULL,"+   //dh_saving
    "NULL)");  //dh_ending

  Eval("NameBlock "+
  "BysMcmc::Bsr::DynHlm::DBApi::LoadModelDef."+
    config::DBApi.modularSchema+
  "(dbName,id_model,id_session,resultRootPath,seriesHandler,config)")
};

////////////////////////////////////////////////////////////////////////////
//Estimates a BSR-HLM model and stores in data base status information 
//during process and CODA diagnostics over parameters at the end
//Returns the MCMC, the CODA report and the evaluation time series and 
//effects using parameter average.
@Cycler GetCycler(Text dbName, 
                 Text model, 
                 Text session, 
                 Text resultRootPath,
                 NameBlock seriesHandler, 
                 BysMcmc::@Config config)
////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::@Notifier dbNotifier=BysMcmc::@Notifier.DB::New
    (dbName,model,session);
  Real dbNotifier::loading(0);  
  NameBlock model.def = GetModelDef(
    dbName, model, session, resultRootPath, seriesHandler, config);
  BysMcmc::@Cycler cycler = BysMcmc::Bsr::Gibbs::GetCycler(
    model.def, BysMcmc::@McmcPartialHandler::Null(0), config, dbNotifier);
  Set Append(cycler::auxInfo, [[series.handler]]);
  cycler
};


////////////////////////////////////////////////////////////////////////////
Real CloseModel(@Estimation estim)
////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::@Config config = estim::cycler::_.config;
  Real If(config::do.linear.effects,
  {
    Set estim::linear.effects := GetLinearBlkEffects(
      estim::report::colNames, 
      estim::param.average, 
      estim::cycler::_.sampler,
      estim::cycler::auxInfo::series.handler);
    1
  });
  Real If(config::do.save.DBApi.Estim.Oza,
  {
    Real estim::cycler::_.notifier::saving(0);
    Real Ois.Store([[estim]], estim::cycler::auxInfo::ascii+".estim.oza");
    1
  });
  Real If(config::do.report,BysMcmc::Bsr::DynHlm::DBApi::SaveParamStats
  (
    estim::cycler::_.notifier::_.dbName,
    estim::cycler::_.notifier::_.model,
    estim::cycler::_.notifier::_.session,
    estim
  ));
  Real estim::cycler::_.notifier::ending(0);
  1
};

