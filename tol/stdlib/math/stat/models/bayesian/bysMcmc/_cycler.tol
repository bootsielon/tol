/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// FILE: _build.tol
// PURPOSE: Declares Class BysMcmc::Cycler method BysMcmc::BuildCycler
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Cycler =
"This class is able to generate a Markov Chain of a model "
"by cycling calls of a given model sampler and gives a set of tools to " 
"make Bayesian Inference about it.\n "
"Arguments:\n"
"  MasterSampler modelSampler is a handler of the model to be simulated\n"
"  Config config has user configuration parameters\n"
"  Notifier notifier is an event tracing handler\n";
Class Cycler
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::MasterSampler _.sampler;
  BysMcmc::Notifier      _.notifier;
  BysMcmc::Config        _.config;

  //Stores the sampler name
  Text _.name = "";
  //Puts the Markov Chain path relative to sampler path
  Text _.path = "";
  //The number of variables of Markov Chain
  Real _.n = ?;
  //Timer member that can be externally consulted 
  Real _.time = ?;
  Real _mcmc.maxTime = ?;
  Real _.sampleLength = ?;
  Real _.savedSimulations = ?;
  //Setting NameBlock description
  Text _.autodoc.description = "";

  Set auxInfo = Copy(Empty);

  //--------------------------------------------------------------------------
  // Configuration members
  //--------------------------------------------------------------------------
  //The number of simulations cached in RAM before to disc writing
  Real cacheLength_ = ?;
  //If resume is true and there was old simulations in _.path, new ones will 
  //be added at the end. In other case old simulations will be lost.
  Real resume_ = ?;
  //Bayesian inference configuration
  Set bysInf_ = Copy(Empty);

  //--------------------------------------------------------------------------
  // Public methods
  //--------------------------------------------------------------------------

  Real define(Real unused)
  {
    //Stores the sampler name
    Text _.name := _.sampler::get.name(0)+"."+_.sampler::get.session(0);
    //Puts the Markov Chain path relative to sampler path
    Text _.path := Replace(_.sampler::get.path(0)+_.name+".mcmc.bbm","\\","/");
    //The number of variables of Markov Chain
    Real _.n := Card(_.sampler::get.colNames(0));
    //Timer member that can be externally consulted 
    Real _.time := 0;
    Real _mcmc.maxTime := _.config::mcmc.maxTime;
    //Setting NameBlock description
    Text _.autodoc.description :="MCMC cycling builder for model "+_.name;

    //--------------------------------------------------------------------------
    // Configuration members
    //--------------------------------------------------------------------------
    //The number of simulations cached in RAM before to disc writing
    Real cacheLength_ := _.config::mcmc.cacheLength;
    //If resume is true and there was old simulations in _.path, new ones will 
    //be added at the end. In other case old simulations will be lost.
    Real resume_ := _.config::do.resume;
    //Bayesian inference configuration
    Set bysInf_ := {BysInf.Report.Config
    (
      Real raftery.diag.q   = _.config::report.raftery.diag.q,
      Real raftery.diag.r   = _.config::report.raftery.diag.r,
      Real raftery.diag.s   = _.config::report.raftery.diag.s,
      Real raftery.diag.eps = _.config::report.raftery.diag.eps,
      Real acf.lag          = _.config::report.acf.lag,
      Real histogram.parts  = _.config::report.histogram.parts,
      Real kerDens.points   = _.config::report.kerDens.points
    )};
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.resume =
  "Reloads n=resume_ saved simulations if possible";
  Real resume(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[Cycler::resume] ";
    If(resume_==0, 
    {
      Real ok.remove = OSFilRemove(_.path);
      Real If(!ok.remove, 
      {
        WriteLn("Please, change session identifier or clean old file and retray it", "E");
        Stop
      });
      0
    },
    {
      Real WriteLn(_MID+"Trying to resume MCMC from "<<_.path);
      If(!FileExist(_.path),
      {
        Real WriteLn(_MID+"Cannot find MCMC at "<<_.path+" to resume","W");
        0
      },
      {
        Set old.mcmc.dim = MatReadDimensions(_.path);
        Real m = old.mcmc.dim::Rows;
        Real n = old.mcmc.dim::Columns;
        Case(
        Not(m),
        {
          Real WriteLn(_MID+"Empty MCMC at "<<_.path+" to resume","W");
          Real OSFilRemove(_.path);
          0
        },
        n==_.n, 
        {
          Real m_ = Case(
            resume_>0, Min(m,resume_),
            resume_<0, Max(0,m+resume_) );
          If(m_==0,
          {
            WriteLn(_MID+"There are not enougth old simulations to resume");
            Real OSFilRemove(_.path);
            0
          },
          {
            Real WriteLn(_MID+"resuming "<<m_+" old simulations");
            Matrix resumed = If(m_==m,
            {
              MatReadFile(_.path)
            },
            {
              Real WriteLn(_MID+"Removing last "<<Real(m-m_)+" old simulations");
              Matrix aux = MatReadRows(_.path,1,m_,1);
              Matrix MatWriteFile(_.path, aux);
              aux
            });
            Matrix lastRow = Sub(resumed,m_,1,1,_.n);
            WriteLn(_MID+"Setting last resumed row as initial point");
            Real _.sampler::setStore(lastRow);
            m_
          })
        },
        1==1,
        {
          Real WriteLn(_MID+"Cannot resume due to old MCMC saved on "+
            _.path+" has "+IntText(n)+" columns instead "
            "of current nummber of parameters "+IntText(_.n)+".\n"
            "Old MCMC will be removed","W");
          Real ok.remove = OSFilRemove(_.path);
          Real If(!ok.remove, 
          {
            WriteLn("Please, change session identifier or clean old file and retray it", "E");
            Stop
          });
          0
        }) 
      })
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[Cycler::initialize] ";
    Real _.notifier::initializing(_.n, _.path);
    Real _.savedSimulations := resume(0);
    Real ok = If(!_.savedSimulations,
    {
       _.sampler::initialize(0)
    },
    {
       _.sampler::resume(0)
    });
    ok
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.generate =
  "Generates and stores a Markov Chain with sampleLength simulations and "
  "return the number of successfully saved ones";
  Real generate(Real sampleLength)
  ////////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[Cycler::generate] ";
    Real _.sampleLength := sampleLength;
    Real OSDirMake(GetFilePath(_.path));
    Real numDec = 1+Ceil(Log(_.sampleLength)/Log(10));
    Text numIterFmt = "% "+IntText(numDec)+".0lf";
    Real numErr0 = Copy(NError);
    Matrix cache = Rand(0,_.n,0,0);
    Real initialize(0);
    Real t0 = Copy(Time);
    Real t1 = Copy(Time);
    Real numSim = _.savedSimulations;
    Real end = GE(numSim,_.sampleLength);
    If(numErr0<NError,
    {
      CMsg::Coded::show(BysMcmc::_.cmsg::_.cannotContinueSimulation,
      [[_MID, Real (NError-numErr0) ]])
    });
    Real runSim = 0;
    Real If(_.config::do.mcmc.profiler, 
      TolOprProfiler.Enabled := True);
    Real _.notifier::simulating(0, 0);
    Real WriteLn(_MID+_.name+
      "\n Storing MCMC in file ....... : "<<_.path+
      "\n Number of fixed variables .. : "<<_.sampler::_.fixedParamNum+
      "\n Number of reloaded variables : "<<_.sampler::_.reloadParamNum+
      "\n Number of sampled variables  : "<<_.sampler::_.freeParamNum+
      "\n Number of total variables .. : "<<_.n+
      "\n Number of simulations ...... : "<<_.sampleLength+
      "\n Cache length ............... : "<<cacheLength_+
      "\n Resume ..................... : "<<resume_+
      If(_mcmc.maxTime<1/0,
      "\n MaxTime ...................  : "<<_mcmc.maxTime+" seconds",""));
    While(!end,
    {
      Real runSim := runSim+1;
      Real numSim := numSim+1;
    //WriteLn("TRACE "+_MID+"2 numSim="<<numSim);
      Real doCache = Or(cacheLength_==1,numSim%cacheLength_==1);
    //WriteLn("TRACE "+_MID+"3");
      Real If(doCache,
      {
        If(cacheLength_>1,
        {
          Write(" Simulating iterations "+
            FormatReal(numSim,numIterFmt)+"-"+
            FormatReal(numSim+cacheLength_-1,numIterFmt))
        },
        {
          Write(_MID+"Simulating iteration "+ IntText(numSim))
        });
        If(And(cacheLength_>1,!Rows(cache)), WriteLn(" ... "),
        {
          Real donePercent = 100*numSim / _.sampleLength;
          Real t2 = Copy(Time);
          Real _.time := (t2-t1)/cacheLength_;
          Real remain = _.time * (_.sampleLength-numSim);
          WriteLn(" [done "+FormatReal(donePercent,"% 6.2lf")+"%]"+
                  " [time/sim:"+FormatReal(_.time,"% 9.6lf")+" s]"+
                  " [remaining "+FormatReal(remain,"% 6.0lf")+" s]");
          Real _.notifier::simulating(numSim-1, _.time);
          Real t1 := t2
        });
        1
      });
    //WriteLn("TRACE "+_MID+"4");
      VMatrix draw_ = _.sampler::draw(numSim);
      Matrix  draw  = VMat2Mat(draw_);
    //WriteLn("TRACE "+_MID+"5 draw("<<Rows(draw)+"x"<<Columns(draw)+")");
    //WriteLn("TRACE "+_MID+"6 cache("<<Rows(cache)+"x"<<Columns(cache)+")");
      Matrix cache := cache << Tra(draw);
    //WriteLn("TRACE "+_MID+"7");
      Real If(doCache,
      {
      //WriteLn("TRACE "+_MID+"9");
        Matrix Do MatAppendFile(_.path, cache);
        Real _.savedSimulations := numSim;
        Matrix cache := Rand(0,_.n,0,0);
        1
      });
      Real Case(
      GE(numSim,_.sampleLength),
      {
        WriteLn("Simulation process has ended succesfully");
        Real end := True
      },
      GE(Time-t0,_mcmc.maxTime),
      {
        WriteLn("Maximum time has been elapsed and process will be stoped",
                "W");
        Real end := True
      },
      GT(NError,numErr0), 
      {
      //WriteLn("TRACE "+_MID+"10");
        Real CMsg::Coded::show(BysMcmc::_.cmsg::_.cannotContinueSimulation,
        [[_MID,Real (NError-numErr0)]]);
        Real end := True
      });
      1
    //WriteLn("TRACE "+_MID+"8");
    });
  //WriteLn("TRACE "+_MID+"11");
    Matrix Do MatAppendFile(_.path, cache);
    Real _.notifier::simulating(numSim, _.time);
  //WriteLn("TRACE "+_MID+"12");
    Real _.savedSimulations := numSim;
    Real _.time := (Time - t0)/runSim;
    WriteLn(" [time by simulation:"<<_.time+"]");
    Real If(config::do.mcmc.profiler, 
      TolOprProfiler.Dump(cycler::_.path+cycler::_.name));
    //WriteLn("TRACE "+_MID+"1");
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.loadFullMcmc =
  "Loads the full stored Markov Chain previouslu generated.";
  Matrix loadFullMcmc(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    MatReadFile(_.path)
  };
  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.loadMcmc =
  "Loads the stored Markov Chain generated by method generate skiping "
  "first burnin rows and selecting one of each thinning ones.";
  Matrix loadMcmc(Real burnin, Real length, Real thinning)
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Inference::loadMcmc(_.path, burnin, length, thinning)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.report =
  "Returns a report about Bayesian Inference over the Markov Chain, "
  "including some CODA items.";
  Set report(Real burnin, Real length, Real thinning)
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Inference::loadAndReport(
      _.path, burnin, length, thinning, 
      _.name, _.sampler::get.colNames(0), bysInf_)
  }

};
