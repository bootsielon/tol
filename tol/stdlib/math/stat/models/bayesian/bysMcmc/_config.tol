//////////////////////////////////////////////////////////////////////////////
// FILE   : _config.tol
// PURPOSE: Configuration of Bayesian MonteCarlo Markov Chain methods
//////////////////////////////////////////////////////////////////////////////

//Options used over all BysMcmc related components
NameBlock Options =
[[
  //Scalar samplers draws a univariant distribution given the logarithm of
  //density function and a domain interval
  //The API of a scalar sampler  is given by a function like this
  //  Real (Code logDens, Real x0, Real x1)
  NameBlock Scalar.Sampler = 
  [[
    Real Arms(Code logDens, Real x.min, Real x.max, Real x.0)
    {
      ARMS(logDens, x.min, x.max, x.0)
    };
    Real Slice(Code logDens, Real x.min, Real x.max, Real x.0)
    {
      MatDat(SliceSampler1D(logDens, x.min, x.max, x.0),1,1)
    }
  ]];
  NameBlock Arima.Filter =
  [[
    //Exact method. Requires a Cholesky decomposition that is built in a 
    //fast and complex way.
    Text FastChol = "FastChol",
    //Approximated method valid and faster than FastChol when there are two 
    //or more distinct periods and one is much larger than the others.
    Text FastCholSea = "FastCholSea",
    //Approximated method valid and faster than FastChol and FastCholSea when
    //the data length is very large
    Text DifEq = "DifEq"
  ]]
]];

//Configuration default values over all BysMcmc related components
Class Config
{
//===========================================================================
//MCMC dimensions
//===========================================================================
  //The final number realizations that will remain after burnin
  Real mcmc.sampleLength = 2000;
  //The frequency of simulation notifying and chain cache updating
  Real mcmc.cacheLength = 100;
  //The number of first realizations that will be skiped at inference and 
  //diagnostic time
  Real mcmc.burnin = 100;
  //Only one of each this number of simulations will be selected for 
  //inference and diagnostic
  Real mcmc.thinning = 1; //thinningg
  //Maximum of time in seconds dedicated to simulation
  //Process will be stoped after mcmc.sampleLength + mcmc.burnin 
  //simulations or mcmc.maxTime seconds will be elapsed
  Real mcmc.maxTime = 1/0;

//===========================================================================
//Partial sampling configuration
//===========================================================================
  Real partialSampling.Sequential = True;

//===========================================================================
//BSR configuration
//===========================================================================
  //Try order for given by user solution to start MCMC
  Real bsr.iniVal.try.givenByUser = 1;
  //Try order for zero solution to start MCMC
  Real bsr.iniVal.try.zero = 2;
  //Try order for constrained minimum norm solution to start MCMC
  Real bsr.iniVal.try.cnstrMinNorm = 3;
  //Try order for constrained max likelihood solution to start MCMC
  Real bsr.iniVal.try.cnstrMLE = 4;
  //If solution error is great than this value a warning will be shown
  Real bsr.cholesky.epsilon = 1.E-16;
  //The notifying frequency of Cholesky warning
  Real bsr.cholesky.warningFreq = 100;
  //The number of burnin realizations in Gibbs drawing of truncated 
  //multinormal
  Real bsr.truncMNormal.gibbsNumIter = 0;
  //Drops linear block matrix to force maximum sparsity
  Real bsr.linBlk.X.drop = 1.E-16;
  //Enables/disbales precondidioning for linear blocks of BSR
  Real bsr.linBlk.usePreconditioning = False;
  //Use Metropolis-Hastings instead og Gibbs for linear blocks after
  //this number of iterations
  Real bsr.linBlk.MH.useAfterIter = 10;
  //Use Gibbs method after these rejections of Metropolis-Hastings 
  Real bsr.linBlk.MH.maxRejected  = 2;
  //Use Gibbs method after these consecutive iterations of Metropolis-Hastings 
  Real bsr.linBlk.MH.maxConsecutive = 10;
  //Scalar sampler used in ARMA block of basic BSR can be a member of 
  //BysMcmc::Options::Scalar.Sampler or an API equivalent function
  Code bsr.scalarSampler.armaBlock = BysMcmc::Options::Scalar.Sampler::Slice;
  //Scalar sampler used in ARMA block of basic BSR can be a member of 
  //BysMcmc::Options::Scalar.Sampler or an API equivalent function
  Code bsr.scalarSampler.nonLinBlock = BysMcmc::Options::Scalar.Sampler::Slice;
  //Arima filter method
  Text bsr.arimaFilter = BysMcmc::Options::Arima.Filter::FastChol;
//===========================================================================
//CODA and other diagnostic report configuration
//===========================================================================
  //The quantile to be estimated in Raftery test
  Real report.raftery.diag.q = 0.025;
  //The desired margin of error of the estimate in Raftery test
  Real report.raftery.diag.r = 0.007;  
  //The probability of obtaining an estimate in the interval (q-r,q+r) in 
  //Raftery test
  Real report.raftery.diag.s = 0.950;  
  //Precision required for estimate of time to convergence in Raftery test
  Real report.raftery.diag.eps = 0.001;
  //Lag of AutoCorrelation Function 
  Real report.acf.lag= 20;
  //Number of divisions in histograms
  Real report.histogram.parts = 100;
  //Number of divisions in kernel density aproximations
  Real report.kerDens.points = 0;
//===========================================================================
//Generic flags
//===========================================================================
  //If positive then is the number of existent realizations to be recovered 
  //from disk
  //If negative then is the number of last existent realization to be
  //skyped
  //If zero then no resuming will be made and a new Markov chain will be
  //generated
  Real do.resume = 0;
  //Enables or disables CODA and other diagnostic reports
  Real do.report = True;
  //Enables or disables in-sample evaluation of forecasting, filter, noise, 
  //residuals, ...
  Real do.eval = True;
  //Enables or disables in-sample evaluation of individual linear effects
  Real do.linear.effects = True;
  //Enables or disables saving full results of DBApi::Estim
  Real do.save.DBApi.Estim.Oza = True;
  //If it's true the automatic generated input missing variables will use 
  //id_node as prefix of identifier. Else it will use MIXTURE node and all
  //inputs with the same name will are referred to the same input missing
  //variables. 
  Real DBApi.useNodeInMissingIdentifier = True;
  //If true an internal TOL profiling will be executed
  Real do.mcmc.profiler = False

};

//////////////////////////////////////////////////////////////////////////////
Config Config.Default(Real unused)
//////////////////////////////////////////////////////////////////////////////
{
  Config default;
  default
};

