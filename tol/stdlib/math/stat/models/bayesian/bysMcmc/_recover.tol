/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// FILE: _recover.tol
// PURPOSE: 
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
Class McmcRecover: McmcReloader
/////////////////////////////////////////////////////////////////////////////
{
  Text _.name;
  Set  _.colNames;
  Set  _.repCfg;
  Text _.mcmc.path;

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Text mcmc.path, Real sequential, Real burnin)
  ////////////////////////////////////////////////////////////////////////////
  {
    Text _.mcmc.path := mcmc.path;
    Real _.sequential := sequential;
    Real _.burnin := burnin;
    Set mcmc.dim = MatReadDimensions(_.mcmc.path);
    Real Case(mcmc.dim::Columns!=Card(_.colNames),
    {
      WriteLn("[McmcRecover::initialize] Stored MCMC columns differs from "
              "number of parameters","E");
      False 
    },
    burnin>=mcmc.dim::Rows,
    {
      WriteLn("[McmcRecover::initialize] Stored MCMC rows is less or equal "
      "than specified burnin","E");
      False 
    },
    1==1,
    {
      Real _.sampleLength := mcmc.dim::Rows - burnin;
       Real SetIndexByName(_.colNames);
      Real initialize.sequence(0);
      True
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Set report(Real burnin, Real length, Real thinning)
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Inference::loadAndReport(
      _.mcmc.path, burnin, length, thinning, 
      _.name, _.colNames, _.repCfg)
  };

  ////////////////////////////////////////////////////////////////////////////
  Set selectIndexes(Set selectedNames)
  ////////////////////////////////////////////////////////////////////////////
  {
    SelectIndexByName(selectedNames, _.colNames)
  };


  ////////////////////////////////////////////////////////////////////////////
  VMatrix reloadSimulation(Real numSim, Set indexes)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real numRow = getRowSequence(numSim);
    Matrix row = MatReadRows(_.mcmc.path, numRow, 1);
    Mat2VMat(SubCol(row, indexes), TRUE)
  }                        

};

/////////////////////////////////////////////////////////////////////////////
Real StoreRecover(Cycler cycler, Real sequential)
/////////////////////////////////////////////////////////////////////////////
{
  Text recover.path = 
    cycler::_.sampler::get.path(0)+cycler::_.name+".recover.oza";
  BysMcmc::McmcRecover recover = 
  [[
    Text _.name      = cycler::_.name;
    Set  _.colNames  = SetTolNameAndIndex(cycler::_.sampler::get.colNames(0));
    Set  _.repCfg    = cycler::bysInf_;
    Text _.mcmc.path = cycler::_.path;
    Real _.sequential = sequential
  ]];
  Real SetIndexByName(recover::_.colNames);
  Real Ois.Store([[recover]],recover.path);
  1
};

/////////////////////////////////////////////////////////////////////////////
McmcRecover Get.Recover(Text rootPath, Text id_model, Text id_session,
                        Config config)
/////////////////////////////////////////////////////////////////////////////
{
  Text path      = rootPath+id_model+"."+id_session+".recover.oza";
  Text mcmc.path = rootPath+id_model+"."+id_session+".mcmc.bbm";
  WriteLn("Reloading MCMCRecover from path "+path);
  Set Ois.Load(path);
  Real recover::initialize(
    GetAbsolutePath(mcmc.path),
    config::partialSampling.Sequential,
    config::mcmc.burnin);
  recover 
};

/////////////////////////////////////////////////////////////////////////////
Set RecoveAndReport(Text rootPath, Text id_model, Text id_session,
                    Real burnin, Real length, Real thinning)
/////////////////////////////////////////////////////////////////////////////
{
  McmcRecover recover = BysMcmc::Get.Recover(
    rootPath, id_model, id_session);
  Set report = recover::report(burnin,length,thinning)
};

