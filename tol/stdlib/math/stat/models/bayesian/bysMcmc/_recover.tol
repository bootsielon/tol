/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// FILE: _recover.tol
// PURPOSE: 
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
Class @McmcRecover: @McmcReloader
/////////////////////////////////////////////////////////////////////////////
{
  Text _.name;
  Set  _.colNames;
  Set  _.repCfg;
  Text _.mcmc.path;
  //--------------------------------------------------------------------------
  //Auxiliar members
  //--------------------------------------------------------------------------
  Real _.mcmc.handler = ?;
  Real _.mcmc.rows = ?;
  Real _.mcmc.cols = ?;

  ////////////////////////////////////////////////////////////////////////////
  Real initialize(Text mcmc.path, Real sequential, Real burnin)
  ////////////////////////////////////////////////////////////////////////////
  {
    Text _.mcmc.path := mcmc.path;
    Real _.mcmc.handler := FOpen(_.mcmc.path,"rb");
    Real _.sequential := sequential;
    Real _.burnin := burnin;
    Set mcmc.dim = MatReadDimensions(_.mcmc.path);
    Real _.mcmc.rows := mcmc.dim::Rows;
    Real _.mcmc.cols := mcmc.dim::Columns;

    Real Case(_.mcmc.cols!=Card(_.colNames),
    {
      WriteLn("[@McmcRecover::initialize] Stored MCMC columns differs from "
              "number of parameters","E");
      False 
    },
    burnin>=_.mcmc.rows,
    {
      WriteLn("[@McmcRecover::initialize] Stored MCMC rows is less or equal "
      "than specified burnin","E");
      False 
    },
    1==1,
    {
      Real _.sampleLength := _.mcmc.rows - burnin;
       Real SetIndexByName(_.colNames);
      Real initialize.sequence(0);
      True
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Set report(Real burnin, Real length, Real thinning)
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Inference::loadAndReport(
      _.mcmc.path, burnin, length, thinning, 
      _.name, _.colNames, _.repCfg)
  };

  ////////////////////////////////////////////////////////////////////////////
  Set selectIndexes(Set selectedNames)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(!Card(selectedNames) | !Card(_.colNames) , Copy(Empty),
    {
      Real If(!HasIndexByName(selectedNames), SetIndexByName(selectedNames));
      SelectIndexByName(selectedNames, _.colNames)
    })
  };


  ////////////////////////////////////////////////////////////////////////////
  VMatrix reloadSimulation(Real numSim, Set indexes)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real numRow = getRowSequence(numSim);
    Matrix row = MatReadRows(
      _.mcmc.handler, numRow, 1, 1, _.mcmc.rows, _.mcmc.cols);
    Mat2VMat(SubCol(row, indexes), TRUE)
  };

  ///////////////////////////////////////////////////////////////////////////
  Static Real Store(@Cycler cycler, Real sequential)
  ///////////////////////////////////////////////////////////////////////////
  {
    Text recover.path = 
      cycler::_.sampler::get.path(0)+".recover.oza";
    WriteLn("Storing @McmcRecover into path "+recover.path);
    BysMcmc::@McmcRecover recover = 
    [[
      Text _.name      = cycler::_.name;
      Set  _.colNames  = SetTolNameAndIndex(cycler::_.sampler::get.colNames(0));
      Set  _.repCfg    = cycler::bysInf_;
      Text _.mcmc.path = cycler::_.path;
      Real _.sequential = sequential
    ]];
    Real SetIndexByName(recover::_.colNames);
    Real Ois.Store([[recover]],recover.path);
    1
  };

  ///////////////////////////////////////////////////////////////////////////
  Static @McmcRecover Load(Text bsrPath, @Config config)
  ///////////////////////////////////////////////////////////////////////////
  {
    Text path      = bsrPath+".recover.oza";
    Text mcmc.path = bsrPath+".mcmc.bbm";
    WriteLn("Reloading MCMCRecover from path "+path);
    Set Ois.Load(path);
    Real recover::initialize(
      GetAbsolutePath(mcmc.path),
      config::partialSampling.Sequential,
      config::mcmc.burnin);
    recover 
  };

  ///////////////////////////////////////////////////////////////////////////
  Static Set LoadAndReport(Text bsrPath,
                           Real burnin, Real length, Real thinning)
  ///////////////////////////////////////////////////////////////////////////
  {
    @McmcRecover recover = BysMcmc::Load(bsrPath);
    Set report = recover::report(burnin,length,thinning)
  }

};

