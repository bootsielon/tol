//////////////////////////////////////////////////////////////////////////////
//FILE: test.tol
//AUTHOR: vdebuen@tol-project.org
//CREATION: 2008-09-23
//PURPOSE: Testing system Bsr-Hlm with deltas.
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//Loads database connection handler
//You must copy dbconnection.tol.seed as dbconnection.tol and edit it
//////////////////////////////////////////////////////////////////////////////
Include("dbconnection.tol");

//Random seed setting
Real PutRandomSeed(2100110139);
Real rndSeed = GetRandomSeed(0);
WriteLn("Current Random Seed = "<<rndSeed);

//////////////////////////////////////////////////////////////////////////////
//NOTA IMPORTANTE: Los comentarios dentro de un NameBlock precedidos de ## 
//significan que el método o miembro a continuación es obligatorio para 
//ser usado por la API BsrHLM, debe estar presente con el mismo nombre, tipo y 
//estructura interna. Por supuesto el contenido sí puede cambiar para 
//adaptarse al caso del modelo analizado.
//Los precedidos de un sólo # son recomendables pero no obligatorios y se 
//puede cambiar el nombre sin problemas pero respetando la acción si es 
//posible.
//Los miembros y métodos de un NameBlock que empiezan con _ son privados y 
//no se pueden acceder desde fuera, a noser que empiecen por _. en cuyo caso
//son de sólo lectura, es decir, se pueden consultar pero no modificar desde
//fuera del NameBlock
//////////////////////////////////////////////////////////////////////////////

Real BysMcmc::Bsr::DynHlm::DBApi::doQueryTrace := False;


//Se activa la base de datos de modelos BsrHlm
Real DBConnection::BsrHlm::Activate(0);

//////////////////////////////////////////////////////////////////////////////
WriteLn("Creando en la base de datos el área documental");
//////////////////////////////////////////////////////////////////////////////

//Identificador del objetivo modelo.
//Debería distinguir de forma inequívocamente el proyecto, el concepto que
//se quiere analizar y otros detalles como el fechado o intervalo al que se 
//refiere.
//Se recomienda usar el mismo nombre del fichero y dejarlo fijo.
Text id_model =  "Tdt.Test.Delta";

//Descripción del objetivo modelo
//Sin extenderse demasiado debe dejar muy claro l oque pretende el modelo
Text ds_model = "Modelo generado automáticamente por simulación para el "
"chequeo de la implementación de la simulación de funciones de transferencia "
"no lineales (delta), sobre un solo output y una sola función de "
"transferencia, sin omitidos ni parte ARIMA";

//Identificador de la sesión o implementación
//Es recomendable cambiarla cada vez que se produzca un cambio no trivial en 
//la definición y que siga algún tipo de orden, cronológico, alfabético u
//ordinal que permita a simple vista saber cual es anterior a otra.
//Si una sesión va asociada a un único modelo es prudente que el nombre lo 
//recoja para evitar confusiones. En este caso se infija con A3Aud7CH como
//abreviatura del nombre del modelo.
Text id_session =  "SES_Tdt.Test.Delta."+IntText(rndSeed);

//Esta orden desbloquea todas las sesiones relativas a este modelo
Real BysMcmc::Bsr::DynHlm::DBApi::Mod.SetBlocked(
  DBConnection::BsrHlm::_.defaultDB, id_model, 0);
//Esta orden borra todas las sesiones relativas a este modelo
Real BysMcmc::Bsr::DynHlm::DBApi::Mod.Delete(
  DBConnection::BsrHlm::_.defaultDB, id_model);


//Descripción de la sesión o implementación
//Se recomienda introducir un comentario sobre los cambios introducidos con
//respecto a la última sesión
Text ds_session =  "Modelo de un año en diario con función de transferencia "
" omega_1/(1-delta_1*B) y un input de nivel";

//Autores
//Deben firmar al menos los que han hecho los cambios de la presente sesión,
//preferentemente con su email separados por ;
Text ds_authors  = 
  "vdebuen@tol-project.org;";


Real BysMcmc::Bsr::DynHlm::DBApi::Mod.Create(
  DBConnection::BsrHlm::_.defaultDB, id_model,   ds_model);
Real BysMcmc::Bsr::DynHlm::DBApi::Ses.Create(
  DBConnection::BsrHlm::_.defaultDB, id_session, ds_session, ds_authors);
Real BysMcmc::Bsr::DynHlm::DBApi::ModSes.Create(
  DBConnection::BsrHlm::_.defaultDB, id_model, id_session);

//////////////////////////////////////////////////////////////////////////////
WriteLn("Creando en la base de datos los niveles de la jerarquía");
//////////////////////////////////////////////////////////////////////////////
Real {BysMcmc::Bsr::DynHlm::DBApi::ModSes.SetLevels(
  DBConnection::BsrHlm::_.defaultDB, id_model, id_session,
  Real maxLatLevel = 0,       //Máximo nivel de latencia
  Real hasPrior    = False,   //Indica si hay nodo a priori
  Real hasMixture  = False)}; //Indica si hay restricciones que afectan a
                              //variables de distintos nodos

//////////////////////////////////////////////////////////////////////////////
WriteLn("Creando en la base de datos los nodos observacionales");
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
NameBlock GetTimeInterval(Date fst, Date lst)
//////////////////////////////////////////////////////////////////////////////
{[[
  //Estas fechas se usan para ocultar datos de output y poder hacer 
  //previsiones extramuestrales
  Date _.firstDate = fst;
  Date _.lastDate  = lst;

  Serie sub.fill(Serie ser, Real defaultValue, Date fst, Date lst) 
  { 
    Serie def = SubSer(CalInd(Dating(ser),Dating(ser))*defaultValue,fst,lst);
    Serie ser_ = SubSer(ser,fst,lst);
    Real AvrS(ser_);
    def << ser_ >> def
  };
  Serie sub(Serie ser, Real defaultValue) 
  { 
    sub.fill(ser,defaultValue,_.firstDate,_.lastDate)
  };
  Serie sub.move(Serie ser, Real defaultValue, Real fstLag, Real lstLag)
  {
    Date fst.lagged = Succ(_.firstDate,Dating(ser),fstLag);
    Date lst.lagged = Succ(_.lastDate, Dating(ser),lstLag);
    sub.fill(ser,defaultValue,fst.lagged,lst.lagged)
  }
]]};

//////////////////////////////////////////////////////////////////////////////
//Crea el manejador de series de un nodo observacional concreto
//En este caso sólo hay un nodo observacional 
  NameBlock node.series.handler(Real nu_node)
//////////////////////////////////////////////////////////////////////////////
{[[
//Real nu_node = 1;
  Text te_node = FormatReal(nu_node,"%04.0lf");
  //##Nombre del nodo
  Text _.id_node = "Obs.Node_"+te_node;
  //##Descripción del nodo
  Text _.description = "Nodo observacional número "+te_node;

  //Para recorte de series input y output
  NameBlock time.interval = GetTimeInterval(y2008m01d01, y2008m12d31);

  //Generación de inputs
  NameBlock gen.input(Real minCoef, Real maxCoef, Serie shape)
  {[[
    Serie  _.input  = time.interval::sub(shape,0);
    Real   _.coef   = Rand(minCoef, maxCoef);
    Serie  _.effect = _.coef * _.input;
    Matrix _.param.omega  = Col(_.coef);
    Matrix _.param.delta  = Rand(0,1,0,0);
    Matrix _.param.denIni = Rand(0,1,0,0)
  ]]};

  //Generación de la funciones de transferencia
  NameBlock gen.transFun(Real minCoef, Real maxCoef, Serie shape,
                         Real omega_deg, Real delta_deg)
  {[[
    Real _.minCoef = minCoef;
    Real _.maxCoef = maxCoef;
    Real  _.omega_deg = omega_deg;
  //ARMS se cae sin más con delta de grado 2
    Real  _.delta_deg = delta_deg;
  //Real  _.delta_deg = 1;
    Polyn rand.omega(Real unused)
    {
      SetSum(For(0, _.omega_deg, Polyn(Real deg)
      {
        Rand(_.minCoef, _.maxCoef)*B^deg
      }))
    };
    //Generates arbitrary stationary roots
    Polyn rand.delta.anyRoots(Real unused)
    {
      RandStationary(_.delta_deg)
    };
    //Generates just real positive roots
    Polyn rand.delta.posRoots(Real unused)
    {
      Case(
        _.delta_deg==0,  1,
        _.delta_deg==1, (1-Rand(0.5,0.99)*B),
        _.delta_deg==2, (1-Rand(0.1,0.6)*B)*(1-Rand(0.7,0.99)*B) )
    };
    Real _.usePosRoots = False;
    Polyn rand.delta(Real unused)
    {
      If(_.usePosRoots, rand.delta.posRoots(0), rand.delta.anyRoots(0))
    };
    Ratio rand.transFun(Real unused)
    {
      rand.omega(0) / rand.delta(0)
    };
    Polyn _.omega = rand.omega(0);
    Polyn _.delta = rand.delta(0);
    Ratio _.transFun = _.omega / _.delta;
    Serie _.input = time.interval::sub.move(shape,0,-_.omega_deg,0);

    Serie  _inp0 = time.interval::sub.move(shape,0,-100*CountS(_.input),0);
    Serie  _eff0 = DifEq(_.transFun, _inp0);
    Serie _.denIni = SubSer(_eff0, 
                            time.interval::_.firstDate-_.delta_deg, 
                            time.interval::_.firstDate-1);  
/*
    Serie _.denIni = SubSer(Rand(MinS(_.input),MaxS(_.input),Dating(shape)), 
                                 time.interval::_.firstDate-_.delta_deg, 
                                 time.interval::_.firstDate-1);  
*/
    Serie  _.effect = DifEq(_.transFun, _.input, _.denIni);
    Matrix _.param.omega  = PolMat(_.omega, _.omega_deg+1, 1);
    Matrix _.param.delta  = PolMat(F*(1-_.delta), _.delta_deg, 1);
    Matrix _.param.denIni = Tra(SerMat(_.denIni))
  ]]};
  //Generación de las series del modelo 
  NameBlock real.data = 
  [[
    Set transFun = 
    [[
      NameBlock constante = gen.input(5,10,CalInd(C,C));
      NameBlock lunes     = gen.input(10,15,CalInd(WD(1),C));
      NameBlock priMes    = gen.transFun(15,20,CalInd(D(1),C),0,2)
    ]];

    Set input = EvalSet(transFun,Serie(NameBlock tf)
    {
      Eval(Name(tf)+"=tf::_.input")
    });

    Serie filter = SetSum(EvalSet(transFun,Serie(NameBlock tf)
    {
      tf::_.effect
    }));

    Real  sigma = Rand(0.8,1.2);
    Serie residuals = time.interval::sub(Gaussian(0,sigma,C),0);
    Serie noise = residuals;

    Serie output = noise + filter;
    Matrix param = BinGroup("<<", EvalSet(transFun,Matrix(NameBlock tf)
    {
      tf::_.param.omega
    })) <<
    Col(sigma^2) << 
    BinGroup("<<", EvalSet(transFun,Matrix(NameBlock tf)
    {
      tf::_.param.delta << 
      tf::_.param.denIni
    }))
  ]];
  
  //#Contiene todas las series input y output con nombres únicos dentro
  //de cada nodo.
  Set _.series = [[real.data::output ]] << real.data::input;
  //#Se comprueba la unicidad de nombres y se indexa para acelerar 
  //búsquedas
  Real _check_unique = SetIndexByName(_.series);

  //##Devuelve una serie del nodo dado un identificador único
  Serie GetSerie(Text id_serie)
  {
    _.series[id_serie]
  };

  //##Información adicional del modelo sobre el output
  NameBlock _.output = 
  {[[
    //##Nombre con el que reconoce la serie en la base de datos
    Text _.name = "output";
    //##Serie output
    Serie _.serie = _.series::output;
    //##Número de sigmas para la distribución a priori de los omitidos
    //se multiplicará por la desviación típica muestral de la serie.
    //La media a priori será la de la propia serie.
    Real _.mis_pri_sig_fac = 3;
    //##Valor mínimo a priori para los omitidos
    Real _.mis_pri_min     = -1/0;
    //##Valor máximo a priori para los omitidos
    Real _.mis_pri_max     = +1/0;
    //##Fecha inicial de estimación del nodo
    Date _.firstDate = time.interval::_.firstDate;
    //##Fecha final de estimación del nodo
    Date _.lastDate = time.interval::_.lastDate;
    //##Parte ARIMA asociada
    Set _.arima = Copy(Empty)
  ]]};

  //#Returns true if differenced serie is not null
  Real notNullDiff(Serie ser)
  {
    Polyn _difference = ARIMAGetDIF(_.output::_.arima);
    Serie difSer = _difference:ser;
    Not(And(Eq(MaxS(difSer),0), Eq(MinS(difSer),0)))
  };

  Real _.useRealDataAsInitValue = False;
  //##Información adicional del modelo sobre los inputs
  //Cada elemento es un NameBlock cuyo nombre será el identificador en
  //la base de datos de BsrHlm y es obligatorio que se llame igual que
  //la correspondiente serie input
  Set _.input = { SetOfNameBlock( 
  NameBlock constante = [[
    //##Serie input
    //Los días de fiesta la gente suele salir de casa más y ver menos tele
    Serie _.serie = _.series::constante;
    //##Si es falso no se usará este input
    Real _.enabled = notNullDiff(_.serie);
    //##Número de sigmas para la distribución a priori de los omitidos
    Real _.mis_pri_sig_fac =  5;
    //##Valor mínimo a priori para los omitidos
    Real _.mis_pri_min     =  -1/0;
    //##Valor máximo a priori para los omitidos
    Real _.mis_pri_max     =  +1/0;
    //##Valor inicial del parámetro
    Real _.initValue       =  If(!_.useRealDataAsInitValue,0,
                                 real.data::transFun::constante::_.coef);
    //##Valor mínimo a priori del parámetro
    Real _.minimum         = -1/0;
    //##Valor máximo a priori del parámetro
    Real _.maximum         = +1/0
  ]], 
  NameBlock lunes = [[
    //##Serie input
    //Los días de fiesta la gente suele salir de casa más y ver menos tele
    Serie _.serie = _.series::lunes;
    //##Si es falso no se usará este input
    Real _.enabled =notNullDiff(_.serie);
    //##Número de sigmas para la distribución a priori de los omitidos
    Real _.mis_pri_sig_fac =  5;
    //##Valor mínimo a priori para los omitidos
    Real _.mis_pri_min     =  -1/0;
    //##Valor máximo a priori para los omitidos
    Real _.mis_pri_max     =  +1/0;
    //##Valor inicial del parámetro
    Real _.initValue       =  If(!_.useRealDataAsInitValue,0,
                                 real.data::transFun::lunes::_.coef);
    //##Valor mínimo a priori del parámetro
    Real _.minimum         = -1/0;
    //##Valor máximo a priori del parámetro
    Real _.maximum         = +1/0
  ]], 
  NameBlock priMes = [[
    //##Serie input
    //Los días de fiesta la gente suele salir de casa más y ver menos tele
    Serie _.serie = _.series::priMes;
    //##Si es falso no se usará este input
    Real _.enabled = notNullDiff(_.serie);
    //#Función de transferencia.
    Ratio _.transferFunction = If(!_.useRealDataAsInitValue,
      real.data::transFun::priMes::rand.transFun(0), 
      real.data::transFun::priMes::_.transFun);
    //##Número de sigmas para la distribución a priori de los omitidos
    Real _.mis_pri_sig_fac =  5;
    //##Valor mínimo a priori para los omitidos
    Real _.mis_pri_min     =  -1/0;
    //##Valor máximo a priori para los omitidos
    Real _.mis_pri_max     =  +1/0;
    //##Valor inicial del parámetro
    Real _.initValue       =  If(!_.useRealDataAsInitValue,0,
      Coef(real.data::transFun::priMes::_.omega,0));
    //##Valor mínimo a priori del parámetro
    Real _.minimum         = -1/0;
    //##Valor máximo a priori del parámetro
    Real _.maximum         = +1/0
  ]] )};

  //Se comprueba de nuevo la unicidad de los manejadores de los input
  Real _checkUniqueInput = SetIndexByName(_.input)

]]};

//////////////////////////////////////////////////////////////////////////////
//Manejador de series del modelo
  NameBlock series.handler=BysMcmc::Bsr::DynHlm::DBApi::CreateSeriesHandler( 
//////////////////////////////////////////////////////////////////////////////
For(1, 1, NameBlock(Real ch)
{ 
  WriteLn("[series.handler] Creando manejador de series del nodo "+
          IntText(ch));
  NameBlock aux = node.series.handler(ch);
  Eval(aux::_.id_node+"=aux")
})); 

//////////////////////////////////////////////////////////////////////////////
WriteLn("Creando en la base de datos los nodos observacionales");
//////////////////////////////////////////////////////////////////////////////
Real BysMcmc::Bsr::DynHlm::DBApi::ModSes.Obs.CreateAll(
  DBConnection::BsrHlm::_.defaultDB, id_model, id_session,
  series.handler::_.obs.node);


NameBlock config = BysMcmc::BuildFullConfig([[
//MCMC dimensions
  Real mcmc.burnin        =  600; 
  Real mcmc.sampleLength  =  2000;
  Real mcmc.cacheLength   =  100;
//MLS step configuration
  Text mls.method  = BysMcmc::Options::Mls.Method::FunnelGibbs;
  Real mls.maxIter = 10;
  Real mls.tolerance = 0.01;
  Real mls.FunnelGibbs.sigmaFactor = 0.01;

  Code bsr.scalarSampler.nonLinBlock=BysMcmc::Options::Scalar.Sampler::Slice;

//Generic flags
  Real do.resume          =  False;
  Real do.report          =  True;
  Real do.eval            =  True;
  Real do.linear.effects  =  True
]]);

/* * /
NameBlock modelDef = BysMcmc::Bsr::DynHlm::DBApi::LoadModelDef
(
  DBConnection::BsrHlm::_.defaultDB,
  id_model,
  id_session,
  Ois.DefRoot+"HlmBsrTest/",
  series.handler
);
Text ascii = BysMcmc::Bsr::Import::Write(modelDef);
Set nonLinFilter = 
  If(!FunctionExist("Set","modelDef::Get.NonLinFilter"), Empty, 
    modelDef::Get.NonLinFilter(0));
Set parsed = BSR.Parse(ascii);
NameBlock gibbs = If(!Card(nonLinFilter),
{
  WriteLn("[BSR] Using Basic Master");
  BysMcmc::Bsr::Gibbs::BasicMaster(parsed, config)
},
{
  WriteLn("[BSR] Using Non Linear Filter Extended Master");
  BysMcmc::Bsr::Gibbs::NonLinMaster(parsed, nonLinFilter, config)
});	
/* */

/* */
//////////////////////////////////////////////////////////////////////////////
//Estimación del modelo con el sistema Bsr::DynHlm
//////////////////////////////////////////////////////////////////////////////
Set bsr.estim = {BysMcmc::Bsr::DynHlm::DBApi::Estim
(
  DBConnection::BsrHlm::_.defaultDB,
  id_model,
  id_session,
  Ois.DefRoot+"HlmBsrTest/",
  series.handler,
  config
)};

/* */
//////////////////////////////////////////////////////////////////////////////
Set compare_forecast = 
//////////////////////////////////////////////////////////////////////////////
For(1,Card(series.handler::_.obs.node),Set(Real nu_node)
{
  NameBlock node = (series.handler::_.obs.node)[nu_node];
  NameBlock known = node::real.data;
  Set estim = (bsr.estim::eval.average)[nu_node];
  Set aux = [[
    //Compara los valores de los parámetros reales y estimados
    Matrix param.cmp = known::param | Tra(bsr.estim::param.average);
    //Filtro real
    Serie Filter = known::filter, 
    //Filtro estimado
    Serie Filter.Estim = estim::serFilter.full;
    //Noise real
    Serie Noise = known::noise, 
    //Noise estimado
    Serie Noise.Estim = estim::serNoise;
    //Output real
    Serie Output = known::output, 
    //Previsión
    Serie Forecast = estim::serForecast;
    //Error en términos absolutos
    Serie Error = Output-Forecast;
    //Error relativo medio
    Real Mape = AvrS(Abs((Output - Forecast)/Output))
  ]];
  Eval(node::_.id_node+"=aux")
});


/* */ 
Real DBConnection::BsrHlm::Close(0);

