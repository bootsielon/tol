//////////////////////////////////////////////////////////////////////////////
// FILE   : _bysMcmc.tol
// PURPOSE: Generic MonteCarlo Markov Chain methods
//////////////////////////////////////////////////////////////////////////////

Set Include("_structs.tol");


//////////////////////////////////////////////////////////////////////////////
NameBlock BysMcmc =
//////////////////////////////////////////////////////////////////////////////
[[
  //read only autodoc
  Text _.autodoc.description =
  "Generic MonteCarlo Markov Chain methods and some applications.";

  //private implementation
  Set _build     = Include("_build.tol");
  Set _cmsg      = Include("_cmsgs.tol");
  Set _blkDef    = Include("_defineBlock.tol");
  Set _bsr       = Include("bsr/_bsr.tol");
  Set _inference = Include("_inference.tol");

  //Exporting public methods and members
  NameBlock _.cmsg;
  Code      DefineBlock;
  Code      BuildCycler;
  Code      Get.Recover;
  Code      RecoveAndReport;
  NameBlock Bsr;
  NameBlock Inference;

  //Options used over all BysMcmc related components
  NameBlock Options =
  [[
    //When model has high non linear behaviour a preliminar Maximum Likelihood Step
    //(MLS) is needed to start Gibbs sampler in a feasible point with non null
    //density
    NameBlock Mls.Method =
    [[
      //Does no MLS step
      Text None = "None",
      //Does funnel-Gibbs method: Gibbs steps with reduced variance to increase
      //convergence
      Text FunnelGibbs = "FunnelGibbs"
    ]];
    //Scalar samplers draws a univariant distribution given the logarithm of
    //density function and a domain interval
    //The API of a scalar sampler  is given by a function like this
    //  Real (Code logDens, Real x0, Real x1)
    NameBlock Scalar.Sampler = 
    [[
      Real Arms(Code logDens, Real x.min, Real x.max, Real x.0)
      {
        ARMS(logDens, x.min, x.max, x.0)
      };
      Real Slice(Code logDens, Real x.min, Real x.max, Real x.0)
      {
        MatDat(SliceSampler1D(logDens, x.min, x.max, x.0),1,1)
      }
    ]];
    NameBlock Arima.Filter =
    [[
      Text FastChol = "FastChol",
      Text DifEq    = "DifEq"
    ]]
  ]];

  //Configuration default values over all BysMcmc related components
  Set _config =
  [[
  //MCMC dimensions
    //The final number realizations that will remain after burnin
    Real mcmc.sampleLength = 2000;
    //The frequency of simulation notifying and chain cache updating
    Real mcmc.cacheLength = 100;
    //The number of first realizations that will be skiped at inference and 
    //diagnostic time
    Real mcmc.burnin = 100;
    //Only one of each this number of simulations will be selected for 
    //inference and diagnostic
    Real mcmc.thinning = 1; //thinningg
    //Maximum of time in seconds dedicated to simulation
    //Process will be stoped after mcmc.sampleLength + mcmc.burnin 
    //simulations or mcmc.maxTime seconds will be elapsed
    Real mcmc.maxTime = 1/0;
  //MLS step configuration
    Text mls.method  = Options::Mls.Method::None;
    Real mls.maxIter = 100;
    Real mls.tolerance = 0.01;
    Real mls.FunnelGibbs.sigmaFactor = 0.01;
  //Basic master configuration
    //Try order for given by user solution to start MCMC
    Real bsr.iniVal.try.givenByUser = 1;
    //Try order for zero solution to start MCMC
    Real bsr.iniVal.try.zero = 2;
    //Try order for constrained minimum norm solution to start MCMC
    Real bsr.iniVal.try.cnstrMinNorm = 3;
    //Try order for constrained max likelihood solution to start MCMC
    Real bsr.iniVal.try.cnstrMLE = 4;
    //If solution error is great than this value a warning will be shown
    Real bsr.cholesky.epsilon = 1.E-13;
    //The notifying frequency of Cholesky warning
    Real bsr.cholesky.warningFreq = 100;
    //The number of burnin realizations in Gibbs drawing of truncated 
    //multinormal
    Real bsr.truncMNormal.gibbsNumIter = 0;
    //Scalar sampler used in ARMA block of basic BSR can be a member of 
    //BysMcmc::Options::Scalar.Sampler or an API equivalent function
    Code bsr.scalarSampler.armaBlock = Options::Scalar.Sampler::Slice;
    //Scalar sampler used in ARMA block of basic BSR can be a member of 
    //BysMcmc::Options::Scalar.Sampler or an API equivalent function
    Code bsr.scalarSampler.nonLinBlock = Options::Scalar.Sampler::Slice;
    //Arima filter method
    Text bsr.arimaFilter = Options::Arima.Filter::FastChol;
  //CODA and other diagnostic report configuration
    //The quantile to be estimated in Raftery test
    Real report.raftery.diag.q = 0.025;
    //The desired margin of error of the estimate in Raftery test
    Real report.raftery.diag.r = 0.007;  
    //The probability of obtaining an estimate in the interval (q-r,q+r) in 
    //Raftery test
    Real report.raftery.diag.s = 0.950;  
    //Precision required for estimate of time to convergence in Raftery test
    Real report.raftery.diag.eps = 0.001;
    //Lag of AutoCorrelation Function 
    Real report.acf.lag= 20;
    //Number of divisions in histograms
    Real report.histogram.parts = 100;
    //Number of divisions in kernel density aproximations
    Real report.kerDens.points = 0;
  //Generic flags
    //If positive then is the number of existent realizations to be recovered 
    //from disk
    //If negative then is the number of last existent realization to be
    //skyped
    //If zero then no resuming will be made and a new Markov chain will be
    //generated
    Real do.resume = 0;
    //Enables or disables CODA and other diagnostic reports
    Real do.report = True;
    //Enables or disables in-sample evaluation of forecasting, filter, noise, 
    //residuals, ...
    Real do.eval = True;
    //Enables or disables in-sample evaluation of individual linear effects
    Real do.linear.effects = True;
    //Enables or disables saving full results of DBApi::Estim
    Real do.save.DBApi.Estim.Oza = True
  ]];

  NameBlock Config = 
  {
    Real SetIndexByName(_config);
    SetToNameBlock(_config)
  };

  //Searches a parameter in the user defined configuration NameBlock and, if
  //not exists returns default value of BsyMcmc::Config
  Anything GetCfgVal(NameBlock config, Text member)
  {
    StdLib::GetConfigValue(config,member,Eval("BysMcmc::Config::"+member))
  };
  //Takes a NameBlock with some config pararameter configurations and adds
  //non specified members with default values
  NameBlock BuildFullConfig(NameBlock config)
  {
    Set _cfg = EvalSet(_config, Anything(Anything member)
    {
      GetCfgVal(config, Name(member))
    });
    Real SetIndexByName(_cfg);
    SetToNameBlock(_cfg)
  }

]];
  




