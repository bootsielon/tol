/////////////////////////////////////////////////////////////////////////////
// LIBRARY: StdtLib (Standard Library of TOL)
// FILE: _build.tol
// PURPOSE: Declares Class BysMcmc::Cycler method BysMcmc::BuildCycler
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Cycler =
"This class is able to generate a Markov Chain of a model "
"by cycling calls of a given model sampler and gives a set of tools to " 
"make Bayesian Inference about it.\n "
"Arguments:\n"
"  MasterSampler modelSampler is a handler of the model to be simulated\n"
"  Config config has user configuration parameters\n"
"  Notifier notifier is an event tracing handler\n";
Class Cycler
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::MasterSampler _.sampler;
  BysMcmc::Notifier      _.notifier;
  BysMcmc::Config        _.config;

  //Stores the sampler name
  Text _.name = "";
  //Puts the Markov Chain path relative to sampler path
  Text _.path = "";
  //The number of variables of Markov Chain
  Real _.n = ?;
  //Timer member that can be externally consulted 
  Real _.time = ?;
  Real _mcmc.maxTime = ?;
  //Setting NameBlock description
  Text _.autodoc.description = "";

  Set auxInfo = Copy(Empty);

  //--------------------------------------------------------------------------
  // Configuration members
  //--------------------------------------------------------------------------
  //The number of simulations cached in RAM before to disc writing
  Real cacheLength_ = ?;
  //If resume is true and there was old simulations in _.path, new ones will 
  //be added at the end. In other case old simulations will be lost.
  Real resume_ = ?;
  //Bayesian inference configuration
  Set bysInf_ = Copy(Empty);

  //--------------------------------------------------------------------------
  // Public methods
  //--------------------------------------------------------------------------

  Real define(Real unused)
  {
    //Stores the sampler name
    Text _.name := _.sampler::get.name(0)+"."+_.sampler::get.session(0);
    //Puts the Markov Chain path relative to sampler path
    Text _.path := Replace(_.sampler::get.path(0)+_.name+".mcmc.bbm","\\","/");
    //The number of variables of Markov Chain
    Real _.n := Card(_.sampler::get.colNames(0));
    //Timer member that can be externally consulted 
    Real _.time := 0;
    Real _mcmc.maxTime := _.config::mcmc.maxTime;
    //Setting NameBlock description
    Text _.autodoc.description :="MCMC cycling builder for model "+_.name;

    //--------------------------------------------------------------------------
    // Configuration members
    //--------------------------------------------------------------------------
    //The number of simulations cached in RAM before to disc writing
    Real cacheLength_ := _.config::mcmc.cacheLength;
    //If resume is true and there was old simulations in _.path, new ones will 
    //be added at the end. In other case old simulations will be lost.
    Real resume_ := _.config::do.resume;
    //Bayesian inference configuration
    Set bysInf_ := {BysInf.Report.Config
    (
      Real raftery.diag.q   = _.config::report.raftery.diag.q,
      Real raftery.diag.r   = _.config::report.raftery.diag.r,
      Real raftery.diag.s   = _.config::report.raftery.diag.s,
      Real raftery.diag.eps = _.config::report.raftery.diag.eps,
      Real acf.lag          = _.config::report.acf.lag,
      Real histogram.parts  = _.config::report.histogram.parts,
      Real kerDens.points   = _.config::report.kerDens.points
    )};
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.initialize =
  "Initializes the Markov Chain";
  Real initialize(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.notifier::initializing(_.n, _.path);
    Real _.sampler::initialize(0);
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.resume =
  "Reloads n=resume_ saved simulations if possible";
  Real resume(Real sampleLength)
  ////////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[Cycler::resume] ";
    If(resume_==0, 
    {
      Real ok.remove = OSFilRemove(_.path);
      Real If(!ok.remove, 
      {
        WriteLn("Please, change session identifier or clean old file and retray it", "E");
        Stop
      });
      0
    },
    {
      Real WriteLn(_MID+"Trying to resume MCMC from "<<_.path);
      If(!FileExist(_.path),
      {
        Real WriteLn(_MID+"Cannot find MCMC at "<<_.path+" to resume","W");
        0
      },
      {
        Set old.mcmc.dim = MatReadDimensions(_.path);
        Real m = old.mcmc.dim::Rows;
        Real n = old.mcmc.dim::Columns;
        Case(
        Not(m),
        {
          Real WriteLn(_MID+"Empty MCMC at "<<_.path+" to resume","W");
          Real OSFilRemove(_.path);
          0
        },
        n==_.n, 
        {
          Real m_ = Case(
            resume_>0, Min(m,resume_),
            resume_<0, Max(0,m+resume_) );
          If(m_==0,
          {
            WriteLn(_MID+"There are not enougth old simulations to resume");
            Real OSFilRemove(_.path);
            0
          },
          {
            Real WriteLn(_MID+"resuming "<<m_+" old simulations");
            Matrix resumed = If(m_==m,
            {
              MatReadFile(_.path)
            },
            {
              Real WriteLn(_MID+"Removing last "<<Real(m-m_)+" old simulations");
              Matrix aux = MatReadRows(_.path,1,m_,1);
              Matrix MatWriteFile(_.path, aux);
              aux
            });
            Matrix lastRow = Sub(resumed,m_,1,1,_.n);
          //WriteLn("TRACE "+_MID+"lastRow="<<lastRow);
            Real _.sampler::setStore(lastRow);
            m_
          })
        },
        1==1,
        {
          Real WriteLn(_MID+"Cannot resume due to old MCMC saved on "+
            _.path+" has "+IntText(n)+" columns instead "
            "of current nummber of parameters "+IntText(_.n)+".\n"
            "Old MCMC will be removed","W");
          Real ok.remove = OSFilRemove(_.path);
          Real If(!ok.remove, 
          {
            WriteLn("Please, change session identifier or clean old file and retray it", "E");
            Stop
          });
          0
        }) 
      })
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.generate =
  "Generates and stores a Markov Chain with sampleLength simulations and "
  "return the number of successfully saved ones";
  Real generate(Real sampleLength)
  ////////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[Cycler::generate] ";
    Real WriteLn(_MID+_.name+
      "\n Storing MCMC in file  : "<<_.path+
      "\n Number of variables   : "<<_.n+
      "\n Number of simulations : "<<sampleLength+
      "\n Cache length          : "<<cacheLength_+
      "\n Resume                : "<<resume_+
      If(_mcmc.maxTime<1/0,
      "\n MaxTime               : "<<_mcmc.maxTime+" seconds",""));
  //Ensures path is all right 
    Real OSDirMake(GetFilePath(_.path));
    Real numDec = 1+Ceil(Log(sampleLength)/Log(10));
    Text numIterFmt = "% "+IntText(numDec)+".0lf";
  //Resume or clean old simulations
    Real savedSimulations = resume(sampleLength);
    //Cache matrix to store up to cacheLength rows before to append it to the
    //BBM file
    Matrix cache = Rand(0,_.n,0,0);
  //WriteLn("TRACE "+_MID+"1.1 cache("<<Rows(cache)+"x"<<Columns(cache)+")");
    //Initializes the timer
    Real t0 = Copy(Time);
    Real t1 = Copy(Time);
    Real _.notifier::simulating(0, 0);
    Real numErr0 = Copy(NError);
    Real numSim = savedSimulations;
  //WriteLn("TRACE "+_MID+"sampleLength="<<sampleLength);
  //WriteLn("TRACE "+_MID+"savedSimulations="<<savedSimulations);
  //WriteLn("TRACE "+_MID+"numSim="<<numSim);
    Real end = GE(numSim,sampleLength);
  //WriteLn("TRACE "+_MID+"end="<<end);
    While(!end,
    {
      Real numSim := numSim+1;
    //WriteLn("TRACE "+_MID+"2 numSim="<<numSim);
      Real doCache = Or(cacheLength_==1,numSim%cacheLength_==1);
    //WriteLn("TRACE "+_MID+"3");
      Real If(doCache,
      {
        If(cacheLength_>1,
        {
          Write(" Simulating iterations "+
            FormatReal(numSim,numIterFmt)+"-"+
            FormatReal(numSim+cacheLength_-1,numIterFmt))
        },
        {
          Write(_MID+"Simulating iteration "+ IntText(numSim))
        });
        If(And(cacheLength_>1,!Rows(cache)), WriteLn(" ... "),
        {
          Real donePercent = 100*numSim / sampleLength;
          Real t2 = Copy(Time);
          Real _.time := (t2-t1)/cacheLength_;
          Real remain = _.time * (sampleLength-numSim);
          WriteLn(" [done "+FormatReal(donePercent,"% 6.2lf")+"%]"+
                  " [time/sim:"+FormatReal(_.time,"% 9.6lf")+" s]"+
                  " [remaining "+FormatReal(remain,"% 6.0lf")+" s]");
          Real _.notifier::simulating(numSim-1, _.time);
          Real t1 := t2
        });
        1
      });
    //WriteLn("TRACE "+_MID+"4");
      VMatrix draw_ = _.sampler::draw(numSim);
      Matrix  draw  = VMat2Mat(draw_);
    //WriteLn("TRACE "+_MID+"5 draw("<<Rows(draw)+"x"<<Columns(draw)+")");
    //WriteLn("TRACE "+_MID+"6 cache("<<Rows(cache)+"x"<<Columns(cache)+")");
      Matrix cache := cache << Tra(draw);
    //WriteLn("TRACE "+_MID+"7");
      Real If(doCache,
      {
      //WriteLn("TRACE "+_MID+"9");
        Matrix Do MatAppendFile(_.path, cache);
        Real savedSimulations := numSim;
        Matrix cache := Rand(0,_.n,0,0);
        1
      });
      Real Case(
      GE(numSim,sampleLength),
      {
        WriteLn("Simulation process has ended succesfully");
        Real end := True
      },
      GE(Time-t0,_mcmc.maxTime),
      {
        WriteLn("Maximum time has been elapsed and process will be stoped",
                "W");
        Real end := True
      },
      GT(NError,numErr0), 
      {
      //WriteLn("TRACE "+_MID+"10");
        Real CMsg::Coded::show(BysMcmc::_.cmsg::_.cannotContinueSimulation,
        [[
          _MID,
          Real (NError-numErr0)
        ]]);
        Real end := True
      });
      1
    //WriteLn("TRACE "+_MID+"8");
    });
  //WriteLn("TRACE "+_MID+"11");
    Matrix Do MatAppendFile(_.path, cache);
  //WriteLn("TRACE "+_MID+"12");
    Real savedSimulations := numSim;
    Real _.time := (Time - t0)/numSim;
    WriteLn(" [time by simulation:"<<_.time+"]");
    Real _.notifier::simulating(numSim, _.time);
    //WriteLn("TRACE "+_MID+"1");
    1
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.loadFullMcmc =
  "Loads the full stored Markov Chain previouslu generated.";
  Matrix loadFullMcmc(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    MatReadFile(_.path)
  };
  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.loadMcmc =
  "Loads the stored Markov Chain generated by method generate skiping "
  "first burnin rows and selecting one of each thinning ones.";
  Matrix loadMcmc(Real burnin, Real length, Real thinning)
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Inference::loadMcmc(_.path, burnin, length, thinning)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.report =
  "Returns a report about Bayesian Inference over the Markov Chain, "
  "including some CODA items.";
  Set report(Real burnin, Real length, Real thinning)
  ////////////////////////////////////////////////////////////////////////////
  {
    BysMcmc::Inference::loadAndReport(
      _.path, burnin, length, thinning, 
      _.name, _.sampler::get.colNames(0), bysInf_)
  }

};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.EstimParsed =
"Estimates a BSR model by Gibbs method\n"+
"Argument `parsed` must be defined as the result of calling function "
"BSR.Parse\n";

Set EstimParsed(BSR.ModelDef parsed, 
                Set nonLinFilter,
                Config config,
                Notifier notifier)
//////////////////////////////////////////////////////////////////////////////
{
//WriteLn("TRACE EstimParsed Card(nonLinFilter) = "<<Card(nonLinFilter));
  BysMcmc::MasterSampler sampler = If(!Card(nonLinFilter),
  {
    WriteLn("[BSR] Using Basic Master");
    BysMcmc::Bsr::Gibbs::BasicMaster(parsed, config)
  },
  {
    WriteLn("[BSR] Using Non Linear Filter Extended Master");
    BysMcmc::Bsr::Gibbs::NonLinMaster(parsed, nonLinFilter, config)
  });	
  BysMcmc::Cycler cycler = [[ Real _unused = 0 ]];
  Real cycler::define(sampler, notifier, config);
  Real StoreRecover(cycler);

  Real cycler::initialize(0);
  Real cycler::generate(config::mcmc.burnin+config::mcmc.sampleLength); 

  Real notifier::reporting(0);
  Set estim = If(Not(config::do.report),
  {
    [[
      parsed,
      sampler,  
      cycler
    ]]
  },
  {
    Set report = cycler::report(config::mcmc.burnin, config::mcmc.sampleLength,config::mcmc.thinning);
    Matrix param.average = 
    {
      Tra(SetMat(Extract(report::coda.summary, 2)))
    };
    If(!(config::do.eval),
    {
      [[
        parsed,
        sampler, 
        cycler,
        report,
        param.average
      ]]
    },
    {
      Real notifier::evaluating(0);
      Set eval.average = sampler::eval(param.average);
      [[
        parsed,
        sampler, 
        cycler,
        report,
        param.average, 
        eval.average  
      ]]
    })
  });
  Real SetIndexByName(estim);
  estim
};
/////////////////////////////////////////////////////////////////////////////
PutDescription(_.autodoc.member.EstimParsed,EstimParsed);
/////////////////////////////////////////////////////////////////////////////


/* */