//////////////////////////////////////////////////////////////////////////////
// FILE   : _blockSampler.tol
// PURPOSE: Declares class BysMcmc::BlockSampler
// PURPOSE: Generic handler for blocks of variables in MonteCarlo Markov 
//          Chain methods
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
Class BlockSampler
//////////////////////////////////////////////////////////////////////////////
{
  //Identifies the block.
  Text _.name = "";
  //Message identificator
  Text _MID = "[BlockSampler unnamed] ";
  //Identifiers of block parameters that must be all unique
  Set _.colNames = Copy(Empty);
  //The position of this block in full MCMC
  Real _.numBlock = ?;
  //Number of parameters in the block
  Real _.N = ?;
  //First column of this block in full MCMC
  Real _.firstCol = ?;
  //Last column of this block in full MCMC
  Real _.lastCol = ?;
  //Indexes of columns of this block in full MCMC
  Set _.colIdx = Copy(Empty);
  //User configuration parameters
  BysMcmc::Config _.config = BysMcmc::Config.Default(0);
  //Stores current values of parameters
  VMatrix _.store = Rand(0,0,0,0);
  //Flag that enables/disables the block
  Real enabled = True;
  Real refreshFrequency = 1;
  
  //Used for partial sampling
  BysMcmc::BlockPartialSampler _.partialSampler = 
    BysMcmc::BlockPartialSampler.Default(0);

  //Result of call to define method
  Real _defined;

  ////////////////////////////////////////////////////////////////////////////
  //_buildWorkSpace will be the internal method used to build work space of 
  //specialized blocks and can take any number of arguments of any type
  //This member will store a reference of _buildWorkSpace if needed
  //Default behaviour does nothing 
  ////////////////////////////////////////////////////////////////////////////
  Real _noWorkSpace(Real unused) 
  {
  //WriteLn("TRACE"+_MID+" BlockSampler::_noWorkSpace 0");
    0 
  };
  Code _.buildWorkSpace = _noWorkSpace;

  //Method of sample generation 
  VMatrix draw(Real numSim);

  //This method will be called for MCMC initialzation
  //Default behaviour does nothing
  Real initialize(Real unused) { 0 };

  //Almost all blocks must filter matrices from other blocks
  //Default behaviour does nothing
  VMatrix filter(VMatrix Z) { Z };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.define =
  "Creates common information handler about each MCMC block"
  "Arguments are:\n"
  "  Text name: Identifies the block.\n"
  "  Set colNames: Identifiers of block parameters that must be all unique.\n"
  "  McmcPartialHandler mcmcPartialHandler: partial simulation info.\n"
  "  Real numBlock: The position of this block in full MCMC.\n"
  "  Real firstCol: First column of this block in full MCMC\n"
  "  NameBlock config: User configuration parameters\n";
  Real define(Text name, 
              Set colNames, 
              BysMcmc::McmcPartialHandler mcmcPartialHandler,
              Real numBlock, 
              Real firstCol,
              BysMcmc::Config config)
  ////////////////////////////////////////////////////////////////////////////
  { 
  //WriteLn("TRACE "+_MID+"::define"+"\n  name="<<name+"\n  numBlock="<<numBlock+"\n  firstCol="<<firstCol);
    Text _.name := name;
    Text _MID := "[BlockSampler "+name+"] ";
    Real _.N := Card(colNames);
    Real If(_.N, {
      Real GT0 (Real idx) { idx>0 };
      Set _.colNames := SetTolNameAndIndex(colNames);
      Real SetIndexByName(_.colNames);
      1
    });
    Real _.partialSampler::build(_.colNames, mcmcPartialHandler);
    Real If(Not(_.partialSampler::_.freeParamNum), 
    {
      Code _.buildWorkSpace := _noWorkSpace;
      1
    });
    Real _.numBlock := numBlock;
    Real _.firstCol := firstCol;
    Real _.lastCol  := firstCol+_.N-1;
    Set _.colIdx := Range(_.firstCol, _.lastCol, 1);
    BysMcmc::Config _.config := config;
    VMatrix If(Or(!_.N, VRows(_.store)!=_.N), _.store := Rand(_.N,1,0,0), _.store);
    WriteLn(_MID+" created with "<<
       _.N+" parameters from "<<_.firstCol+" to "<<_.lastCol+"");
    1
  };


  ////////////////////////////////////////////////////////////////////////////
  //Method of sample generation 
  VMatrix get.draw(Real numSim, Real force)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_MID+" get.draw 0");
    Real refresh = Case(
      force, 1,
      !enabled, 0, 
      1==1, Rand(0,1)<=refreshFrequency);
  //WriteLn("TRACE "+_MID+" get.draw 1");
    If(!refresh, Copy(_.store),
    { 
    //WriteLn("TRACE "+_MID+" get.draw 2 _.partialSampler::_.freeParamNum = "<<_.partialSampler::_.freeParamNum);
      VMatrix b = Case(
      Not(_.partialSampler::_.freeParamNum), 
      {
      //WriteLn("TRACE "+_MID+" get.draw 3.1");
        _.partialSampler::getMergedFixedAndReloadedSample(numSim)
      },
      _.partialSampler::_.freeParamNum!=_.N, 
      {
      //WriteLn("TRACE "+_MID+" get.draw 3.2");
        _.partialSampler::getMergedFixedAndReloadedSample(numSim);
        VMatrix b2 = draw(numSim);
        _.partialSampler::mergeWithFreeSample(b2)
      },
      1==1,
      {
      //WriteLn("TRACE "+_MID+" get.draw 3.3");
        draw(numSim)
      });
    //WriteLn("TRACE "+_MID+" get.draw 4");
      Real setStore(VMat2Mat(b));
      b
    })
  };


  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getStoreColIndex =
  "Returns the index with given column name in local block store";
  Real getStoreColIndex(Text colName) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Real idx = FindIndexByName(_.colNames, ToName(colName));
    Real If(idx>0, idx,
    {
      Real CMsg::Coded::show(BysMcmc::_.cmsg::_.notFoundName,
        [["[Block "+_.name+"::getStoreColIndex]",colName]]),
      0
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getStoreColIndexes =
  "Returns the set of indexes in local store with given column names";
  Set getStoreColIndexes(Set colNames) 
  ////////////////////////////////////////////////////////////////////////////
  {
    EvalSet(colNames, getStoreColIndex)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getMcmcColIndex =
  "Returns the index with given column name in global MCMC";
  Real getMcmcColIndex(Text colName) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Real idx = FindIndexByName(_.colNames, ToName(colName));
    Real If(idx>0, _.colIdx[idx],
    {
      Real CMsg::Coded::show(BysMcmc::_.cmsg::_.notFoundName,
        [["[Block "+_.name+"::getMcmcColIndex]",colName]]),
      0
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getMcmcColIndexes =
  "Returns the set of indexes inMCMC with given column names";
  Set getMcmcColIndexes(Set colNames) 
  ////////////////////////////////////////////////////////////////////////////
  {
    EvalSet(colNames, getMcmcColIndex)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getMcmc =
  "Extracts from MCMC columns related to this block";
  Matrix getMcmc(Matrix mcmc) 
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.N<=0, Rand(Rows(mcmc),0,0,0),
      SubCol(mcmc, _.colIdx))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.getMcmcRow =
  "Extracts from a row of MCMC columns related to this block";
  Matrix getMcmcRow(Matrix mcmc, Real row) 
  ////////////////////////////////////////////////////////////////////////////
  {
    If(_.N<=0, Rand(1,0,0,0),
      SubCol(SubRow(mcmc,[[row]]), _.colIdx))
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix vMat2Col(VMatrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
    If(VRows(values)==1,Tra(values),values)
  };
  ////////////////////////////////////////////////////////////////////////////
  VMatrix mat2Col(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
    vMat2Col(Mat2VMat(values))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.checkNonFiniteValues =
  "Checks that the current stored vector of parameters has just finite real "
  "values, and not unknown (NAN) of infinte ones.";
  Real checkNonFiniteValues(Real unused)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real ok = MatMin(IsFinite(VMat2Mat(_.store)));
    Real If(!ok, CMsg::Coded::show
      (BysMcmc::_.cmsg::_.unkInfBlock,[[_.name,_.store]]));
    ok
  };

  ////////////////////////////////////////////////////////////////////////////
  Real putStoreV(VMatrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_.name+"::putStoreV("<<VRows(values)+"x"<<VColumns(values)+")");
    If(_.N<=0, 0,
    {
      VMatrix _.store := vMat2Col(values);
    //WriteLn("TRACE "+_.name+"::_.store("<<VRows(_.store)+"x"<<VColumns(_.store));
      checkNonFiniteValues(0)
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real putStore(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_.name+"::putStore("<<Rows(values)+"x"<<Columns(values)+")");
    putStoreV(Mat2VMat(values))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setStore =
  "Sets _.store to the specified row or column vector of values";
  Real setStore(Matrix values) 
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE "+_.name+"::setStore("<<Rows(values)+"x"<<Columns(values)+")");
    putStore(values) 
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.setMcmcRow =
  "Sets _.store to the columns related to this block of a given row of a "
  "Markov Chain";
  Real setMcmcRow(Matrix mcmc, Real row) 
  ////////////////////////////////////////////////////////////////////////////
  {
    setStore(getMcmcRow(mcmc, row))
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.average =
  "Extracts from MCMC columns related to this block and returns its average";
  Matrix average(Matrix mcmc) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Matrix subMcmc = getMcmc(mcmc);
    Real r = Rows(subMcmc);
    Matrix avr = Rand(1, r, 1/r, 1/r);
    Tra(avr*subMcmc)
  }

};

//////////////////////////////////////////////////////////////////////////////
Class BlockSamplerDefault : BlockSampler
//////////////////////////////////////////////////////////////////////////////
{
  VMatrix draw(Real numSim) { Rand(0,1,0,0) };
  Real buildWorkSpace(Real unused) { True };
  Code _.buildWorkSpace = buildWorkSpace
};

//////////////////////////////////////////////////////////////////////////////
BlockSamplerDefault BlockSampler.Default(Text name, 
                                         Real numBlock, 
                                         Real firstCol,
                                         BysMcmc::Config config)
//////////////////////////////////////////////////////////////////////////////
{
  BysMcmc::BlockSamplerDefault aux =
  [[
    Real _defined = define(name, Empty, BysMcmc::McmcPartialHandler.Default(0),
                          numBlock, firstCol, config)
  ]];
  aux
};
