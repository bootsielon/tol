
  // [API útil]
  //  * Text _.autodoc.get.identifier(NameBlock package)
  //  * NameBlock Require(Text identifier)
  //  * Real AddRepository(Text url)
  // [API Client+Server]
  //  * Real InstallPackage(Text identifier)
  //  * Real InstallCompatible(Text pattern, Text tolVersion, Date date)
  //  * Real InstallLastCompatible(Text pattern)
  //  * Real UpdateAll(Real void)
  //  * Real UpgradeAll(Real void)
  // [API compatibilidad]
  //  % Set _.GetVersSyncInfo(Real void) 
  //  % Set _.GetPackSyncInfo(Text tolVersion)
  //  % Set GetInstallationList(Set packages)
  //  * Set AtListA(Text listId)
  // <Leyenda>
  //  %: Utilizados en la GUI de TolPackage.

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.get.identifier(NameBlock package)
  ////////////////////////////////////////////////////////////////////////////
  {
    package::_.autodoc.name<<"."
      <<package::_.autodoc.version.high<<"."<<package::_.autodoc.version.low
  };

  ////////////////////////////////////////////////////////////////////////////
  NameBlock Require(Text identifier)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real Eval("Real {
      #Require "<<identifier<<";
    1}");
    Eval(Tokenizer(identifier, ".")[1])
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.AddRepository = 
    "Añade un repositorio a la lista de configuración del usuario:\n"
    "  Set TolConfigManager::Config::Upgrading::TolPackage::Repositories\n";
  Real AddRepository(Text url)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set TolConfigManager::Config::Upgrading::TolPackage::Repositories :=
      Unique(TolConfigManager::Config::Upgrading::TolPackage::Repositories <<
      [[url]]);
    Real TolConfigManager::SaveConfig(TolConfigManager::Config);
    Real Server::GetCatalog(?)::Update(?)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _AsOSDir(Text dir)
  ////////////////////////////////////////////////////////////////////////////
  {
    // OSDir* utiliza direcciones no acabadas en /
    Real length = TextLength(dir);
    If(Text Sub(dir, length, length)=="/", Sub(dir, 1, length-1), dir)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real InstallPackage(Text identifier)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real Server::Initialize(?);
    Text file = Server::DownloadPackage(identifier);
    Real If(TextLength(file), {
      Real Client::InstallZip(file);
      Real Client::UpdateCatalog(?);
    1}, 0)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real InstallCompatible(Text pattern, Text tolVersion, Date date)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real Server::Initialize(?);
    Text file = Server::DownloadCompatible(pattern, tolVersion, date);
    Real If(TextLength(file), {
      Real Client::InstallZip(file);
      Real Client::UpdateCatalog(?);
    1}, 0)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real InstallLastCompatible(Text pattern)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real Server::Initialize(?);
    Text file = Server::DownloadLastCompatible(pattern);
    Real If(TextLength(file), {
      Real Client::InstallZip(file);
      Real Client::UpdateCatalog(?);
    1}, 0)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real UpdateAll(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    @Catalog client = Client::GetCatalog(?);
    @Catalog server = Server::GetCatalog(?);
    Set updateList = server::ObtainUpdateList(client, Version, UnknownDate);
    If(Card(updateList), SetSum(EvalSet(updateList, Real (Set record) {
      WriteLn("[UpdateAll] Se actualiza "<<record::identifier);
      InstallPackage(record::identifier)
    })), 0)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real UpgradeAll(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    @Catalog client = Client::GetCatalog(?);
    @Catalog server = Server::GetCatalog(?);
    Set upgradeList = server::ObtainUpgradeList(client, Version, UnknownDate);
    If(Card(upgradeList), SetSum(EvalSet(upgradeList, Real (Set record) {
      WriteLn("[UpgradeAll] Se mejora a "<<record::identifier);
      InstallPackage(record::identifier)
    })), 0)
  };

  // Estructuras

  ////////////////////////////////////////////////////////////////////////////
  // Para la gestión de orígenes de código. (Builder)
  Struct @PackageSource
  ////////////////////////////////////////////////////////////////////////////
  {
    Text name;
    Text type;
    Text source
  };

  ////////////////////////////////////////////////////////////////////////////
  // Para la transmisión de información desde los repositorios. (Server)
  // Información de un paquete que es relevante para la sincronización de las 
  // copias locales con el repositorio remoto.
  Struct @VersionSynchro
  ////////////////////////////////////////////////////////////////////////////
  {
    Text te_url,                  //URL of repository
    Text co_name,                 //Generic name of package
    Text co_name_version,         //Name of versioned package 
    Text te_extra_info,           //Extra information
    Text te_min_tol_version,      //Minimum compatible TOL version
    Text te_max_tol_version,      //Maximum compatible TOL version
    Text te_dependencies,         //Required packages
    Date dh_release_date_remote,  //Publication date in remote repository
    Date dh_release_date_local,   //Local installing date
    Real nu_bytes                 //Size of remote compressed archive
  };

  ////////////////////////////////////////////////////////////////////////////
  // Para la transmisión de información desde los repositorios. (Server)
  // Información de un paquete que es relevante para la sincronización de las 
  // copias locales con el repositorio remoto.
  Struct @PackageSynchro {
  ////////////////////////////////////////////////////////////////////////////
    Text te_url,                  //URL of repository
    Text co_name,                 //Generic name of package
    Text te_brief,                //Brief description of package 
    Text te_extra_info,           //Extra information
    Text te_min_tol_version,      //Minimum compatible TOL version
    Text te_max_tol_version,      //Maximum compatible TOL version
    Text co_last_version_remote,  //Name of last remote version
    Text co_last_version_local,   //Name of last local version
    Date dh_release_date_remote,  //Publication date in remote repository
    Date dh_release_date_local,   //Local installing date
    Real nu_bytes                 //Size of compressed file
  };

  // Lists

  ////////////////////////////////////////////////////////////////////////////
  Set _.GetVersSyncInfo(Real void) // Compatibilidad GUI
  ////////////////////////////////////////////////////////////////////////////
  {
    @Catalog client = Client::GetCatalog(?);
    @Catalog server = Server::GetCatalog(?);
    SetConcat(EvalSet(server::_.records, Set (Set list) {
      EvalSet(list, Set (Set record) {
        Text dependencies = If(Card(record::freeDependencies), {
          SetSum([[ record::freeDependencies[1] ]]
            << For(2, Card(record::freeDependencies), Text (Real i) { 
              ", "<<record::freeDependencies[i] 
          }))
        }, "");
        Text localIdentifier = client::ObtainIdentifier_Show(record::name, 
          Version, UnknownDate, 0);
        Date localRelease = If(TextLength(localIdentifier), {
          Set localRecord = client::GetRecord(localIdentifier);
          localRecord::release
        }, TheBegin);
        @VersionSynchro(record::repository, record::name, record::identifier,
          "<...>", record::minTolVersion, record::maxTolVersion, 
          dependencies, record::release, localRelease, ?)
      })
    }))
  };

  ////////////////////////////////////////////////////////////////////////////
  Set _.GetPackSyncInfo(Text tolVersion) // Compatibilidad GUI
  ////////////////////////////////////////////////////////////////////////////
  {
    @Catalog client = Client::GetCatalog(?);
    @Catalog server = Server::GetCatalog(?);
    EvalSet(server::GetCompatibleList(tolVersion, UnknownDate), 
      Set (Set record) {
      Text localIdentifier = client::ObtainIdentifier_Show(record::name, 
        Version, UnknownDate, 0);
      Date localRelease = If(TextLength(localIdentifier), {
        Set localRecord = client::GetRecord(localIdentifier);
        localRecord::release
      }, TheBegin);
      @PackageSynchro(record::repository, record::name, "<...>", "<...>", 
        record::minTolVersion, record::maxTolVersion, record::identifier,
        localIdentifier, record::release, localRelease, ?)
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Set GetInstallationList(Set patterns) // GUI
  ////////////////////////////////////////////////////////////////////////////
  {
    TolPackage::@Catalog catalog = TolPackage::Server::GetCatalog(?);
    Set deepDs = Unique(SetConcat(EvalSet(patterns, Set (Text pattern) {
      [[pattern]]<<catalog::GetDeepDependencies(pattern, Version, UnknownDate)
    })));
    Set catalog::IdentifyPackages(deepDs, Version, UnknownDate)
  };

  ////////////////////////////////////////////////////////////////////////////
  Set _ListA = Ois.Load(GetAbsolutePath("listA.oza"))[1];
  ////////////////////////////////////////////////////////////////////////////
  Set AtListA(Text listId)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real index = FindIndexByName(_ListA, listId);
    If(index, _ListA[index], {
      Set parts = Tokenizer(listId, ".");
      Real index2 = FindIndexByName(_ListA, parts[1]);
      If(index2, {
        Set info = DeepCopy(_ListA[index2]);
        Real info::_.autodoc.version.high := Eval(parts[2]);
        Real info::_.autodoc.version.low := Eval(parts[3]);
        Text identifier = parts[1]<<"."<<parts[2]<<"."<<parts[3];
        PutName(identifier, info)
      }, Copy(Empty))
    })
  };

  ////////////////////////////////////////////////////////////////////////////
