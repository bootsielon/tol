/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : server.tol
// PURPOSE: TolPackage server side tools
//////////////////////////////////////////////////////////////////////////////

Text _.autodoc.member.Server= 
"Sistema servidor de gestión de paquetes TOL";

//////////////////////////////////////////////////////////////////////////////
NameBlock Server = [[
//////////////////////////////////////////////////////////////////////////////

Text _.localRoot = TolPackage::_.localRoot +"Server/";

Set _.supportedPlatforms =
[[
  "Windows_x86_32",
  "Linux_x86_32"
]];

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.Initialize = 
"Inicializa el servidor del servicio de paquetes TOL";
Real Initialize(Real void)
//////////////////////////////////////////////////////////////////////////////
{
  Real OSDirMake(_.localRoot);
  Set EvalSet(_.supportedPlatforms, Real(Text platform)
  {
    Real OSDirMake(_.localRoot+platform)
  });
  True
};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.FormatSet=
"Builds the TOL expression of a Set";
Text FormatSet(Set set)
//////////////////////////////////////////////////////////////////////////////
{
  Text bl = " ";
  Text name = Name(set);
  "Set { "+If(name=="","",Name(set)+" = ")+bl+
  If(!Card(set),"Copy(Empty)",
  {
    "[["+bl+
    SetSum(For(1,Card(set),Text(Real k)
    {
      Text gk = Grammar(set[k]);
      Text nk = Name(set[k]);
      Text dec = "  "+gk+" { "+If(nk=="","",nk+" = ");
      If(k>1,","+bl,"")+
      Case(
      gk=="Text", dec+"\""+set[k]+"\" } ",
      gk=="Real", dec<<set[k]+" } ",
      gk=="Date", dec<<set[k]+" } ",
      gk=="Set",  FormatSet(set[k]),
      1==1,
      {
        WriteLn("[TolPackage::Server::FormatSet] "
        " Unexpected object "+If(nk,nk+" ","")+"of invalid type "+gk,"E"),
        ""
      })
    }))+bl+"]]"
  })+
  " }"
};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.SqlFormatSetOfText =
"Builds the SQL expression of a Set of texts without quotes nor brackets";
Text SqlFormatSetOfText(Set set)
//////////////////////////////////////////////////////////////////////////////
{
  If(!Card(set),"",
  {
    SetSum(For(1,Card(set),Text(Real k)
    {
      Text gk = Grammar(set[k]);
      If(k>1,",","")+
      Case(
      gk=="Text", set[k],
      1==1,
      {
        Text nk = Name(set[k]);
        WriteLn("[TolPackage::Server::SqlFormatSetOfText] "
        " Unexpected object "+If(nk,nk+" ","")+"of invalid type "+gk,"E"),
        ""
      })
    }))
  })
};



//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.BuildPackage = 
"Construye el archivo comprimido correspondiente a un paquete TOL a partir "
"del código situado en el directorio fuente:\n"
"  \"<sourceRoot>/<name>\"\n"
"\n"
"El resultado se almacena en el directorio de destino con el nombre de "
"la versión específica que conste en el NameBlock del paquete:"
"\n"
"  \"<destination>/<name>.<high>.<low>.zip\"\n"
"\n";
Text BuildPackage(
  Text name,         //Nombre del paquete (sin versión)
  Text sourceRoot,   //Directorio raíz del código fuente
  Text destination,  //Directorio de destino del paquete
  Real removeDir)    //Si es cierto se borra el directorio descomprimido
//////////////////////////////////////////////////////////////////////////////
{
  Date release.gmt = Copy(NowGmt);
  Text _MID = "[BuildPackage] ";
  Set pkgCnt = If( ObjectExist( "NameBlock", name ), [[ NameBlock Eval( name ) ]], {
        WriteLn(_MID+sourceRoot+name+" -> "+destination);
        Set Eval("Set IncludeTOL(\""+
                 sourceRoot+name+"/"+name+".tol\",True)")
      } );
  NameBlock pkg = pkgCnt[1];
  Text name.version = name+"."<<
    pkg::_.autodoc.version.high+"."<<pkg::_.autodoc.version.low;

  Text minTolVersion = If(!ObjectExist("Text","pkg::_.autodoc.minTolVersion"),
   "v000000000000000000",  pkg::_.autodoc.minTolVersion);
  Text maxTolVersion = If(!ObjectExist("Text","pkg::_.autodoc.maxTolVersion"),
   "v999999999999999999",  pkg::_.autodoc.maxTolVersion);

  Real okTolVersion = And(
    Compare.VersionString(minTolVersion,TolPackage::_.currentTolVersion)<=0,
    Compare.VersionString(maxTolVersion,TolPackage::_.currentTolVersion)>=0);
  Real If(!okTolVersion, 
  {
    Error("[TolPackage::Server::BuildPackage] cannot create package "<<name.version+
    "with current TOL version "<<Version+". It requires a version in interval "+
    "["<<pkg::_.autodoc.minTolVersion+","<<pkg::_.autodoc.maxTolVersion+"]");
    Real Stop
  });
  Text ppRoot_ = destination+name.version;
  Text ppRoot = ppRoot_+"/";
  Real TolPackage::PackageInfo.Build(pkgCnt[1],ppRoot,release.gmt);
  Set nonTolResources = pkg::_.autodoc.nonTolResources;


  Real OSDirMake(ppRoot);
  Real Ois.Store(pkgCnt,ppRoot+name.version+".oza");

  Real cleanResource(Text dest)
  {
    Set dir = GetDir(dest);
    Set sub = dir[2];
    Set EvalSet(sub,Real(Text s)
    {
      Text dest_new = dest+"/"+s;
      Text ls = ToLower(s);
      If(Or(ls==".svn",ls=="svn",ls=="cvs",ls==".cvs"),
        OSDirRemove(dest_new),
        cleanResource(dest_new))
    });
    True
  };

  Real processResourceText(Text resource)
  {
    Text orig = sourceRoot+"/"+name+"/"+resource;
    Text dest = ppRoot+"/"+resource;
    Real OSDirMake(dest);
    If(OSUnix, OSDirRemove(dest));
  //WriteLn("TRACE dir copy '"+orig+"' -> '"+dest+"'");
    Real OSDirCopy(orig,dest);
    cleanResource(dest)
  };
  Real processResourceSet(Set resourceSet)
  {
    Set EvalSet(resourceSet, processResourceText);
    True
  };
  Set EvalSet(nonTolResources, Real (Anything res)
  {
    Text gra = Grammar(res);
    WriteLn(_MID+"Processing resource "+gra+" "<<res);
    Eval("processResource"+gra+"(res)")
  });
  Text ppr = ReplaceSlash(ppRoot_); 
  Real PackArchive::PackFull("ZipArchive", ppr, removeDir);
  ppRoot_+".zip"
};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.UploadPackage = 
"Sube al repositorio remoto un paquete desde el archivo local comprimido "
"creado con TolPackage::Server::BuildPackage y dado por el argumento:\n"
"  Text pkg.path.zip = \"<directory>/<name>.<high>.<low>.zip\"\n";
Real UploadPackage(NameBlock repository.db, Text pkg.path.zip)
//////////////////////////////////////////////////////////////////////////////
{
  Text _MID = "[UploadPackage] ";
  Text root = GetFilePath(pkg.path.zip);
  Text pkg.name.zip = GetFileName(pkg.path.zip);
  Text pkg.name = Replace(pkg.name.zip,".zip","");
  Set name.tok = Tokenizer(pkg.name,".");
  Real nu_version_high = Eval(name.tok[2]);
  Real nu_version_low = Eval(name.tok[3]);
  Real PackArchive::UnpackFull("ZipArchive",root+pkg.name,False);
  Text oza = root+pkg.name+"/info.oza";
  Set pkg = Include(oza);
  Text name = pkg::_.autodoc.name;
  Real If(pkg::_.autodoc.version.high!=nu_version_high,
  {
    WriteLn("Wrong version high number "<<
      nu_version_high+"!="<<pkg::_.autodoc.version.high,"W");
    Real pkg::_.autodoc.version.high := nu_version_high
  });
  Real If(pkg::_.autodoc.version.low!=nu_version_low,
  {
    WriteLn("Wrong version low number "<<
      nu_version_low+"!="<<pkg::_.autodoc.version.low,"W");
    Real pkg::_.autodoc.version.low := nu_version_low
  });
  Real repository.db::Open(0);
  Real DBExecQuery("set client_encoding to '""latin1""'");
  Text repository.query = "
  SELECT 
    id_repository, co_repository, ds_repository, 
    co_access, co_version_control, te_url
  FROM 
    repository_d_def AS D,
    repository_d_access AS A,
    repository_d_version_control AS V
  WHERE 
      A.id_access          = D.id_access
  AND V.id_version_control = D.id_version_control
  AND (    te_url          = '"+pkg::_.autodoc.url+"' 
        OR te_url          = '"+pkg::_.autodoc.url+"repository.php' ) 
  ";
//WriteLn("TRACE "+_MID+"repository.query=\n"+repository.query);
  Set repository = DBTable(repository.query);
  If(!Card(repository), 
  {
    WriteLn(_MID+"Unknown repository '"+pkg::_.autodoc.url+"'","E");
    False
  },
  {
    Set dep = pkg::_.autodoc.dependencies;
    Set aut = pkg::_.autodoc.authors;
    Set key = pkg::_.autodoc.keys;
    Set res = pkg::_.autodoc.nonTolResources;
    Text verCnt = ReplaceTable(pkg::_.autodoc.versionControl,[[
      [["\n","<BR>"]],
      [["'","\""]] ,
      [[";",","]] ]]);
    Text bl_contents = EncodeBase64FromFile(pkg.path.zip);
    Real nu_bytes = FileBytes(pkg.path.zip);
    Real id_format = 1;
    Text te_max_tol_version = pkg::_.autodoc.maxTolVersion;
    Text te_extra_info = "";
  //Text exist.query = 
    Text insert.query = "
    INSERT INTO package_f_contents(
      id_repository, co_name, nu_version_high, nu_version_low, 
      te_brief, te_description, 
      te_keys, te_authors, te_min_tol_version, dh_release_date,  
      te_dependencies, te_non_tol_resources, te_version_control,
      bl_contents, nu_bytes, id_format, te_max_tol_version, te_extra_info)
    VALUES (
     "<<(repository[1])::id_repository+", "+
     "'"+name+"', \n"+
     ""<<pkg::_.autodoc.version.high+", \n"+
     ""<<pkg::_.autodoc.version.low+", \n"+
     "'"<<pkg::_.autodoc.brief+"', \n"+
     "'"+Replace(pkg::_.autodoc.description,"\n","<BR>")+"', \n"+
     "'"<<TolPackage::Server::SqlFormatSetOfText(pkg::_.autodoc.keys)+"', \n"+
     "'"<<TolPackage::Server::SqlFormatSetOfText(pkg::_.autodoc.authors)+"', \n"+
     "'"<<pkg::_.autodoc.minTolVersion+"', \n"+
     "'"<<FormatDate(pkg::_.autodoc.releaseDate,"%c%Y-%m-%d %h:%i:%s")+"', \n"+
     "'"<<TolPackage::Server::SqlFormatSetOfText(dep)+"', \n"+
     "'"<<TolPackage::Server::FormatSet(res)+"', \n"+
     "E'"<<verCnt+"', \n"+
     "decode('"<<bl_contents+"','base64'), \n"+
     ""<<nu_bytes+", \n"+
     ""<<id_format+", \n"+
     "'"<<te_max_tol_version+"', \n"+
     "'"<<te_extra_info+"' \n"+
    ");";
  //WriteLn("TRACE "+_MID+"insert.query=\n" + insert.query);

    Real num_reg = DBExecQuery(insert.query);
    If(!num_reg, WriteLn(_MID+
      "Package is already in the repository. Please upgrade the "
      "version numbers or delete the register of existent package.","E"));
    Real repository.db::Close(0);
    num_reg
  })
};

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.BuildAndUploadPackage = 
"Construye el archivo comprimido correspondiente a un paquete TOL a partir "
"del código situado en el directorio fuente:\n"
"  \"<sourceRoot>/<name>\"\n"
"\n"
"y luego lo sube al repositorio remoto.\n"
"La copia temporal del archivo comprimido del paquete se queda en el "
"directorio del servidor a efectos de depuración si surgen problemas "
"pero se puede borrar si se desea.\n"
"Por último se chequeará la instalación según lo indicado:"
"  Si checkInstallMode = \"local\" se usa la copia local comprimida.\n"
"  Si checkInstallMode = \"remote\" se instala desde el repositorio.\n"
"  En otro caso no se instala nada.\n"
"Devuelve un código que indica en qué fase ha habido problemas:\n"
"  0 todo parece haber ido bien\n"
"  1 hubo fallos en la construcción (entonces la subida no se intenta)\n"
"  2 no hubo fallos en la construcción pero sí en la subida (la instalación no se intenta)\n"
"  3 no hubo fallos en la construcción ni en la subida pero la instalación ha dado errores\n";
Real BuildAndUploadPackage(
  Text name,                //Nombre del paquete (sin versión)
  Text sourceRoot,          //Directorio raíz del código fuente
  Text repository.url,      //URL del repositorio
  NameBlock repository.db,  //Conexión a la base de datos
  Text checkInstallMode)    //Modo de chequeo de la instalación
//////////////////////////////////////////////////////////////////////////////
{
  Real nErr0 = Copy(NError);
  Text tmp = _.localRoot;
  Real OSDirMake(tmp);
  Text pkg.path.zip = TolPackage::Server::BuildPackage(
    name, sourceRoot, tmp, True);
  Real nErr1 = Copy(NError);
  If(nErr1>nErr0, 
  { 
    WriteLn("Es posible que no se haya podido construir el paquete correctamente","W");
    1
  },
  {
    Real TolPackage::Server::UploadPackage( 
      repository.db, pkg.path.zip);
    Real nErr2 = Copy(NError);
    If(nErr2>nErr1, 
    { 
      WriteLn("Es posible que no se haya podido enviar el paquete al repositorio","W");
      2
    },
    {
      Text pkg.name = Replace(GetFileName(pkg.path.zip),".zip","");
      Real ok = Case(
      ToLower(checkInstallMode) == "remote",
      {
        TolPackage::Client::RemoteInstallPackage(repository.url, pkg.name, True)
      },
      ToLower(checkInstallMode) == "local",
      {
        Real TolPackage::Client::LocalInstallPackage(pkg.path.zip)
      },
      1==1,True);
      Real nErr3 = Copy(NError);
      If(And(ok,nErr3==nErr2), 0,
      { 
        WriteLn("La instalación en modo '"+checkInstallMode+"' ha dado problemas","W");
        3
      })
    })
  })
}; 

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.RemovePackageVersion = 
"Borra una versión de un paquete del repositorio.\n"
"Esta función no es reversible, así que debe usarse con mucho cuidado.\n"
;
Real RemovePackageVersion(
  Text name,                //Nombre del paquete (sin versión)
  Real nu_version_high,     //Primer número de versión
  Real nu_version_low,      //Segundo número de versión
  NameBlock repository.db)  //Conexión a la base de datos
//////////////////////////////////////////////////////////////////////////////
{
  Real repository.db::Open(0);
  Real reg = DBExecQuery(
  "DELETE FROM package_f_contents\n"
  "WHERE \n"
  "  co_name = '"+name+"' AND\n"
  "  nu_version_high = "<<nu_version_high+" AND\n"
  "  nu_version_low = "<<nu_version_low+";\n");
  Real repository.db::Close(0);
  reg
};


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.CheckTolDependencies = 
"Comprueba que las versiones mínima y máxima especificadas para cada "
"paquete son coherentes con las especificadas por los paquetes requeridos "
"directa o indirectamente.\n";
Set CheckTolDependencies(NameBlock repository.db, Real fix)
//////////////////////////////////////////////////////////////////////////////
{
  Text url=TolPackage::_.official+"action=checkTolDependencies&filter=False";
  Text pkgInfo = GetUrlContents(url);
  Set pkgLst = IncludeText(pkgInfo);
  Real repository.db::Open(0);
  Set EvalSet(pkgLst,Real(TolPackage::@TolVerReqChk chk)
  {
    If(Not(chk->min_ok),
    {
      Text msg = "Minimum specified TOL version for package "<<
        chk->co_name_version+" is "+chk->te_min_tol_version +
        "lesser than indirectly recommended "+chk->te_min_tol_version_deep+"\n";
      Real If(fix,
      {
        Text msg := msg + "Fixing field package_f_contents."
          "te_min_tol_version to '"+chk->te_min_tol_version_deep+"' in database of repository.";
        DBExecQuery("UPDATE package_f_contents "
        "SET te_min_tol_version='"+chk->te_min_tol_version_deep+"'")
      });
      WriteLn(msg+"Please, fix it if posible in your TOL code by settting \n"+
      "Text "+chk->co_name_version+"::te_min_tol_version = \""+
      chk->te_min_tol_version_deep+"\";\n","W")
    });
    If(Not(chk->max_ok),
    {
      Text msg = "Maximum specified TOL version for package "<<
        chk->co_name_version+" is "+chk->te_max_tol_version +
        "greater than indirectly recommended "+chk->te_max_tol_version_deep+"\n";
      Real If(fix,
      {
        Text msg := msg + "Fixing field package_f_contents."
          "te_max_tol_version to '"+chk->te_max_tol_version_deep+"' in database of repository.";
        DBExecQuery("UPDATE package_f_contents "
        "SET te_max_tol_version='"+chk->te_max_tol_version_deep+"'")
      });
      WriteLn(msg,"W")
    });
    True
  });
  Real repository.db::Close(0);
  pkgLst
}  
  

]];

/* */
