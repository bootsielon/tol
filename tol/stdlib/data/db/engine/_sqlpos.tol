//////////////////////////////////////////////////////////////////////////////
// FILE    : _sqlPos.tol
// PURPOSE : Funciones propias del gestor PosCLE
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// CONSTANTS
//////////////////////////////////////////////////////////////////////////////

Text SqlPosFormatRealTol2Sql = "%.5lf";
Date SqlPosDefaultTheBegin   = y1990m01d01h00i00s00;
Date SqlPosDefaultTheEnd     = y2010m01d01h00i00s00;

//////////////////////////////////////////////////////////////////////////////
// FUNCTIONS
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text SqlPosFormatDate(Date dte)
//////////////////////////////////////////////////////////////////////////////
{
  Date dteAux = 
   If(dte == TheBegin, SqlPosDefaultTheBegin,
   If(dte == TheEnd,   SqlPosDefaultTheEnd, dte));

  Text formatDate = FormatDate(dteAux, "%c%Y/%m/%d%u %h:%i:%s");
  Real longfd     = TextLength(formatDate);
  Text sqlFormat  = Case
  (
    //EQ(longfd, 4), "YYYY",
    //EQ(longfd, 7), "YYYY/MM",
    EQ(longfd, 10), "YYYY/MM/DD",
    EQ(longfd, 13), "YYYY/MM/DD HH24",
    EQ(longfd, 16), "YYYY/MM/DD HH24:MI",
    EQ(longfd, 19), "YYYY/MM/DD HH24:MI:SS",
    True          , "YYYY/MM/DD HH24:MI:SS..."
  );

  "to_date('"+ formatDate +"', '"+ sqlFormat +"')" 

};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Formateador de fecha con formato dependiente del de TOL al formato 
equivalente PostGres.",
SqlPosFormatDate);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text SqlPosFormatReal(Real rea)
//////////////////////////////////////////////////////////////////////////////
{  //Hay que realizar un casting porque si no toma el nulo como cadena
  Real isUnk = IsUnknown(rea);
  Real isInf = IsInfinite(rea);
  If(Or(isUnk, isInf), "NULL::float8", 
   FormatReal(rea,SqlPosFormatRealTol2Sql))
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Formateador de reales TOL a formato real de PostGres.",
SqlPosFormatReal);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text SqlPosFormatInteger(Real rea)
//////////////////////////////////////////////////////////////////////////////
{//Hay que realizar un casting porque si no toma el nulo como cadena
  Real isUnk = IsUnknown(rea);
  Real isInf = IsInfinite(rea);
  If(Or(isUnk, isInf), "NULL::int", IntText(rea))
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Formateador de reales TOL a formato entero de PostGres. Si el numero no es 
entero lo redondea.",
SqlPosFormatInteger);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text SqlPosFormatText(Text txt)
//////////////////////////////////////////////////////////////////////////////
{ If(txt == "", "null","'"+Replace(txt, "'", "''")+"'") };
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Formateador de text a char de PosCLE",
SqlPosFormatText);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text SqlPosFormatPolyn(Polyn pol)
//////////////////////////////////////////////////////////////////////////////
{ 
  If(IsUnknownPolyn(pol), "null", "'"+FormatPolyn(pol)+"'") 
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Formateador de polyn a char de PosCLE",
SqlPosFormatPolyn);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set SqlPosInfoColumns(Text tabla)
//////////////////////////////////////////////////////////////////////////////
{ 
  // query

  Text strSql =
"
    SELECT UPPER(pg_class.relname) AS Table_, 
           UPPER(pg_attribute.attname) AS Column_, 
           UPPER(pg_type.typname) AS Type_,
           CASE WHEN 
             pg_type.typname = 'varchar' 
           THEN
             (pg_attribute.atttypmod - 
               (pg_attribute.atttypmod / 65536) * 65536 - 
              4)
           ELSE
             CASE WHEN 
               pg_type.typname = 'date' 
             THEN
               4
             ELSE
               CASE WHEN 
                 pg_type.typname = 'time' OR pg_type.typname = 'timestamp' 
               THEN
                 8
               ELSE
                 (pg_attribute.atttypmod / 65536) 
               END
             END
           END AS Length_,
           CASE WHEN 
             pg_type.typname = 'numeric' 
           THEN
             (pg_attribute.atttypmod / 65536) 
           ELSE
             null
           END AS Precision_,
           CASE WHEN 
             pg_type.typname = 'numeric'
           THEN
             (pg_attribute.atttypmod - 
               (pg_attribute.atttypmod / 65536) * 65536 - 
              4) 
           ELSE 
             null
           END AS Scale_,
           CASE WHEN 
             pg_attribute.attnotnull = 't'
           THEN 
             0 
           ELSE
             1
           END AS IsNull_,
           CASE WHEN
             (SELECT COUNT(*) > 0
                FROM pg_class Cla, pg_constraint Con, pg_attribute Att
               WHERE Cla.oid          = Con.conrelid 
                 AND Con.contype      = 'p'
                 AND Cla.relname      = pg_class.relname
                 AND Att.attname      = pg_attribute.attname
                 AND Cla.oid          = Att.attrelid
                 AND Att.attnum       = ANY(Con.conkey)
                 AND Att.attisdropped = 'f'
                 AND Att.attnum       > 0) = 't'
           THEN
             1
           ELSE
             0
           END AS IsKey_
      FROM pg_class, pg_attribute, pg_type
     WHERE pg_class.oid              = pg_attribute.attrelid 
       AND pg_attribute.attisdropped = 'f' 
       AND pg_attribute.attnum       > 0
       AND UPPER(pg_class.relname)   = UPPER('"+tabla+"') 
       AND pg_attribute.atttypid     = pg_type.oid 
  ORDER BY pg_attribute.attnum
";
  Set info = SqlDBTable(strSql, "StSqlInfoColums");
  info

//  Empty
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Información de los campos de una tabla de Poscle",
SqlPosInfoColumns);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set SqlPosInfoKeys(Text tabla)
//////////////////////////////////////////////////////////////////////////////
{ 
  // query
  Text strSql =
"
select Cl.RelName     as Table_,
       ic.conname     as Index_,
       Atr.attname    as Column_
from  pg_constraint ic, pg_attribute Atr,pg_class     Cl
where ic.conrelid = Cl.oid
and   Atr.attnum = Any(ic.conkey)
and   ic.contype='p'

and upper(Cl.RelName) = upper('"+tabla+"')*/
order by Atr.attnum
";
  Set info = SqlDBTable(strSql, "StSqlInfoKeys");
  info;
  Empty
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Información de los campos clave de una tabla de Poscle",
SqlPosInfoKeys);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set SqlPosInfoForeign(Text tabla)
//////////////////////////////////////////////////////////////////////////////
{ 
  // query
  Text strSql =
"

select Cl.RelName          as Table_,
       ic.conname          as Index_,
       Atr.attname         as Column_,
       Cl2.RelName         as ForeignTable_,
       ic2.conname         as ForeignIndex_,
       Atr2.attname        as ForeignColumn_
from  pg_constraint ic, pg_constraint ic2,
      pg_attribute Atr, pg_attribute Atr2,
      pg_class     Cl,  pg_class     Cl2
where ic.oid   <>             ic2.oid
  and ic.conrelid          = Cl.oid
  and ic2.conrelid         = Cl2.oid
  and cl.relowner          = cl2.relowner
  and ic.contype          = 'p'
   and ic2.contype          = 'f'
  and   Atr.attnum        = Any(ic.conkey)
  and   Atr2.attnum       = Any(ic2.conkey)
  and   Cl.Oid             = Atr.attrelid
  and    Atr.attrelid      <> atr2.attrelid
and   UPPER(Cl.RelName) = UPPER('"+tabla+"')
order by  ic.conname , Atr.attnum
";
  Set info = SqlDBTable(strSql, "StSqlInfoForeing");
  info;
  Empty
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Información de las relacciones externas de una tabla de Poscle",
SqlPosInfoForeign);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set SqlPosInfoDependent(Anything tabla)
//////////////////////////////////////////////////////////////////////////////
{ 
  Text gramTabla = Grammar(tabla);
  // informacion de los campos claves
  Text txtWhe = Case(
    gramTabla == "Text", " upper(Cl2.RelName) = upper('"+tabla+"') ",
    gramTabla == "Set",
    {
      Set lstWhe = EvalSet(tabla, Text (Set set)
      {
         Text " ( upper(Cl2.RelName) = upper('"+set->Table+"') 
                  and upper(ic2.conname) = upper('"+set->Column+"'))"
      });
      Text TxtListItem (lstWhe, " or "+NL)
    }, 
    "",
    {
      WriteLn("ERROR: SqlPosInfoDependent\n"+
              "Gramatica '"+ gramTabla +"' desconocida!");
      " = '"<< tabla +"'"
    }
  );
  // query
  Set info = If(txtWhe == "", Empty,
  {
    Text strSql =
"
select Cl.RelName          as Table_,
       ic.conname          as Index_,
       Atr.attname         as Column_,
       Cl2.RelName         as ForeignTable_,
       ic2.conname         as ForeignIndex_,
       Atr2.attname        as ForeignColumn_
from  pg_constraint ic, pg_constraint ic2,
      pg_attribute Atr, pg_attribute Atr2,
      pg_class     Cl,  pg_class     Cl2
where ic.oid   <>             ic2.oid
  and ic.conrelid          = Cl.oid
  and ic2.conrelid         = Cl2.oid
  and cl.relowner          = cl2.relowner
  and ic.contype          = 'p'
   and ic2.contype          = 'f'
  and   Atr.attnum        = Any(ic.conkey)
  and   Atr2.attnum       = Any(ic2.conkey)
  and   Cl.Oid             = Atr.attrelid
  and    Atr.attrelid      <> atr2.attrelid
and  ("+ txtWhe +")
order by  ic.conname , Atr.attnum
";
    Set info = SqlDBTable(strSql, "StSqlInfoForeing");
    info
  })

};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Información de las tablas que dependen de una tabla dada en Poscle.
La función puede recibir un Text o un Set.
Parámetros:
  tabla -> Text: Nombre de una tabla la Base de Datos
           Set : Conjunto con la estructura 'StSqlInfoForeing'",
SqlPosInfoDependent);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set SqlPosGetDependantTables(Text tabla, Set columns)
//////////////////////////////////////////////////////////////////////////////
{
// informacion de los campos claves
  Text txtWhe = " upper(Cl2.RelName = upper('"+tabla+"')" + 
    If(IsEmpty(columns), "",
    {
      Set lstWhe = EvalSet(columns, Text (Text col)
      {
        Text " ( and upper(ic2.conname) = upper('"+col+"'))"
      });
      Text " and (" + TxtListItem (lstWhe, " or "+NL) + ")"
     });
  // query
  Set info = If(txtWhe == "", Empty,
  {
    Text strSql =
"
select Cl.RelName          as Table_,
       ic.conname          as Index_,
       Atr.attname         as Column_,
       Cl2.RelName         as ForeignTable_,
       ic2.conname         as ForeignIndex_,
       Atr2.attname        as ForeignColumn_
from  pg_constraint ic, pg_constraint ic2,
      pg_attribute Atr, pg_attribute Atr2,
      pg_class     Cl,  pg_class     Cl2
where ic.oid   <>             ic2.oid
  and ic.conrelid          = Cl.oid
  and ic2.conrelid         = Cl2.oid
  and cl.relowner          = cl2.relowner
  and ic.contype          = 'p'
   and ic2.contype          = 'f'
  and   Atr.attnum        = Any(ic.conkey)
  and   Atr2.attnum       = Any(ic2.conkey)
  and   Cl.Oid             = Atr.attrelid
  and    Atr.attrelid      <> atr2.attrelid
and  ("+ txtWhe +")
order by  ic.conname , Atr.attnum
";
    Set info = SqlDBTable(strSql, "StSqlInfoForeing");
    info
  })


};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Información de las tablas que dependen de una tabla dada. La función
recibe un Text y un Set.
Parámetros:
  tabla    -> Text: Nombre de una tabla la Base de Datos
  columns  -> Set : Conjunto de columnas de las cuales se quiere saber
              qué claves externas están relacionadas a ella
  gestor   -> SGBD activo 
Devuelve un Set de estructuras StSqlInfoForeing 
  (Text Table, Text Index, Text Column, Text ForeignTable,
   Text ForeignIndex, Text ForeignColumn)
",
SqlPosGetDependantTables);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Set SqlPosInfoDependentAll(Anything tabla)
//////////////////////////////////////////////////////////////////////////////
{
  // query
  Set sGetTabDep = SqlPosInfoDependent(tabla);

  Set info = If(IsEmpty(sGetTabDep), Empty,
  {
    Text gramTabla = Grammar(tabla);
    Set cnj  = Case(
      gramTabla == "Text", SetOfText(tabla),
      gramTabla == "Set", tabla,
      Empty,
      {
        WriteLn("ERROR: SqlPosInfoDependentAll\n"+
                "Gramatica '"+ gramTabla +"' desconocida!");
        Empty
    });
    sGetTabDep << SqlPosInfoDependentAll(sGetTabDep)
  })
};
//////////////////////////////////////////////////////////////////////////////
PutDescription("
Información de todas las tablas que dependen de una tabla dada en Poscle.
La función puede recibir un Text o un Set.
Parámetros:
  tabla -> Text: Nombre de una tabla la Base de Datos
           Set : Conjunto con la estructura 'StSqlInfoForeing'
",
SqlPosInfoDependentAll);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text SqlPosForeignEnable(Text tabla, Text restriccion)
//////////////////////////////////////////////////////////////////////////////
{
  WriteLn("<W>SqlPosForeignEnable. Postgres. Work in Progress.</W>");
  ""
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Sentencia para habilitar una clave ajena dada para Poscle.
Valida los cambios realizados.
Parámetros:
  tabla       -> Nombre de la tabla
  restriccion -> Nombre de la resticcion
Devuelve: El texto a ejecutar",
SqlPosForeignEnable);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text SqlPosForeignDisable(Text tabla, Text restriccion)
//////////////////////////////////////////////////////////////////////////////
{
  WriteLn("<W>SqlPosForeignDisable. Postgres. Work in Progress.</W>");
  ""
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"Sentencia para deshabilitar una clave ajena dada para Poscle.
Valida los cambios realizados.
Parámetros:
  tabla       -> Nombre de la tabla
  restriccion -> Nombre de la resticcion
Devuelve: El texto a ejecutar",
SqlPosForeignDisable);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text SqlPosShowTreeTable(Text nombreTabla, Real showSonTables){
//////////////////////////////////////////////////////////////////////////////

  Set ctoTablasAcum = Copy(Empty);

  Text func_espacios(Real nEspacios, Text txt){
    Set cto = For(1, nEspacios, Text(Real i){ txt });
    If(Card(cto),
      SetSum(cto),
      "")
  };

  Text funcion(Text nombreTabla_2, Real numEspacios){

    Text espacios = func_espacios(numEspacios, "|  ");

    Text qry_cols =
    "
        SELECT UPPER(pg_attribute.attname)
          FROM pg_class, pg_attribute
         WHERE pg_class.oid              = pg_attribute.attrelid 
           AND UPPER(pg_class.relname)   = UPPER('"+ nombreTabla_2 +"') 
           AND pg_attribute.attisdropped = 'f' 
           AND pg_attribute.attnum       > 0
    ";
    Set cto_cols = DBTable(qry_cols);
  
    Text cols = {
      Text qry_pk =
      "
        SELECT UPPER(pg_attribute.attname)
          FROM pg_class, pg_constraint, pg_attribute
         WHERE pg_class.oid              = pg_constraint.conrelid 
           AND pg_constraint.contype     = 'p'
           AND UPPER(pg_class.relname)   = UPPER('"+ nombreTabla_2 +"') 
           AND pg_class.oid              = pg_attribute.attrelid
           AND pg_attribute.attnum       = ANY(pg_constraint.conkey)
           AND pg_attribute.attisdropped = 'f'
           AND pg_attribute.attnum       > 0
      ";
      Set cto_pk_temp = DBTable(qry_pk);
      Set cto_pk = If(Card(cto_pk_temp), 
        Traspose(cto_pk_temp)[1],
        Empty
      );

      Real card = Card(cto_cols);
      If(card,
      { Set cto = For(1, card-1, Text(Real i){
          Text col = cto_cols[i][1];
          If(col<:cto_pk, FirstToUpper(col, TRUE)+", ",  ToLower(col) +", ")
        });
        Text ultimo = {
          Text col = cto_cols[card][1];
          If(col<:cto_pk, FirstToUpper(col, TRUE), ToLower(col))
        };

        "("+ SetSum(cto) + ultimo +")"
      }," --> ¡¡¡NO EXISTEN restricciones para esta tabla!!!")
    };
  
    Text qry_tablas =
    If(showSonTables,
      "
      SELECT UPPER(ownTable.relname)
        FROM pg_class ownTable,
             pg_constraint,
             pg_class refTable
       WHERE pg_constraint.contype = 'f'
         AND ownTable.oid = pg_constraint.conrelid
         AND pg_constraint.confrelid = refTable.oid
         AND UPPER(refTable.relname) = UPPER('"+ nombreTabla_2 +"')
      ",
      "
      SELECT UPPER(refTable.relname)
        FROM pg_class ownTable,
             pg_constraint,
             pg_class refTable
       WHERE pg_constraint.contype = 'f'
         AND ownTable.oid = pg_constraint.conrelid
         AND pg_constraint.confrelid = refTable.oid
         AND UPPER(ownTable.relname) = UPPER('"+ nombreTabla_2 +"')
      "
    );

    Set cto_tablas_temp = DBTable(qry_tablas);
  
    Set cto_tablas = If(Card(cto_tablas_temp),
      Traspose(cto_tablas_temp)[1],
      Empty
    );
  

   Real condParada = { 
     Set cto = EvalSet(cto_tablas, Real(Text tabla){
         nombreTabla_2 <: ctoTablasAcum
     });
     Real r = SetSum(cto);
     If(IsUnknown(r), 0, r)
     };
    
    Set {ctoTablasAcum := ctoTablasAcum + SetOfText(nombreTabla_2)};

    Text ptosSusp = If(Card(cto_tablas),
    {
      Text espaciosVacios = func_espacios(numEspacios + 1, "|  ");
      "\n"+ espaciosVacios +"· [...]"
    }, "");

    If(condParada, 
      ToUpper(nombreTabla_2) + cols + ptosSusp,
     { 
       Set cto = EvalSet(cto_tablas, Text(Text tab){
         "\n"+ espacios + "|  · "+ funcion(tab, numEspacios + 1)
       });
       ToUpper(nombreTabla_2) + cols + SetSum(cto)
     }
    )
  };

  funcion(nombreTabla, 0)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(
"  Dada una tabla, dibuja un árbol con las tablas que hacen referencia a ella 
de forma recursiva si 'showSonTables' es TRUE, si no mostrará las
tablas a las que ésta hace referencia recursivamente.
  Se muestran también los campos, los que son Primary Key en capital.
  La expresión '[...]' indica que dicha tabla ya ha sido representada.",
SqlPosShowTreeTable);
//////////////////////////////////////////////////////////////////////////////
