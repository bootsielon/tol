//////////////////////////////////////////////////////////////////////////////
// FILE: _ois.tol
// PURPOSE: functions to handle with OIS modules and stores.  
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
  Real Ois.Store(Set data, Text path_) 
//////////////////////////////////////////////////////////////////////////////
{
  Text path = Ois.AutoPath(path_);
  Text name = ToName(Identify(data));
  Ois.Create
  (
    path,
    Empty, 
    data,
    Ois.DocStr
    (
      Ois.DefDoc->Name+If(Ois.DefDoc->Name!="","::","")+name,
      {category="Data.Store"},
      {subject= Ois.DefDoc->Subject+If(Ois.DefDoc->Subject!="",". ","")+
                I2("Autogenerated TOL static data store from set ",
                   "Almacén estático de datos TOL autogenerado a partir "
                   "del conjunto ")+name},
      {keys=Ois.DefDoc->Keys+If(Ois.DefDoc->Keys!=""," ","")+"Ois.Store"},
      {abstract=Ois.DefDoc->Abstract},
      {authors=Ois.DefDoc->Authors},
      {distribution=Ois.DefDoc->Distribution},
      {repository=Ois.DefDoc->Repository}
    )
  )
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(I2(
"Creates a static OIS image of an arbitrary Set of TOL objects.\n"
"No referential integrity check will be allowed for these OIS images.\n"
"You can specify a usual relative or absolute path and also a default OIS "
"abolute path begining by \"ois:/\" that will be replaced by the value of "
"Text Ois.DefRoot variable.\n"
"In order to use the method of macro-compression in only a compact file, "
"is enough with passing to Ois.Store a location to him with the extension "
".oza. To use the micro-compression method it is had to pass a location "
"without extension.",
"Crea una imagen OIS estática de un conjunto arbitrario de objetos TOL sobre "
"la que no se podrá hacer ningún chequeo de integridad referencial.\n"
"Se puede especificar un camino usual relativo o absoluto o también un camino "
"absoluto por defecto de OIS empezando por \"ois:/\" lo cual será reemplazado "
"por el contenido de la variable Text Ois.DefRoot.\n"
"Para utilizar el método de macro-compresión en un sólo archivo compacto, "
"basta con pasarle a Ois.Store una ubicación con la extensión .oza, y para "
"usar el método de micro-compresión se ha de pasar una ubicación sin extensión."),
Ois.Store);
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
  Text Ois.CheckUpdCaducity(Text tolFile, Real caducityDays)
//////////////////////////////////////////////////////////////////////////////
{
  Real oisUpdt  = Ois.CheckIsUpdated(tolFile);
  Date oisTime  = Ois.GetModuleTime (tolFile);
  Real obsolete = If(oisUpdt & (DateDif(Daily, oisTime, Now)<=caducityDays), 0,  
                     Ois.RemoveModule(tolFile));
  tolFile
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(I2(
"If the OIS image of a module corresponding to a .tol file is not updated or "
"has passed the term of lapsing specified from its creation, then it "
"destroys the image so that it returns to be reconstructed in the next load.\n"
"It gives back to the own file .tol so that it can be used as filter of "
"Ois.UseModule function:\n" 
"  Set Ois.UseModule(Ois.CheckUpdCaducity(tolFile,caducityDays))",
"Si la imagen OIS de un módulo correspondiente a un fichero .tol no está "
"actualizada o ha transcurrido el plazo de caducidad especificado desde su "
"creación entonces se destruye la imagen para que vuelva a ser reconstruida "
"en la próxima carga. Devuelve el propio fichero .tol para que pueda usarse "
"como filtro de la función Ois.UseModule:\n"
"  Set Ois.UseModule(Ois.CheckUpdCaducity(tolFile,caducityDays))"), 
Ois.CheckUpdCaducity);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
  Text Ois.GetAddress(Text root, Ois.AddressStr address)
//////////////////////////////////////////////////////////////////////////////
{
  Text r0 = Replace(root,            "\\","/");
  Text c0 = Replace(address->Concept,"\\","/");
  Text v0 = Replace(address->Version,"\\","/");
  Text n0 = Replace(address->Node,   "\\","/");
  Text r  = If(Or(r0=="",TextEndAt(r0,"/")),r0,r0+"/");
  Text c  = If(Or(c0=="",TextEndAt(c0,"/")),c0,c0+"/");
  Text v  = If(Or(v0=="",TextEndAt(v0,"/")),v0,v0+"/");
  Text n  = If(Or(n0=="",TextEndAt(n0,"/")),n0,n0+"/");
  r+c+v+Sub(n,1,TextLength(n)-1)
};
//////////////////////////////////////////////////////////////////////////////
PutDescription(I2(
"Returns the standard path corresponding to an OIS address starting in a "
"given root.",
"Devuelve el camino estándar correspondiente a una dirección OIS a partir de "
"una raíz dada."), 
Ois.GetAddress);
//////////////////////////////////////////////////////////////////////////////
