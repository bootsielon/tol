/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : BaseC2.LinComb.tol
// PURPOSE: Defines class @BaseC2.LinComb
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.BaseC2.LinComb = "Defines a new base B2 of "
"order K2 as a linear combination B2=B1*V of functions of a previous base "
"B1 of order K1>=K2. The matrix of change V must have rank K2 to ensure "
"linear independence.";
Class @BaseC2.LinComb : @BaseC2.Cache
//////////////////////////////////////////////////////////////////////////////
{
  @BaseC2 _.base; 
  VMatrix _.V;
  VMatrix _.Vi;
    Set _.aux = Copy(Empty);

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.New = "Creates an instance B2 of "
  "@BaseC2.LinComb as B2 = B1*V";
  Static @BaseC2.LinComb New(@BaseC2 base, VMatrix V, VMatrix Vi)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real n = base::_.n;
    @BaseC2.LinComb aux = [[
      Real _.n = base::_.n;
      Real _.K = VColumns(V);
      @BaseC2 _.base = base; 
      VMatrix _.V = V; 
      VMatrix _.Vi = Vi
  ]]};

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.Orthogonal = "Creates an instance of "
  "@BaseC2.LinComb that is orthonormal for given points and has exactly K "
  "elements";
  Static @BaseC2.LinComb Orthogonal(
    @BaseC2 base, 
    Real K, 
    VMatrix u)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set range.K = Range(1,K,1);
    Real n = base::_.n;
    Real K1 = base::_.K;
    Real base::upgrade.cache(u,0,0);
    VMatrix Pu = Group("ConcatColumns", For(1, K1, VMatrix(Real k)
    {
      base::function.v(k,u)
    }));
  //WriteLn("TRACE [@BaseC2.LinComb Compact.K] Pu:"<<Pu);
    Set Pu.svd = SVD(VMat2Mat(Pu));

    Matrix Pu.eigenvalue = Tra(SubDiag(Pu.svd[2],0));
    VMatrix V = Mat2VMat(SubCol(Pu.svd[3],range.K));
    VMatrix D = Eye(K,K,0,RPow(Mat2VMat(SubRow(Pu.eigenvalue,range.K)),+1));
    VMatrix Di = Eye(K,K,0,RPow(Mat2VMat(SubRow(Pu.eigenvalue,range.K)),-1));
    VMatrix W = V*Di;
    VMatrix Wi = D*Tra(V);
    @BaseC2.LinComb new = New(base, W, Wi);
    Set new::_.aux :=
    [[
      K,n,K1,u,Pu,Pu.svd,Pu.eigenvalue,V,D,Di,W,Wi 
    ]];
    new
  };

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.Orthogonal.Rand = "Creates an instance of "
  "@BaseC2.LinComb that is orthonormal for random points and has exactly K "
  "elements";
  Static @BaseC2.LinComb Orthogonal.Rand(
    @BaseC2 base, 
    Real K)
  ////////////////////////////////////////////////////////////////////////////
  {
    Orthogonal(base,K,Gaussian(10*base::_.K, base::_.n, 0, 1))
  };

  ////////////////////////////////////////////////////////////////////////////
  Real _build.cache(VMatrix X, Real deriv.order, Real integ.order) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    Real _.base::upgrade.cache(X,deriv.order,integ.order);
    VMatrix _.function := _.base::function.m(X)*_.V;
    Set If(deriv.order>=1, { _.partial.derivative.1 := 
      For(1, _.n, VMatrix(Real i)
      { 
        _.base::partial.derivative.1.m(X,i)*_.V 
      })
    });
    Set If(deriv.order>=2, { _.partial.derivative.2 := 
      For(1, _.n, Set(Real i)
      { 
        For(1, i, VMatrix(Real j)
        { 
          _.base::partial.derivative.2.m(X,i,j)*_.V 
        })
      })
    });
    Set If(integ.order>=1, { _.partial.integrate.1 := 
      For(1, _.n, VMatrix(Real i)
      { 
        _.base::partial.integrate.1.m(X,i)*_.V 
      })
    });
    True
  }

};
