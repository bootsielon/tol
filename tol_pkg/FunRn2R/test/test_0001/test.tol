/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : test.tol
// PURPOSE: Package MulVarFunAprox test
//////////////////////////////////////////////////////////////////////////////

Text email_ = "vdebuen@tol-project.org"; 
Text link_ = ""; 
Text summary_ = "Test for mutivariant function aproximation";

//Write here the initial test TOL code if needed
Real numErr0 = Copy(NError);
Real numWar0 = Copy(NWarning);

//Random seed setting
Real PutRandomSeed(21224047);
Real rndSeed = GetRandomSeed(0);
WriteLn("Current Random Seed = "<<rndSeed);

//#Require FunRn2R;
#Embed "../../FunRn2R.tol";

Real n = 2;
Real m = 1000;
Real maxDeg = 16;
Real informationRatio = 0.99;

VMatrix X = Rand(m,n,-1,1);

FunRn2R::@BaseC2.Monomial B1 = 
  FunRn2R::@BaseC2.Monomial::New(n,maxDeg);

Real K1 = B1::_.K;

FunRn2R::@FunC2 f1 = FunRn2R::@FunC2.InBaseC2::Random(B1, 1);

VMatrix F1 = f1::eval.function.v(X);

VMatrix u1 = f1::_.linComb;

FunRn2R::@BaseC2.LinComb B2 = 
  FunRn2R::@BaseC2.LinComb::Compact.Ratio(B1, informationRatio);

Real K2 = B2::_.K;

VMatrix u2 = B2::_.Vi*u1;

FunRn2R::@FunC2 f2 = FunRn2R::@FunC2.InBaseC2::New(B2, u2);

Real B2::upgrade.cache(X,0,0);

VMatrix F2 = f2::eval.function.v(X);

VMatrix F.cmp = F1 | F2;
VMatrix E = F1 - F2;

Real E.avr = VMatAvr(E);
Real E.ste = VMatStDs(E);

Real quality = Min(1,Max(0,(1-informationRatio)/E.ste));
Real numErr1 = Copy(NError);
Real numWar1 = Copy(NWarning);

Set partialResults_ = [[numErr0, numErr1, 
                        quality]];

//This is a messure of the success of the test 
Real quality_ = And(numErr1 == numErr0, 
                    numWar1 == numWar0)*quality;

//Return the results 
Set resultStr_ = @strTestStatus(summary_, link_, quality_,
                  "Partial results = "<<partialResults_,
                  "NO DBServerType", "NO DBServerHost", "NO DBAlias",
                  email_);
WriteLn(""<<resultStr_);
resultStr_;

/* */

