  /* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : GisTools.tol
// PURPOSE: Defines Package GisTools
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
NameBlock GisTools = [[
//////////////////////////////////////////////////////////////////////////////

#Require MatQuery;

Text _.autodoc.description = "Functions and classes related with "
"Geographic Information System (GIS), with all type of methods "
"over large matricial geographical points.";
Text _.autodoc.url = "";
Set _.autodoc.keys = [["GIS","Geographic","point","distance"]];
Set _.autodoc.authors = [[
   "vdebuen@tol-project.org"   ]];

//////////////////////////////////////////////////////////////////////////////
//Abstract class to handle with a bidimensional point.
Class @Point2D
//////////////////////////////////////////////////////////////////////////////
{
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.numberOfPoints = 
  "Returns the number of stored points";
  Real numberOfPoints(Real void);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.x = 
  "Returns the first coordinate of the k-th point";
  Real x(Real k);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.y = 
  "Returns the second coordinate of the k-th point";
  Real y(Real k)
  ////////////////////////////////////////////////////////////////////////////
};

//////////////////////////////////////////////////////////////////////////////
//Class to handle with just one bidimensional point that
//isn´t externally stored
Class @Point2D.Simple : @Point2D
//////////////////////////////////////////////////////////////////////////////
{
  Real _.x;
  Real _.y;

  //Just one point is stored
  Real numberOfPoints(Real void) { 1 };
  //Argument k is unused
  Real x(Real k) { _.x };
  //Argument k is unused
  Real y(Real k) { _.y };
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.New = "Creates an instance of @Point2D.Simple";
  Static @Point2D.Simple New(Real x, Real y)
  ////////////////////////////////////////////////////////////////////////////
  {
    @Point2D.Simple new = [[
      Real _.x = x;
      Real _.y = y ]];
    new
  };
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.FromRow = "Creates an instance of "
  "@Point2D.Simple using the 2 first columns of selected row of given matrix";
  Static @Point2D.Simple FromRow(VMatrix M, Real numRow)
  ////////////////////////////////////////////////////////////////////////////
  {
    @Point2D.Simple new = [[
      Real _.x = VMatDat(M,numRow,1);
      Real _.y = VMatDat(M,numRow,2) ]];
    new
  };
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.FromCol = "Creates an instance of "
  "@Point2D.Simple using the 2 first rows of selected column of given matrix";
  Static @Point2D.Simple FromCol(VMatrix M, Real numCol)
  ////////////////////////////////////////////////////////////////////////////
  {
    @Point2D.Simple new = [[
      Real _.x = VMatDat(M,1,numCol);
      Real _.y = VMatDat(M,2,numRow) ]];
    new
  }
};

//////////////////////////////////////////////////////////////////////////////
//Class to store al large set of points as rows of a matrix with 2 columns.
Class @Point2D.Stored
//////////////////////////////////////////////////////////////////////////////
{
  VMatrix _.xy;

  Real numberOfPoints(Real void) { VRows(_.xy) };
  Real x(Real k) { VMatDat(_.xy,k,1) };
  Real y(Real k) { VMatDat(_.xy,k,1) };

  @Point2D.Simple center(Real void)
  {
    Real m = VRows(_.xy);
    VMatrix c = Rand(m,1,1/m,1/m)*_.xy;
    @Point2D.Simple::New(VMatDat(c,1,1), VMatDat(c,1,2))
  };

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.New = "Creates an instance of @Point2D.Stored";
  Static @Point2D.Stored New(VMatrix xy)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(VColumns(xy)>2,
      WriteLn("[@Point2D.Stored::New] Only 2 first of "<<VColumns(xy)+
      " columns of argument xy will be used","W"));
    If(VColumns(xy)<2,
      WriteLn("[@Point2D.Stored::New] Almost 2 columns instead of "<<
      VColumns(xy)+" are needed for argument xy","E"));
    @Point2D.Stored new = [[
      VMatrix _.xy = xy ]];
    new
  }
};

//////////////////////////////////////////////////////////////////////////////
//Abstract class to inherite bidimensional interpolating classes.
Class @Interp2D
//////////////////////////////////////////////////////////////////////////////
{
  //Bidimensional points in cartesian coordinates. Dim: _.m x 2
  @Point2D.Stored _.P;
  //Tarjet data to be interpolated, Dim : _.m x _.n
  VMatrix _.F;

  ////////////////////////////////////////////////////////////////////////////
  //Auxiliar members
  ////////////////////////////////////////////////////////////////////////////
  //Number of interpolation points
  Real _.m = ?;
  //Number of independent interpolation functions.
  //When _.n==1 it´s called the scalar interpolating case
  //When _.n>=2 it´s called the vectorial interpolating case
  Real _.n = ?;

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.build = 
  "Initializes all members which are needed to build the interpolating "
  "methods";
  Real build(Real void);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.eval.vector = 
  "Evaluates all interpolation function at point x,y";
  VMatrix eval.vector(@Point2D p);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.eval = 
  "Evaluates the first interpolation function at point x,y. It's useful in "
  "the scalar case, when _.F has just one column (_.n==1)";
  Real eval(@Point2D p)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatDat(eval.vector(p),1,1)
  }
};

//////////////////////////////////////////////////////////////////////////////
//Abstract class to inherite bidimensional weighted interpolating classes.
Class @Interp2D.Gravit : @Interp2D
//////////////////////////////////////////////////////////////////////////////
{
  //In order to be more efficient, the points farther of this distance will 
  //be skipped due its weight is almost null 
  Real _.maxDistance;

  ////////////////////////////////////////////////////////////////////////////
  //Auxiliar members
  ////////////////////////////////////////////////////////////////////////////
  Set     _.point.idx = Copy(Empty);
  Set     _.x.range   = Copy(Empty);
  VMatrix _.x.class   = Rand(0,0,0,0);
  Set     _.y.range   = Copy(Empty);
  VMatrix _.y.class   = Rand(0,0,0,0);
  VMatrix _.grid.map  = Rand(0,0,0,0);
  Set     _.grid      = Copy(Empty);
  
  ////////////////////////////////////////////////////////////////////////////
  Real build(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.m := VRows(_.P::_.xy);
    Real _.n := VRows(_.F);
    If(VColumns(_.P::_.xy)!=2,
      WriteLn("Interp2D.Gravit::_.P::_.xy must have 2 columns instead "
              "of "<<VColumns(_.P::_.xy)));
    If(VRows(_.F)!=_.m,
      WriteLn("Interp2D.Gravit::_.xy must have 2 columns instead of "
              <<VColumns(_.P::_.xy)));

    Set _.point.idx := Range(1,_.m,1);
    VMatrix x = SubCol(_.P::_.xy,[[1]]);
    VMatrix y = SubCol(_.P::_.xy,[[2]]);
    Set _.x.range := Range(VMatMin(x),VMatMax(x),_.maxDistance);
    Set _.y.range := Range(VMatMin(y),VMatMax(y),_.maxDistance);
    VMatrix _.x.class := MatQuery::ClassifyRowsByRank(x,_.x.range);
    VMatrix _.y.class := MatQuery::ClassifyRowsByRank(y,_.y.range);
    Set xy.class = Classify(_.point.idx, Real(Real a, Real b)
    {
      Real x.cmp = Compare(VMatDat(_.x.class,a,1),VMatDat(_.x.class,b,1));
      If(x.cmp, x.cmp,
      Real y.cmp = Compare(VMatDat(_.y.class,a,1),VMatDat(_.y.class,b,1)))
    });
    Set _.grid := For(1,Card(_.x.range)+1,Set(Real i)
    {
      For(1,Card(_.y.range)+1,Set(Real j)
      {
        Copy(Empty)
      })
    });
    VMatrix _.grid.map := Group("ConcatRows",EvalSet(xy.class, VMatrix(Set cl)
    {
      Real k = cl[1];
      Real x.class = VMatDat(_.x.class,k,1);
      Real y.class = VMatDat(_.y.class,k,1);
      Set _.grid[x.class][y.class] := cl;
      SetRow([[x.class,y.class]])
    }));
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.get.distance = 
  "Evaluates the weight between a given point p and each point of a 2 "
  "columns matrix of coordinates";
  VMatrix get.distance(@Point2D p, VMatrix xy)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real m = VRows(xy);
    VMatrix p.x = Rand(m,1,p::x(1),p::x(1));
    VMatrix p.y = Rand(m,1,p::y(1),p::y(1));
    VMatrix x = SubCol(xy,[[1]]);
    VMatrix y = SubCol(xy,[[2]]);
    RPow(RPow(x-p.x,2)+RPow(y-p.y,2),0.5)
  };
 
  ////////////////////////////////////////////////////////////////////////////
  NameBlock evaluate(@Point2D p)
  ////////////////////////////////////////////////////////////////////////////
  {[[
    VMatrix p.x = Rand(1,1,p::x(1),p::x(1));
    VMatrix p.y = Rand(1,1,p::y(1),p::y(1));
    VMatrix p.xy = p.x | p.y;
    Real p.x.class = VMatDat(MatQuery::ClassifyRowsByRank(p.x,_.x.range),1,1);
    Real p.y.class = VMatDat(MatQuery::ClassifyRowsByRank(p.y,_.y.range),1,1);
    Real i.min = Max(1,p.x.class-1);
    Real i.max = Min(Card(_.x.range)+1,p.x.class+1);
    Real j.min = Max(1,p.y.class-1);
    Real j.max = Min(Card(_.y.range)+1,p.y.class+1);
    Set p.candidates = BinGroup("<<",For(i.min, i.max, Set(Real i)
    {
      BinGroup("<<",For(j.min, j.max, Set(Real j)
      {
        _.grid[i][j]  
      }))
    }));
    VMatrix xy.candidates = SubRow(_.P::_.xy, p.candidates);
    VMatrix d.candidates = get.distance(p,xy.candidates);
    Set neighborhood = MatQuery::SelectRowsInInterval(d.candidates, 
      False, 0, _.maxDistance, True);
    Matrix d = VMat2Mat(SubRow(d.candidates, neighborhood));
    VMatrix v = Mat2VMat(RPow(d,2));
    VMatrix w = v/VMatSum(v);
    VMatrix f = Tra(w) * SubRow(SubRow(_.F,p.candidates),neighborhood)
  ]]};
  ////////////////////////////////////////////////////////////////////////////
  VMatrix eval.vector(@Point2D p)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix p.x = Rand(1,1,p::x(1),p::x(1));
    VMatrix p.y = Rand(1,1,p::y(1),p::y(1));
    VMatrix p.xy = p.x | p.y;
    Real p.x.class = VMatDat(MatQuery::ClassifyRowsByRank(p.x,_.x.range),1,1);
    Real p.y.class = VMatDat(MatQuery::ClassifyRowsByRank(p.y,_.y.range),1,1);
    Real i.min = Max(1,p.x.class-1);
    Real i.max = Min(Card(_.x.range)+1,p.x.class+1);
    Real j.min = Max(1,p.y.class-1);
    Real j.max = Min(Card(_.y.range)+1,p.y.class+1);
    Set p.candidates = BinGroup("<<",For(i.min, i.max, Set(Real i)
    {
      BinGroup("<<",For(j.min, j.max, Set(Real j)
      {
        _.grid[i][j]  
      }))
    }));
    VMatrix xy.candidates = SubRow(_.P::_.xy, p.candidates);
    VMatrix d.candidates = get.distance(p,xy.candidates);
    Set neighborhood = MatQuery::SelectRowsInInterval(d.candidates, 
      False, 0, _.maxDistance, True);
    Matrix d = VMat2Mat(SubRow(d.candidates, neighborhood),1);
    VMatrix v = Mat2VMat(RPow(d,2));
    VMatrix w = v/VMatSum(v);
    w * SubRow(SubRow(_.F,p.candidates),neighborhood)
  };

  Static Text _.autodoc.member.New = "Creates an instance of "
  "@Interp2D.Gravit";

  Static @Interp2D.Gravit New(VMatrix XY, VMatrix F, Real maxDistance)
  {
    @Interp2D.Gravit new =
    [[
      @Point2D.Stored _.P = @Point2D.Stored::New(XY);
      VMatrix _.F = F;
      Real _.maxDistance = maxDistance
    ]]
  }
}

]];


