  /* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : Interp2D.tol
// PURPOSE: Defines Class GisTools::@Interp2D and inherited classes
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//Abstract class to inherite bidimensional interpolating classes.
Class @Interp2D
//////////////////////////////////////////////////////////////////////////////
{
  //Bidimensional points in cartesian coordinates. Dim: _.m x 2
  @Point2D.Stored _.P;
  //Tarjet data to be interpolated, Dim : _.m x _.n
  VMatrix _.F;

  ////////////////////////////////////////////////////////////////////////////
  //Auxiliar members
  ////////////////////////////////////////////////////////////////////////////
  //Number of interpolation points
  Real _.m = ?;
  //Number of independent interpolation functions.
  //When _.n==1 it´s called the scalar interpolating case
  //When _.n>=2 it´s called the vectorial interpolating case
  Real _.n = ?;

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.build = 
  "Initializes all members which are needed to build the interpolating "
  "methods";
  Real build(Real void);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.eval.vector = 
  "Evaluates all interpolation function at point x,y";
  VMatrix eval.vector(@Point2D p);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.eval = 
  "Evaluates the first interpolation function at point x,y. It´s useful in "
  "the scalar case, when _.F has just one column (_.n==1)";
  Real eval(@Point2D p)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatDat(eval.vector(p),1,1)
  }
};

//////////////////////////////////////////////////////////////////////////////
//Abstract class to inherite bidimensional weighted interpolating classes.
Class @Interp2D.Gravit : @Interp2D
//////////////////////////////////////////////////////////////////////////////
{
  //In order to be more efficient, the points farther of this distance will 
  //be skipped due its weight is almost null 
  Real _.maxDistance;

  ////////////////////////////////////////////////////////////////////////////
  //Auxiliar members
  ////////////////////////////////////////////////////////////////////////////
  Set     _.point.idx = Copy(Empty);
  Set     _.x.range   = Copy(Empty);
  VMatrix _.x.class   = Rand(0,0,0,0);
  Set     _.y.range   = Copy(Empty);
  VMatrix _.y.class   = Rand(0,0,0,0);
  VMatrix _.grid.map  = Rand(0,0,0,0);
  Set     _.grid      = Copy(Empty);
  
  ////////////////////////////////////////////////////////////////////////////
  Real build(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.m := VRows(_.P::_.xy);
    Real _.n := VRows(_.F);
    If(VColumns(_.P::_.xy)!=2,
      WriteLn("Interp2D.Gravit::_.P::_.xy must have 2 columns instead "
              "of "<<VColumns(_.P::_.xy)));
    If(VRows(_.F)!=_.m,
      WriteLn("Interp2D.Gravit::_.xy must have 2 columns instead of "
              <<VColumns(_.P::_.xy)));

    Set _.point.idx := Range(1,_.m,1);
    VMatrix x = SubCol(_.P::_.xy,[[1]]);
    VMatrix y = SubCol(_.P::_.xy,[[2]]);
    Set _.x.range := Range(VMatMin(x),VMatMax(x),_.maxDistance);
    Set _.y.range := Range(VMatMin(y),VMatMax(y),_.maxDistance);
    VMatrix _.x.class := MatQuery::ClassifyRowsByRank(x,_.x.range);
    VMatrix _.y.class := MatQuery::ClassifyRowsByRank(y,_.y.range);
    Set xy.class = Classify(_.point.idx, Real(Real a, Real b)
    {
      Real x.cmp = Compare(VMatDat(_.x.class,a,1),VMatDat(_.x.class,b,1));
      If(x.cmp, x.cmp,
      Real y.cmp = Compare(VMatDat(_.y.class,a,1),VMatDat(_.y.class,b,1)))
    });
    Set _.grid := For(1,Card(_.x.range)+1,Set(Real i)
    {
      For(1,Card(_.y.range)+1,Set(Real j)
      {
        Copy(Empty)
      })
    });
    VMatrix _.grid.map := Group("ConcatRows",EvalSet(xy.class, VMatrix(Set cl)
    {
      Real k = cl[1];
      Real x.class = VMatDat(_.x.class,k,1);
      Real y.class = VMatDat(_.y.class,k,1);
      Set _.grid[x.class][y.class] := cl;
      SetRow([[x.class,y.class]])
    }));
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.get.distance = 
  "Evaluates the weight between a given point p and each point of a 2 "
  "columns matrix of coordinates";
  VMatrix get.distance(@Point2D p, VMatrix xy)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real m = VRows(xy);
    VMatrix p.x = Rand(m,1,p::x(1),p::x(1));
    VMatrix p.y = Rand(m,1,p::y(1),p::y(1));
    VMatrix x = SubCol(xy,[[1]]);
    VMatrix y = SubCol(xy,[[2]]);
    RPow(RPow(x-p.x,2)+RPow(y-p.y,2),0.5)
  };
 
  ////////////////////////////////////////////////////////////////////////////
  NameBlock evaluate(@Point2D p)
  ////////////////////////////////////////////////////////////////////////////
  {[[
    VMatrix p.x = Rand(1,1,p::x(1),p::x(1));
    VMatrix p.y = Rand(1,1,p::y(1),p::y(1));
    VMatrix p.xy = p.x | p.y;
    Real p.x.class = VMatDat(MatQuery::ClassifyRowsByRank(p.x,_.x.range),1,1);
    Real p.y.class = VMatDat(MatQuery::ClassifyRowsByRank(p.y,_.y.range),1,1);
    Real i.min = Max(1,p.x.class-1);
    Real i.max = Min(Card(_.x.range)+1,p.x.class+1);
    Real j.min = Max(1,p.y.class-1);
    Real j.max = Min(Card(_.y.range)+1,p.y.class+1);
    Set p.candidates = BinGroup("<<",For(i.min, i.max, Set(Real i)
    {
      BinGroup("<<",For(j.min, j.max, Set(Real j)
      {
        _.grid[i][j]  
      }))
    }));
    VMatrix xy.candidates = SubRow(_.P::_.xy, p.candidates);
    VMatrix d.candidates = get.distance(p,xy.candidates);
    Set neighborhood = MatQuery::SelectRowsInInterval(d.candidates, 
      False, 0, _.maxDistance, True);
    Matrix d = VMat2Mat(SubRow(d.candidates, neighborhood));
    VMatrix v = Mat2VMat(RPow(d,2));
    VMatrix w = v/VMatSum(v);
    VMatrix f = Tra(w) * SubRow(SubRow(_.F,p.candidates),neighborhood)
  ]]};
  ////////////////////////////////////////////////////////////////////////////
  VMatrix eval.vector(@Point2D p)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix p.x = Rand(1,1,p::x(1),p::x(1));
    VMatrix p.y = Rand(1,1,p::y(1),p::y(1));
    VMatrix p.xy = p.x | p.y;
    Real p.x.class = VMatDat(MatQuery::ClassifyRowsByRank(p.x,_.x.range),1,1);
    Real p.y.class = VMatDat(MatQuery::ClassifyRowsByRank(p.y,_.y.range),1,1);
    Real i.min = Max(1,p.x.class-1);
    Real i.max = Min(Card(_.x.range)+1,p.x.class+1);
    Real j.min = Max(1,p.y.class-1);
    Real j.max = Min(Card(_.y.range)+1,p.y.class+1);
    Set p.candidates = BinGroup("<<",For(i.min, i.max, Set(Real i)
    {
      BinGroup("<<",For(j.min, j.max, Set(Real j)
      {
        _.grid[i][j]  
      }))
    }));
    VMatrix xy.candidates = SubRow(_.P::_.xy, p.candidates);
    VMatrix d.candidates = get.distance(p,xy.candidates);
    Set neighborhood = MatQuery::SelectRowsInInterval(d.candidates, 
      False, 0, _.maxDistance, True);
    Matrix d = VMat2Mat(SubRow(d.candidates, neighborhood),1);
    VMatrix v = Mat2VMat(RPow(d,2));
    VMatrix w = v/VMatSum(v);
    w * SubRow(SubRow(_.F,p.candidates),neighborhood)
  };

  Static Text _.autodoc.member.New = "Creates an instance of "
  "@Interp2D.Gravit";

  Static @Interp2D.Gravit New(VMatrix XY, VMatrix F, Real maxDistance)
  {
    @Interp2D.Gravit new =
    [[
      @Point2D.Stored _.P = @Point2D.Stored::New(XY);
      VMatrix _.F = F;
      Real _.maxDistance = maxDistance
    ]]
  }
};

