/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : Multivariate.tol
// PURPOSE: Defines Class BysVecLinReg::@Multivariate
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//Multivariate linear regression
// 
// Y = A*X + E
// 
//where
//   Y is the known output matrix dxN
//   X is the known input matrix mxN
//   A is the unknown cofficient matrix dxm
//   E is the unknown residuals matrix dxN with distribution
//     E[.,t] ~ N(0,V) for all t = 1 ... N
//     V is the instant covariance matrix mxm
//     V has an optional prior inverse Wishart W(V0,N0)
//
//Optionally it's posible to include full rak linear constraining equalities 
//over stacked columns form of coefficient matrix 
// 
//   C * vec(A) = c
//
//where
//   C is the coefficient matrix of linear equalities rx(m*d)
//   r is the number of linear equalities 
//   r < m*d
//   rank(C) = r
Class @Multivariate
//////////////////////////////////////////////////////////////////////////////
{
  Text _.desc;
  Set _.outputNames;
  Set _.inputNames;
  ////////////////////////////////////////////////////////////////////////////
  //Definition members
  ////////////////////////////////////////////////////////////////////////////
  VMatrix _.Y = Rand(0,0,0,0);    //Multivariate output matrix DxN 
  VMatrix _.X = Rand(0,0,0,0);    //Multivariate input matrix MxN
  Real _.alpha = 0;               //Prior invariant scaling factor
  Real _.W.weight = 0;            //Weight of prior Wishart freedom degrees
  Real _.W.N0 = 0;                //Prior Wishart freedom degrees
  VMatrix _.W.V0 = Rand(0,0,0,0); //Prior Wishart scale factor matrix
  
  ////////////////////////////////////////////////////////////////////////////
  //Auxiliar members
  ////////////////////////////////////////////////////////////////////////////
  //Data length
  Real _.N = ?; 
  //Number of multivariate output vectors
  Real _.d = ?; 
  //Number of multivariantinput vectors
  Real _.m = ?; 
  //multivariate residuals (dxN)
  VMatrix _.E = Rand(0,0,0,0);
  //Instant covariance of multivariate residuals (dxd)
  VMatrix _.V = Rand(0,0,0,0);
  //Regression multivariate coefficients (dxm)
  VMatrix _.A = Rand(0,0,0,0); 
  //Stacked columns of A (D*Mx1)
  VMatrix _.vec.A = Rand(0,0,0,0); 
  VMatrix _.M = Rand(0,0,0,0); 
  VMatrix _.K = Rand(0,0,0,0); 
  //Average of posterior distribution of A for alpha=0: Y*X'*(X*Xt)^-1 (dxm)
  VMatrix _.nu = Rand(0,0,0,0); 
  //Stacked columns of nu ((d*m)x1)
  VMatrix _.vec.nu = Rand(0,0,0,0); 
  //Y*Y'
  VMatrix _.Syy = Rand(0,0,0,0); 
  VMatrix _.Syx = Rand(0,0,0,0); 
  VMatrix _.Sxx = Rand(0,0,0,0); 
  VMatrix _.Sy.x = Rand(0,0,0,0); 

  //Y*X'*(X*Xt)^-1*X*Y'
  VMatrix _.nuXYt = Rand(0,0,0,0); 
  //Cholesky decomposition of X*X' as sparse factor (mxm)
  VMatrix _.X.Lf = Rand(0,0,0,0);
  //Cholesky decomposition of X*X' as sparse explicit (mxm)
  VMatrix _.X.Le = Rand(0,0,0,0);
  //Inverse of Cholesky decomposition of X*X' as sparse explicit (mxm)
  VMatrix _.X.Li = Rand(0,0,0,0);
  //Kronecker product of identity of order d by X.L ((d*m)x(d*m))
  VMatrix _.IdxXL = Rand(0,0,0,0);
  //Kronecker product of identity of order d by X.Li ((d*m)x(d*m))
  VMatrix _.IdxXLi = Rand(0,0,0,0);
  //Kronecker product of V by identity of order m ((d*m)x(d*m))
  VMatrix _.VxIm = Rand(0,0,0,0);
  //Choleski decomposition of VxIm as sparse factor((d*m)x(d*m))
  VMatrix _.VxIm.Lf = Rand(0,0,0,0);
  //Choleski decomposition of VxIm as sparse explicit((d*m)x(d*m))
  VMatrix _.VxIm.Le = Rand(0,0,0,0);

  Real maxAcceptRejectTry = 100;
  Real _.totalTry = 0;

  ////////////////////////////////////////////////////////////////////////////
  // Optional linear constraining equalities
  // 
  //   C * vec(A) = c
  // 
  //Number of linear constraining equalities
  Real _.r.C = 0;
  //Coefficient matrix of linear constraining equalities 
  VMatrix _.C = Rand(0,0,0,0);
  //Right vector of linear constraining equalities 
  VMatrix _.c = Rand(0,0,0,0);
  //Constraining equalities in standariced metric used internally
  VMatrix _.C01 = Rand(0,0,0,0);
  VMatrix _.c01 = Rand(0,0,0,0);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  // Optional arbitrary constraining inequalities
  // 
  //   G(A) >= 0
  // 
  //Number of arbitrary constraining inequalities
  Real _.r.G = 0;

  ////////////////////////////////////////////////////////////////////////////
  // Returns G(coefMat)
  // User must inherite a class redefining this method to apply 
  // arbitrary constraining inequalities and set the correct value of _.r.G
  VMatrix eval.arbitraryConstrainingInequalities(VMatrix coefMat)
  ////////////////////////////////////////////////////////////////////////////
  {
    Rand(0,1,0,0)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real check.dim(Text method, VMatrix M, Real nRow, Real nCol)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(And(VRows(M)==nRow, VColumns(M)==nCol), True,
    {
      WriteLn("[BysVecLinReg::@Multivariate::"+method+"] "
              "Incongruent dimensions of "+Name(M)+" that should be "
              "("<<nRow+","<<nCol+") instead of "
              "("<<VRows(M)+","<<VColumns(M)+")","E"); 
      False
    })
  };
  
  ////////////////////////////////////////////////////////////////////////////
  Real set.linearConstrainingEquations(VMatrix C, VMatrix c)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real r = VRows(c);
    If(Or(!check.dim("set.linearConstrainingEquations",C,r,_.m*_.d),
          !check.dim("set.linearConstrainingEquations",c,r,1      )),False,
    {
      Real _.r.C := r;
      VMatrix _.C := C; 
      VMatrix _.c := c; 
      recalc.C01c01(0)
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real set.outputInput(VMatrix Y, VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.totalTry := 0;
    Real _.d := VRows(Y);
    Real _.m := VRows(X);
    Real _.N := VColumns(X);
    Case(
    VColumns(Y)!=_.N, 
    {
      WriteLn("[BysVecLinReg::@Multivariate::set.outputInput] "
              "Incongruent rows data length between input "
              "("<<VRows(X)+","<<VColumns(X)+") "
              "and output "
              "("<<VRows(Y)+","<<VColumns(Y)+")","E"); 
      False
    },
    _.m > _.N, 
    {
      WriteLn("[BysVecLinReg::@Multivariate::set.outputInput] "
              "Too much inputs for data length "<<_.N+"<"<<_.m,"E"); 
      False
    },
    1==1, 
    {
      VMatrix _.M := Constant(_.d,_.m,0);
      VMatrix _.K := Constant(_.m,_.m,0);
      Real change.X(X);
      Real change.Y(Y);
      Real change.alpha(0);
      Real change.vec.A(_.vec.nu/(1+_.alpha));
      Real change.V(Eye(_.d));
      True
    })
  };


  ////////////////////////////////////////////////////////////////////////////
  Real set.prior.V.none(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.W.N0 := 0;
    Real _.W.weight := 0;
    VMatrix _.W.V0 := Constant(_.d,_.d,0);
    VMatrix gibbs.draw.V(0);
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real set.prior.V.inverseWishart(Real W.weight, VMatrix W.V0)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(!check.dim("set.prior.V.inverseWishart",W.V0,_.d,_.d),False,
    {
      Real _.W.N0 := Case(
      W.weight==0,0,
      W.weight>=0.99,_.N*99,
      1==1,
      {
        Max(1, _.N * W.weight / (1-W.weight))
      });
      Real _.W.weight := _.W.N0 / (_.W.N0+_.N);
      VMatrix _.W.V0 := Copy(W.V0);
      VMatrix gibbs.draw.V(0);
      True
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real change.X(VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(!check.dim("change.X",X,_.m,_.N),False,
    {
      VMatrix _.X := Copy(X); 
      VMatrix _.Sxx := MMtSqr(_.X)+_.K;
      VMatrix _.X.Lf:=CholeskiFactor(_.Sxx,"X");
      VMatrix _.X.Le := CholeskiSolve(_.X.Lf,
        Convert(_.X.Lf, "Cholmod.R.Sparse"),"P");
      VMatrix _.X.Li := CholeskiSolve(_.X.Lf,Eye(_.m),"PtL");
      VMatrix _.IdxXL := KroneckerProduct(Eye(_.d),_.X.Le);
      VMatrix _.IdxXLi := KroneckerProduct(Eye(_.d),_.X.Li);
      True
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real change.Y(VMatrix Y)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(!check.dim("change.Y",Y,_.d,_.N),False,
    {
      VMatrix _.Y := Copy(Y); 
      VMatrix _.Syy := _.Y*Tra(_.Y) + _.M*_.K*Tra(_.M);
      VMatrix _.Syx := _.Y*Tra(_.X) + _.M*_.K;
      VMatrix XYt =_.X*Tra(_.Y);
      VMatrix _.nu:=Tra(CholeskiSolve(_.X.Lf,Tra(_.Syx),"PtLLtP"));
      VMatrix _.Sy.x := _.Syy - _.nu*Tra(_.Syx);
      VMatrix _.vec.nu:=BysVecLinReg::vmatrix2vec(_.nu);
      True
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real change.alpha(Real alpha)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(alpha<0,
    {
      WriteLn("[BysVecLinReg::@Multivariate::change.alpha] "
              "scaling invariant parameter alpha must be non negative","E"); 
      False
    },
    {
      Real _.alpha := alpha;
      True
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real change.vec.A(VMatrix vec.A)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix _.vec.A := vec.A;
    VMatrix _.A := BysVecLinReg::vec2vmatrix(_.vec.A,Constant(_.d,_.m,1));
    VMatrix _.E := _.Y - _.A * _.X;
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real recalc.C01c01(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix _.C01 := Tra(_.IdxXLi*Tra(_.C))*_.VxIm.Le;
    VMatrix _.c01 := _.c - _.C * _.vec.nu;
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real change.V(VMatrix V)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(!check.dim("change.V",V,_.d,_.d),False,
    {
      VMatrix _.V := (V+Tra(V))/2; 
    //WriteLn("TRACE change.V 1");
      VMatrix _.VxIm := KroneckerProduct(_.V, Eye(_.m));
      VMatrix _.VxIm.Lf := CholeskiFactor(_.VxIm,"X");
      VMatrix _.VxIm.Le := CholeskiSolve(_.VxIm.Lf,
        Convert(_.VxIm.Lf, "Cholmod.R.Sparse"),"P");
      VMatrix _.VxIm.Lf := CholeskiFactor(_.VxIm,"X");
      VMatrix _.VxIm.Le := CholeskiSolve(_.VxIm.Lf,
        Convert(_.VxIm.Lf, "Cholmod.R.Sparse"),"P");
      If(!_.r.C, True, recalc.C01c01(0))
    })
  };


  ////////////////////////////////////////////////////////////////////////////
  Real set.maxEvidence.alpha(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix V.L = CholeskiFactor(_.V,"X");
    VMatrix aux = CholeskiSolve(V.L,_.nuXYt,"PtLLtP");
    Real trace = VMatSum(SubDiag(aux));
    Real md = _.m*_.d;
    change.alpha(md/(trace-md))
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix gibbs.draw.V(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //VMatrix W = _.Sy.x + _.W.V0*_.W.N0;
    VMatrix W = MMtSqr(_.E) + _.W.V0*_.W.N0;
    Real freDeg = _.N+_.W.N0;
    VMatrix V = Mat2VMat(RandIWishart(freDeg, VMat2Mat(W)));
    Real change.V(V);
    Copy(_.V)
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix gibbs.draw.vec.V(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix gibbs.draw.V(numSim);
    BysVecLinReg::vmatrix2vec(_.V)
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix gibbs.draw.vec.A.std(Real numSim, VMatrix C01, VMatrix c01)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE gibbs.draw.vec.A.std");
    If(!_.r.C, 
      Gaussian(_.d*_.m,1,0,1),
      BysVecLinReg::eqConstrainedStdGaussian(C01,c01))
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix try.draw.vec.A_mu_s(Real numSim, VMatrix C01, VMatrix c01, VMatrix nu, Real s)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE try.draw.vec.A_mu_s");
    Real _.totalTry := _.totalTry + 1;
    VMatrix e = gibbs.draw.vec.A.std(numSim,C01,c01)*s;
    VMatrix e.1 = _.VxIm.Le*e;
    VMatrix e.2 = Tra(Tra(e.1)*_.IdxXLi);
    (nu + e.2)/(1+_.alpha)
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix try.draw.vec.A(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
     try.draw.vec.A_mu_s(numSim,_.C01,_.c01,_.vec.nu, 1)
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix gibbs.draw.vec.A(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
  //WriteLn("TRACE gibbs.draw.vec.A 1");
    VMatrix vec.A = try.draw.vec.A(numSim);
    If(!_.r.G, 
    {
    //WriteLn("TRACE gibbs.draw.vec.A 2");
      Real change.vec.A(vec.A);
      vec.A
    },
    {
      Real match = False;
      Real _numTry = 0;
      VMatrix A = BysVecLinReg::vec2vmatrix(vec.A,_.A);
      VMatrix G.A = Rand(0,0,0,0);
      Real min.G.A = ?;
      While(And(!match,_numTry<maxAcceptRejectTry),
      {
      //WriteLn("TRACE gibbs.draw.vec.A 3");
        VMatrix G.A := eval.arbitraryConstrainingInequalities(A);
        Real min.G.A := VMatMin(G.A);
        Real match := Copy(min.G.A>0);
        VMatrix If(!match, 
        {
          VMatrix vec.A := try.draw.vec.A(numSim);
          VMatrix A     := BysVecLinReg::vec2vmatrix(vec.A,_.A)
        });
        Real _numTry := _numTry+1
      });
      If(match,
      {
      //WriteLn("TRACE [BysVecLinReg::@Multivariate::gibbs.draw.vec.A] accepted simulation "<<numSim+" with min.G.A = "<<min.G.A+" after "<<_numTry+" tries ");
      //WriteLn("TRACE [BysVecLinReg::@Multivariate::gibbs.draw.vec.A] vec.A=\n"<<VMat2Mat(vec.A));
        Real change.vec.A(vec.A);
        vec.A
      },
      {
        WriteLn("[BysVecLinReg::@Multivariate::gibbs.draw.vec.A] Too much "
        "rejected tries at simulation "<<numSim, "W");
        vec.A
      })
    }) 
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix gibbs.draw.A(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix gibbs.draw.vec.A(numSim);
    Copy(_.A)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real vec.A.position(Real i, Real j)
  ////////////////////////////////////////////////////////////////////////////
  {
    BysVecLinReg::vmatrix2vec.getPosition(i,j,_.d,_.m)
  }

}

