/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : Multivariate.tol
// PURPOSE: Defines Class BysVecLinReg::@Multivariate
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//Multivariate linear regression
// 
// Y = A*X + E
// 
//where
//   Y is the known output matrix dxN
//   X is the known input matrix mxN
//   A is the unknown cofficient matrix dxm
//   E is the unknown residuals matrix dxN with distribution
//     E[.,t] ~ N(0,V) for all t = 1 ... N
//     V is the instant covariance matrix mxm
//     V has an optional prior inverse Wishart W(V0,N0)
//
//Optionally it's posible to include full rak linear constraining equalities 
//over stacked columns form of coefficient matrix 
// 
//   C * vec(A) = c
//
//where
//   C is the coefficient matrix of linear equalities rx(m*d)
//   r is the number of linear equalities 
//   r < m*d
//   rank(C) = r
Class @Multivariate
//////////////////////////////////////////////////////////////////////////////
{
  Text _.desc;
  Set _.outputNames;
  Set _.inputNames;
  ////////////////////////////////////////////////////////////////////////////
  //Definition members
  ////////////////////////////////////////////////////////////////////////////
  VMatrix _.Y = Rand(0,0,0,0);    //Multivariate output matrix DxN 
  VMatrix _.X = Rand(0,0,0,0);    //Multivariate input matrix MxN
  Real _.alpha = 0;               //Prior invariant scaling factor
  Real _.W.weight = 0;            //Weight of prior Wishart freedom degrees
  Real _.W.N0 = 0;                //Prior Wishart freedom degrees
  VMatrix _.W.V0 = Rand(0,0,0,0); //Prior Wishart scale factor matrix
  
  ////////////////////////////////////////////////////////////////////////////
  //Auxiliar members
  ////////////////////////////////////////////////////////////////////////////
  //Data length
  Real _.N = ?; 
  //Number of multivariate output vectors
  Real _.d = ?; 
  //Number of multivariantinput vectors
  Real _.m = ?; 
  //multivariate residuals (dxN)
  VMatrix _.E = Rand(0,0,0,0);
  //Instant covariance of multivariate residuals (dxd)
  VMatrix _.V = Rand(0,0,0,0);
  //Regression multivariate coefficients (dxm)
  VMatrix _.A = Rand(0,0,0,0); 
  //Stacked columns of A (D*Mx1)
  VMatrix _.vec.A = Rand(0,0,0,0); 
  //Average of posterior distribution of A for alpha=0: Y*X'*(X*Xt)^-1 (dxm)
  VMatrix _.nu = Rand(0,0,0,0); 
  //Stacked columns of nu ((d*m)x1)
  VMatrix _.vec.nu = Rand(0,0,0,0); 
  //Y*Y'
  VMatrix _.YYt = Rand(0,0,0,0); 
  //Y*X'*(X*Xt)^-1*X*Y'
  VMatrix _.nuXYt = Rand(0,0,0,0); 
  //Cholesky decomposition of X*X' as sparse factor (mxm)
  VMatrix _.X.Lf = Rand(0,0,0,0);
  //Cholesky decomposition of X*X' as sparse explicit (mxm)
  VMatrix _.X.Le = Rand(0,0,0,0);
  //Inverse of Cholesky decomposition of X*X' as sparse explicit (mxm)
  VMatrix _.X.Li = Rand(0,0,0,0);
  //Kronecker product of identity of order d by X.L ((d*m)x(d*m))
  VMatrix _.IdxXL = Rand(0,0,0,0);
  //Kronecker product of identity of order d by X.Li ((d*m)x(d*m))
  VMatrix _.IdxXLi = Rand(0,0,0,0);
  //Kronecker product of V by identity of order m ((d*m)x(d*m))
  VMatrix _.VxIm = Rand(0,0,0,0);
  //Choleski decomposition of VxIm as sparse factor((d*m)x(d*m))
  VMatrix _.VxIm.Lf = Rand(0,0,0,0);
  //Choleski decomposition of VxIm as sparse explicit((d*m)x(d*m))
  VMatrix _.VxIm.Le = Rand(0,0,0,0);

  ////////////////////////////////////////////////////////////////////////////
  // Optional linear constraining equalities
  // 
  //   C * vec(A) = c
  // 
  //Number of linear constraining equalities
  Real _.r.C = 0;
  //Coefficient matrix of linear constraining equalities 
  VMatrix _.C = Rand(0,0,0,0);
  //Right vector of linear constraining equalities 
  VMatrix _.c = Rand(0,0,0,0);
  ////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////
  // Optional arbitrary constraining inequalities
  // 
  //   G(A) >= 0
  // 
  //Number of arbitrary constraining inequalities
  Real _.r.G = 0;

  ////////////////////////////////////////////////////////////////////////////
  // Returns G(A)
  // User must inherite a class redefining this method to apply 
  // arbitrary constraining inequalities and set the correct value of _.r.G
  VMatrix eval.arbitraryConstrainingInequalities(VMatrix A)
  ////////////////////////////////////////////////////////////////////////////
  {
    Rand(0,1,0,0)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real check.dim(Text method, VMatrix M, Real nRow, Real nCol)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(And(VRows(M)==nRow, VColumns(M)==nCol), True,
    {
      WriteLn("[BysVecLinReg::@Multivariate::"+method+"] "
              "Incongruent dimensions of "+Name(M)+" that should be "
              "("<<nRow+","<<nCol+") instead of "
              "("<<VRows(M)+","<<VColumns(M)+")","E"); 
      False
    })
  };
  
  ////////////////////////////////////////////////////////////////////////////
  Real set.linearConstrainingEquations(VMatrix C, VMatrix c)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real r = VRows(c);
    If(Or(!check.dim("set.linearConstrainingEquations",C,r,_.m*_.d),
          !check.dim("set.linearConstrainingEquations",c,r,1      )),False,
    {
      Real _.r.C := r;
      VMatrix _.C := C; 
      VMatrix _.c := c; 
      True
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real set.outputInput(VMatrix Y, VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.d := VRows(Y);
    Real _.m := VRows(X);
    Real _.N := VColumns(X);
    Case(
    VColumns(Y)!=_.N, 
    {
      WriteLn("[BysVecLinReg::@Multivariate::set.outputInput] "
              "Incongruent rows data length between input "
              "("<<VRows(X)+","<<VColumns(X)+") "
              "and output "
              "("<<VRows(Y)+","<<VColumns(Y)+")","E"); 
      False
    },
    _.m > _.N, 
    {
      WriteLn("[BysVecLinReg::@Multivariate::set.outputInput] "
              "Too much inputs for data length "<<_.N+"<"<<_.m,"E"); 
      False
    },
    1==1, 
    {
      change.X(X);
      change.Y(Y);
      change.alpha(0);
      VMatrix _.vec.A := (_.vec.nu)/(1+_.alpha);
      VMatrix _.A := vec2vmatrix(_.vec.A,Constant(_.d,_.m,1));
      change.V(Eye(_.d));
      True
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real set.prior.V.none(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real _.W.N0 := 0;
    Real _.W.weight := 0;
    VMatrix _.W.V0 := Constant(_.d,_.d,0);
    VMatrix gibbs.draw.V(0);
    True
  };

  ////////////////////////////////////////////////////////////////////////////
  Real set.prior.V.inverseWishart(Real W.weight, VMatrix W.V0)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(!check.dim("set.prior.V.inverseWishart",W.V0,_.d,_.d),False,
    {
      Real _.W.N0 := Case(
      W.weight==0,0,
      W.weight>=0.99,_.N*99,
      1==1,
      {
        Max(1, _.N * W.weight / (1-W.weight))
      });
      Real _.W.weight := _.W.N0 / (_.W.N0+_.N);
      VMatrix _.W.V0 := Copy(W.V0);
      VMatrix gibbs.draw.V(0);
      True
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real change.X(VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(!check.dim("change.X",X,_.m,_.N),False,
    {
      VMatrix _.X := Copy(X); 
      VMatrix _.X.Lf:=CholeskiFactor(_.X,"XXt");
      VMatrix _.X.Le := CholeskiSolve(_.X.Lf,
        Convert(_.X.Lf, "Cholmod.R.Sparse"),"P");
      VMatrix _.X.Li := CholeskiSolve(_.X.Lf,Eye(_.m),"PtL");
      VMatrix _.IdxXL := KroneckerProduct(Eye(_.d),_.X.Le);
      VMatrix _.IdxXLi := KroneckerProduct(Eye(_.d),_.X.Li);
      True
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real change.Y(VMatrix Y)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(!check.dim("change.Y",Y,_.d,_.N),False,
    {
      VMatrix _.Y := Copy(Y); 
      VMatrix _.YYt := MMtSqr(_.Y);
      VMatrix XYt =_.X*Tra(_.Y);
      VMatrix _.nu:=Tra(CholeskiSolve(_.X.Lf,XYt,"PtLLtP"));
      VMatrix _.nuXYt := _.nu*XYt;
      VMatrix _.vec.nu:=vmatrix2vec(_.nu);
      True
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real change.alpha(Real alpha)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(alpha<0,
    {
      WriteLn("[BysVecLinReg::@Multivariate::change.alpha] "
              "scaling invariant parameter alpha must be non negative","E"); 
      False
    },
    {
      Real _.alpha := alpha;
      True
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real change.V(VMatrix V)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(!check.dim("change.V",V,_.d,_.d),False,
    {
      VMatrix _.V := (V+Tra(V))/2; 
      VMatrix _.VxIm := KroneckerProduct(_.V, Eye(_.m));
      VMatrix _.VxIm.Lf := CholeskiFactor(_.VxIm,"X");
      VMatrix _.VxIm.Le := CholeskiSolve(_.VxIm.Lf,
        Convert(_.VxIm.Lf, "Cholmod.R.Sparse"),"P");
      VMatrix _.VxIm.Lf := CholeskiFactor(_.VxIm,"X");
      VMatrix _.VxIm.Le := CholeskiSolve(_.VxIm.Lf,
        Convert(_.VxIm.Lf, "Cholmod.R.Sparse"),"P");
      True
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Real set.maxEvidence.alpha(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix V.L = CholeskiFactor(_.V,"X");
    VMatrix aux = CholeskiSolve(V.L,_.nuXYt,"PtLLtP");
    Real trace = VMatSum(SubDiag(aux));
    Real md = _.m*_.d;
    change.alpha(md/(trace-md))
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix gibbs.draw.V(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix _.E := _.Y - _.A * _.X;
    VMatrix S2 = MMtSqr(_.E);
    VMatrix W = S2 + _.W.V0*_.W.N0;
    Real freDeg = _.N+_.W.N0;
    VMatrix V = Mat2VMat(RandIWishart(freDeg, VMat2Mat(W)));
    Real change.V(V);
    Copy(_.V)
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix gibbs.draw.vec.V(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix gibbs.draw.V(numSim);
    vmatrix2vec(_.V)
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix gibbs.draw.vec.A.std(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(!_.r.C, Gaussian(_.d*_.m,1,0,1),
    {
      VMatrix C = Tra(_.IdxXLi*Tra(_.C))*_.VxIm.Le;
      VMatrix c = _.c - _.C * _.vec.nu;
      eqConstrainedStdGaussian(C,c)
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix gibbs.draw.vec.A(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix e = gibbs.draw.vec.A.std(numSim);
    VMatrix e.1 = _.VxIm.Le*e;
    VMatrix e.2 = Tra(Tra(e.1)*_.IdxXLi);
    VMatrix _.vec.A := (_.vec.nu + e.2)/(1+_.alpha);
    _.vec.A
  };

  ////////////////////////////////////////////////////////////////////////////
  VMatrix gibbs.draw.A(Real numSim)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix gibbs.draw.vec.A(numSim);
    VMatrix _.A := vec2vmatrix(_.vec.A,_.A);
    Copy(_.A)
  };

  ////////////////////////////////////////////////////////////////////////////
  Real vec.A.position(Real i, Real j)
  ////////////////////////////////////////////////////////////////////////////
  {
    vmatrix2vec.getPosition(i,j,_.d,_.m)
  }

}

