/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : test.tol
//////////////////////////////////////////////////////////////////////////////


Text email_ = "vdebuen@tol-project.org"; 
Text link_ = "";
Text summary_ = 
"test_0003 multivariate linear model with unknown covariance matrix and "
"constraining linear equalities" ;

Real numErr0 = Copy(NError);

#Require BysVecLinReg;
//Se generará un modelo con r.eq restricciones de igualdad lineales
Real r.eq = 3;
Real rndSeed = 792466945;
#Embed "../gen_multivariant_linear_regression.tol";


BysVecLinReg::@Multivariate MV = [[
  Text _.desc = summary_;
  Set _.outputNames = For(1,d,Text(Real i) { "Output_"<<i });
  Set _.inputNames = For(1,m,Text(Real i) { "Input_"<<i })
]];

Real MV::set.outputInput(Y,X);

Real MV::set.prior.V.none(0);
//Real MV::set.prior.V.inverseWishart(0.50, Eye(d)*0.8);

Real MV::set.linearConstrainingEquations(C, c);

//VMatrix vec.A_ = MV::gibbs.draw.vec.A(0);
//VMatrix C.dist = C*vec.A_ - c;
//Real quality.C = Max(0, 1 - VMatMax(Abs(C.dist)));

VMatrix mcmc = Group("ConcatRows", For(1,sampleLength,VMatrix(Real numSim)
{
  If(!(numSim%100), 
    WriteLn("  Simulation "<<numSim+" of "<<sampleLength+" ["+Time+"]") );
  Tra(MV::gibbs.draw.vec.A(numSim)) |
  Tra(MV::gibbs.draw.vec.V(numSim))
}));

//////////////////////////////////////////////////////////////////////////////
//Standard report
//////////////////////////////////////////////////////////////////////////////

Set report = { 
  BysMcmc::@Config cfg = BysMcmc::@Config::Default(0);
  BysMcmc::Inference::report(
  MV::_.desc, 
  Set colNames_ = SetConcat(For(1,MV::_.m,Set(Real j)
  {
    For(1,MV::_.d,Text(Real i)
    {
      "linblk_a_"<<i<<"_"<<j+"_"+MV::_.outputNames[i]+"_"+MV::_.inputNames[j]
    })
  })) << SetConcat(For(1,MV::_.d,Set(Real j)
  {
    For(1,MV::_.d,Text(Real i)
    {
      "sigblk_s_"<<i<<"_"<<j+"_"+MV::_.outputNames[i]+"_"+MV::_.outputNames[j]
    })
  })),
  Set BysMcmc::@BysInf.Report.Config
  (
    cfg::report.raftery.diag.q,
    cfg::report.raftery.diag.r,
    cfg::report.raftery.diag.s,
    cfg::report.raftery.diag.eps,
    cfg::report.acf.lag,
    cfg::report.histogram.parts,
    cfg::report.kerDens.points
  ),
  Matrix VMat2Mat(mcmc))};

//////////////////////////////////////////////////////////////////////////////
//Reporting about average of simulations
//////////////////////////////////////////////////////////////////////////////
VMatrix avg = Tra(Constant(1,sampleLength,1/sampleLength)*mcmc);
VMatrix vec.A_ = BysVecLinReg::vmatrix2vec(
  SubRow(avg,Range(1,MV::_.m * MV::_.d,1)));
VMatrix vec.V_ = BysVecLinReg::vmatrix2vec(
  SubRow(avg,Range(MV::_.m * MV::_.d+1,VRows(avg),1)));

VMatrix A_ = BysVecLinReg::vec2vmatrix(vec.A_,MV::_.A);
VMatrix V_ = BysVecLinReg::vec2vmatrix(vec.V_,MV::_.V);
VMatrix V_.L = CholeskiFactor(V_,"X");
VMatrix V_.Le = CholeskiSolve(V_.L, Convert(V_.L, "Cholmod.R.Sparse"),"P");

//Instant residuals correlation
VMatrix V.COR_ = Mat2VMat(NormDiag(VMat2Mat(V_)));

VMatrix E_ = Y - A_*X;
VMatrix E.S2_ = MMtSqr(E_);
VMatrix E.COV_ = E.S2_/N;
VMatrix E.COR_ = Mat2VMat(NormDiag(VMat2Mat(E.S2_)));
VMatrix E01_ = CholeskiSolve(V_.L,E_,"PtL");

VMatrix cmpA = BysVecLinReg::vmatrix2vec(A) |
               BysVecLinReg::vmatrix2vec(A_); 
VMatrix cmpV = BysVecLinReg::vmatrix2vec(V) |
               BysVecLinReg::vmatrix2vec(V_) |
               BysVecLinReg::vmatrix2vec(E.COV) |
               BysVecLinReg::vmatrix2vec(E.COV_); 
VMatrix cmpE = BysVecLinReg::vmatrix2vec(E) |
               BysVecLinReg::vmatrix2vec(E_); 
VMatrix cmpE01 = BysVecLinReg::vmatrix2vec(E01) |
                 BysVecLinReg::vmatrix2vec(E01_); 

Real stdErr01_ = VMatAvr(E01_^2);
Real quality.adjust = Min(1,Exp((stdErr01-stdErr01_)*N*d));


VMatrix C.dist = C*vec.A - c;
Real quality.C = Max(0, 1 - VMatMax(Abs(C.dist)));

Real numErr1 = Copy(NError);

//Extented information about test behaviour
Set partialResults_ = 
[[
  numErr0, numErr1, stdErr01, stdErr01_, quality.adjust, quality.C
]];

Real quality_ = And(numErr0==numErr1)*quality.adjust*quality.C;

//Return the results 
Set resultStr_ = @strTestStatus(summary_, link_, quality_,
                  "Partial results = "<<partialResults_,
                  "NO DBServerType", "NO DBServerHost", "NO DBAlias",
                  email_);
WriteLn(""<<resultStr_);
resultStr_

/* */


/* */
