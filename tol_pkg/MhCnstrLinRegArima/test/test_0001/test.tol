/////////////////////////////////////////////////////////////////////////////
// FILE: test_01.tol
// PURPOSE: Checking class MhCnstrLinRegArima::@Simulator
/////////////////////////////////////////////////////////////////////////////

Text email_ = "vdebuen@tol-project.org"; 
Text link_ = ""; 
Text summary_ = "checking class MhCnstrLinRegArima::@Simulator";

//Write here the initial test TOL code if needed
Real numErr0 = Copy(NError);
Real numWar0 = Copy(NWarning);

/////////////////////////////////////////////////////////////////////////////
//A model will be randomly generated by means of reverse engineering 
/////////////////////////////////////////////////////////////////////////////

//Random seed setting
Real PutRandomSeed(0);
Real rndSeed = GetRandomSeed(0);
WriteLn("Current Random Seed = "<<rndSeed);

#Embed "../../_MhCnstrLinRegArima.tol";

/////////////////////////////////////////////////////////////////////////////
//MCMC method configuration parameters
/////////////////////////////////////////////////////////////////////////////
//Number of Markov chains that will be used in Gelman test
Real ChainNumber = 5;

//Number of initial max-loglikelihood steps in order to speed up convergence
Real MLHSteps = 0;
//Length of MCMC
Real SampleLength = 500;

/////////////////////////////////////////////////////////////////////////////
//Model configuration parameters
/////////////////////////////////////////////////////////////////////////////
//Number of variables of each observational node
Real n = 2;
//Data length of each observational node
Real m  = IntRand(100, 400);
//Number of inequations
Real r = IntRand(0,2*n);
//Enables/disables full ARIMA components
Real enableARMA = IntRand(0,1);
//Seasonal periodicity
Real S = 7;
//Regular AR Degree
Real p1 = enableARMA*IntRand(0,2);
//Seasonal AR Degree
Real pS = enableARMA*IntRand(1,1);
//Regular AR Degree
Real q1 = enableARMA*IntRand(0,Max(0,2-p1));
//Seasonal AR Degree
Real qS = enableARMA*0*IntRand(0,Max(0,1-pS));


/////////////////////////////////////////////////////////////////////////////
//Model components
/////////////////////////////////////////////////////////////////////////////
//Input matrix
//VMatrix X = Rand(m,n,-0.5,0.5,"Cholmod.R.Sparse",m*n*Rand(.20,.30));

VMatrix X = 
{
  Matrix aux.1 = 
  {
    Real avr = Rand(-10, 10);
    Rand(m,1,avr,avr)
  };
  Matrix aux.2 = Group("ConcatColumns",For(2,n,Matrix(Real j)
  {
    Real avr = Rand(-10, 10);
    Real sig = Rand(2, 4);
    Gaussian(m,1,avr,sig)
  }));
  Matrix rand = Rand(m,n-1,0,1);
  Matrix sparsity = Rand(m,n-1,0.2,0.2);
  Matrix zero = Rand(m,n-1,0,0);
  Mat2VMat(aux.1 | IfMat(LT(rand,sparsity), aux.2, zero))
};


//Linear parameters
VMatrix b  = Rand(n,1,1,1);

//Standard deviation
Real s = Rand(0.1,0.4);
//Variance
Real s2 = s^2;

//ARIMA strucure
Polyn ar1 = RandStationary(p1);
Polyn arS = RandStationary(pS,S);
Polyn ma1 = RandStationary(q1);
Polyn maS = RandStationary(qS,S);
Polyn dif1 = (1-B)  ^If(enableARMA & (Coef(ma1,1)<-0.9),1,0);
Polyn difS = (1-B^S)^If(enableARMA & (Coef(maS,1)<-0.9),1,0);
Set Arima = SetOfSet
(
  @ARIMAStruct(1,ar1,ma1,dif1),
  @ARIMAStruct(S,arS,maS,difS)
);
Polyn ar  = ar1  * arS;
Polyn ma  = ma1  * maS;
Polyn dif = dif1 * difS;
Polyn ari = ar*dif;
Real p   = Degree(ari);
Real q   = Degree(ma);

//Standard residuals and ARIMA noise
VMatrix e_  = Gaussian(100*m,1,0,s);
VMatrix z_  = DifEq(ma/ari, e_, Rand(q,1,0,0), Rand(p,1,0,0));
VMatrix e   = Sub(e_, 99*m+1, 1, m, 1);
VMatrix z   = Sub(z_, 99*m+1, 1, m, 1);
//Sample standard error
Real   sse = VMatStDs(e);

//Real filter
VMatrix F = X*b;

//Output data
VMatrix Y = If(n, X*b + z, z);

VMatrix YF_cmp = Y | F;
VMatrix ez_cmp = e | z;

//Initial values for distinct Markov chains are created before inequations to
//ensure by construction that are all feasible
Set b0 = For(1,ChainNumber, VMatrix(Real k) { b+Gaussian(n,1,0,10*s) });
//Inequation coefficients
VMatrix A = Rand(r,n,-10,10);
//Inequation border
VMatrix a = If(!r, Rand(r,1,0,0),
{
  Set Ab_ = EvalSet([[b]]<<b0,VMatrix(VMatrix b_) { A*b_ });
  Rand(r,1,2,10)+Group("Max",Ab_)
});

//Simulation handler
MhCnstrLinRegArima::@Simulator mclra = 
  MhCnstrLinRegArima::@Simulator::New(
    VMatrix Y,      //Output matrix
    VMatrix X,      //Input matrix
    VMatrix A,      //Coefficients of inequation
    VMatrix a,      //Border of inequation
    Real    s2,     //Residuals variance
    Polyn   ar,     //Autoregressive polynomial
    Polyn   ma,     //Moving average polynomial
    Polyn   dif     //Difference and deterministic structure
  );

//Disabling tuner effects
//Real mclra::_.gFactor := 1;

//Markov chain processes for each initial value
Set MCMC = EvalSet(b0, Matrix(VMatrix b0_)
{
  WriteLn("Initializing Markov Chain ...");
  Real mclra::_.gInitial := s/2;
  Real mclra::initialize(b0_);
  Matrix mcmc  = Rand(0,mclra::_.n,0,0);
  Matrix cache = Rand(0,mclra::_.n,0,0);
  While(Rows(mcmc)<SampleLength,
  {
    Real If(Rows(mcmc) < MLHSteps,
       mclra::maxLikelihoodStep(10),
       mclra::try(False));
    Matrix cache := cache << VMat2Mat(mclra::_.b,True);
    Real If(Rows(cache)==100, 
    {
      Matrix mcmc := mcmc << cache;
      Matrix cache := Rand(0,mclra::_.n,0,0);
      1
    });
    True 
  });
  mcmc
});

Set Include("test_circle.tol");
Set Include("test_bsr.tol");

//Chart circle on real target beta and MCMC´s all together odd pairs against
Matrix mcmc = circle | bsr.mcmc | Group("ConcatColumns",MCMC);

Set gelman.diag = RCODA::gelman.diag(MCMC,{[[
  Real verbose=TRUE, 
  Real varByCol=TRUE, 
  Real confidence=0.95, 
  Real transform=FALSE, 
  Real autoburnin=TRUE]]});


Real numErr1 = Copy(NError);
Real numWar1 = Copy(NWarning);

Set partialResults_ = [[numErr0, numErr1]];

//This is a messure of the success of the test 
Real quality_ = And(numErr1 == numErr0, 
                    numWar1 == numWar0);

//Return the results 
Set resultStr_ = @strTestStatus(summary_, link_, quality_,
                  "Partial results = "<<partialResults_,
                  "NO DBServerType", "NO DBServerHost", "NO DBAlias",
                  email_);
WriteLn(""<<resultStr_);
resultStr_;

/* */

