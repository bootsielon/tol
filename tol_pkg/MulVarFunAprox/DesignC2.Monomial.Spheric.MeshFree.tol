/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : DesignC2.Monomial.Spheric.MeshFree.tol
// PURPOSE: Defines Class @DesignC2.Monomial.Spheric.MeshFree
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.DesignC2.Monomial.Spheric.MeshFree.tol = 
"";
Class @DesignC2.Monomial.Spheric.MeshFree : 
  @DesignC2.Monomial, 
  @DesignC2.Spheric
//////////////////////////////////////////////////////////////////////////////
{
//////////////////////////////////////////////////////////////////////////////
//Configuration parameters
//////////////////////////////////////////////////////////////////////////////
  MatQuery::@ANN.KDTree _.ann;
  Real stress.maxDistance;

//////////////////////////////////////////////////////////////////////////////
//Auxiliar members
//////////////////////////////////////////////////////////////////////////////
  VMatrix _.R =Rand(0,0,0,0);
  MatQuery::@KNN.Neighbourhood _.ngbh;

  ////////////////////////////////////////////////////////////////////////////
  Static @DesignC2.Monomial.Spheric.MeshFree New(
    VMatrix X, 
    Real maxNeighbour,
    Real stress.maxDistance_,
    Real radius.margin)
  ////////////////////////////////////////////////////////////////////////////
  {
    @DesignC2.Monomial.Spheric.MeshFree new =
    [[ 
      VMatrix _.X = X;
      Real _.n = VColumns(X);
      Real _.J = VRows(X);
      Real _.X.maxNeighbour = maxNeighbour+1;
      Real stress.maxDistance = stress.maxDistance_;
      Real _.radius.margin = radius.margin;
      MatQuery::@ANN.KDTree _.ann = 
        MatQuery::@ANN.KDTree::New(VMat2Mat(X));
      MatQuery::@KNN.Neighbourhood _.ngbh =
        _.ann::search(_.ann::_.X,_.X.maxNeighbour)
    ]] 
  };

  //////////////////////////////////////////////////////////////////////////////
  Real build.reference.points(Real void)
  //////////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[@DesignC2.Monomial.Spheric.MeshFree::build.reference.points] ";
    VMatrix _.Y := _.X;
    Real _.H := VRows(_.Y);
    VMatrix _.R := 
      Mat2VMat(Sqrt(SubCol(_.ngbh::_.distance2,[[_.X.maxNeighbour]])))*
      (1+Min(0,_.radius.margin));
    VMatrix _.Yj := Constant(_.H,1,_.X.maxNeighbour-1);
    _.H
  };

  //////////////////////////////////////////////////////////////////////////////
  Real build.stress.points(Real void)
  //////////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[@DesignC2.Monomial.Spheric.MeshFree::build.stress.points] ";
    Real _.Z.maxNeighbour := If(prior.Z.order>=0,2,0);
    If(!_.Z.maxNeighbour, 
    {
      VMatrix _.Yt := Zeros(_.H,1);
      Real _.Tz := 0
    },{
    Set Y1_ = For(2,_.X.maxNeighbour,VMatrix(Real k)
    {
      Mat2VMat(SubCol(_.ngbh::_.neighbour,[[1]]))
    });
    Set Y2_ = For(2,_.X.maxNeighbour,VMatrix(Real k)
    {
      Mat2VMat(SubCol(_.ngbh::_.neighbour,[[k]]))
    });
    Set distance_ = For(2,_.X.maxNeighbour,VMatrix(Real k)
    {
      Mat2VMat(Sqrt(SubCol(_.ngbh::_.distance2,[[k]])))
    });
    Set match_ = For(1,_.X.maxNeighbour-1,VMatrix(Real k)
    {
      And(
        LE(distance_[k], Constant(_.J,1,stress.maxDistance)),
        LT(Y1_[k],Y2_[k]))
    });
    VMatrix distance.all = Group("ConcatRows",distance_);
    VMatrix Y1.all = Group("ConcatRows",Y1_);
    VMatrix Y2.all = Group("ConcatRows",Y2_);
    VMatrix match = Group("ConcatRows",match_);
    Set sel = MatQuery::SelectMatch(match);
    VMatrix distance = SubRow(distance.all,sel);
    VMatrix Y1 = SubRow(Y1.all,sel);
    VMatrix Y2 = SubRow(Y2.all,sel);
    VMatrix _.Z.h := Y1 | Y2;
    VMatrix _.Z := (SubRow(_.Y,VCol2Set(Y1))+SubRow(_.Y,VCol2Set(Y2)))/2;
    Real _.Tz := VRows(_.Z);
    VMatrix Z.Y.neighbour = 
    {
      Matrix Z.t = DifEq(1/(1-B),Rand(_.Tz,1,1,1));
      Matrix Z.th = (Z.t << Z.t) | 
       VMat2Mat((SubCol(_.Z.h,[[1]])<<SubCol(_.Z.h,[[2]])));
      Matrix Z.Y.idx = PivotByRows(Z.th,Sort(Z.th,[[2]]));
      Mat2VMat(Z.Y.idx)
    };
    VMatrix aux = MatQuery::SortAndCount(SubCol(Z.Y.neighbour,[[2]]));
    VMatrix _.Yt := Triplet(VMat2Mat(SubCol(aux,[[1]])) |  
                            Rand(VRows(aux),1,1,1) | 
                            VMat2Mat(SubCol(aux,[[2]])),_.H,1);
/*
    VMatrix _.Yt := 
    {
      VMatrix aux= Group("ConcatColumns",match_);
      aux*Constant(_.X.maxNeighbour-1,1,1)
    };
*/
    Real _.Mz := Case(
      prior.Z.order< 0, 0,
      prior.Z.order==0, _.Tz,
      prior.Z.order==1, _.Tz*(1+_.n),
      prior.Z.order==2, _.Tz*(1+_.n*3/2+(1/2)*_.n^2));
    _.Tz
  })};

  //////////////////////////////////////////////////////////////////////////////
  Real build.border.points(Real void)
  //////////////////////////////////////////////////////////////////////////////
  {
    VMatrix _.Yb := Zeros(_.H,1);
    Real _.Tb := 0
  };
/*
  //////////////////////////////////////////////////////////////////////////////
    Real build.base(Real void)
  //////////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[@DesignC2.Monomial::build.base] ";
    VMatrix _.Yn := 
      Floor(Min(Rand(_.H,1,_.K0,_.K0),Max(_.Ym/min.contrast.surface,_.Ym*0+1)));
   
    Set Append(_.base, [[base.feasible]]);
    Real _.base.sel := Card(_.base);
    _.K
  };
*/
  ////////////////////////////////////////////////////////////////////////////
    VMatrix match.evaluable(VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
    MatQuery::@KNN.Neighbourhood ngbh = 
      _.ann::search(VMat2Mat(X),1);
    VMatrix Y = SubRow(_.Y,Col2Set(ngbh::_.neighbour));
    VMatrix dist = Mat2VMat(Sqrt(ngbh::_.distance2));
    VMatrix X.h = Mat2VMat(ngbh::_.neighbour);
    LE(dist,get.radius(X.h))$*
    LE(dist,Constant(VRows(dist),1,stress.maxDistance))
    
  };

  //////////////////////////////////////////////////////////////////////////////
  VMatrix closest.reference.index(VMatrix X)
  //////////////////////////////////////////////////////////////////////////////
  {
    MatQuery::@KNN.Neighbourhood ngbh = 
      _.ann::search(VMat2Mat(X),_.X.maxNeighbour);
    Mat2VMat(ngbh::_.neighbour)
  };

  //////////////////////////////////////////////////////////////////////////////
  VMatrix get.radius(VMatrix Y.idx)
  //////////////////////////////////////////////////////////////////////////////
  {
    SubRow(_.R,VCol2Set(Y.idx))
  };

  ///////////////////////////////////////////////////////////////////////////
    VMatrix generate.internal.points(Real m)
  ///////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[@DesignC2.Monomial.Spheric.MeshFree::generate.internal.points] ";
    WriteLn("TRACE "+_MID+"1 m="<<m);
    VMatrix h = Round(Rand(m,1,0.5,_.H+0.499999999));
    WriteLn("TRACE "+_MID+"2 h:\n"<<h);
    VMatrix y = SubRow(_.Y,VCol2Set(h));
    WriteLn("TRACE "+_MID+"3 y:\n"<<y);
    VMatrix v = Gaussian(m,_.n,0,1);
    WriteLn("TRACE "+_MID+"4 v:\n"<<v);
    VMatrix u = v*(VMatDat(MtMSqr(v),1,1)^-0.5);
    WriteLn("TRACE "+_MID+"5 u:\n"<<u);
    VMatrix rnd = get.radius(h)$*Rand(m,1,0,1);
    WriteLn("TRACE "+_MID+"5 rnd:\n"<<rnd);
    VMatrix r = Eye(m,m,0,rnd);
    WriteLn("TRACE "+_MID+"6 r:\n"<<r);
    y + r * u
  }


};
