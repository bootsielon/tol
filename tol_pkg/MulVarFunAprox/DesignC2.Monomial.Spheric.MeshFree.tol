/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : DesignC2.Monomial.Spheric.MeshFree.tol
// PURPOSE: Defines Class @DesignC2.Monomial.Spheric.MeshFree
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.DesignC2.Monomial.Spheric.MeshFree.tol = 
"";
Class @DesignC2.Monomial.Spheric.MeshFree : 
  @DesignC2.Monomial, 
  @DesignC2.Spheric
//////////////////////////////////////////////////////////////////////////////
{
//////////////////////////////////////////////////////////////////////////////
//Configuration parameters
//////////////////////////////////////////////////////////////////////////////
  Real stress.maxDistance;

  ////////////////////////////////////////////////////////////////////////////
  Static @DesignC2.Monomial.Spheric.MeshFree New(
    VMatrix X, 
    Real maxNeighbour,
    Real radius.margin,
    Real stress.maxDistance_)
  ////////////////////////////////////////////////////////////////////////////
  {
    @DesignC2.Monomial.Spheric.MeshFree new =
    [[ 
      VMatrix _.X = X;
      Real _.n = VColumns(X);
      Real _.J = VRows(X);
      Real _.X.maxNeighbour = maxNeighbour+1;
      Real _.radius.margin = radius.margin;
      Real stress.maxDistance = stress.maxDistance_
    ]] 
  };

  //////////////////////////////////////////////////////////////////////////////
  Real build.reference.points(Real void)
  //////////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[@DesignC2.Monomial.Spheric.MeshFree::build.reference.points] ";
    Real set.reference.points(_.X);
    VMatrix _.Yj := Constant(_.H,1,_.X.maxNeighbour-1);
    _.H
  };

  //////////////////////////////////////////////////////////////////////////////
  Real build.stress.points(Real void)
  //////////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[@DesignC2.Monomial.Spheric.Delaunay2D::build.stress.points] ";
    Real _.Z.maxNeighbour := If(prior.Z.order>=0,2,0);
    If(!_.Z.maxNeighbour, 
    {
      VMatrix _.Yt := Zeros(_.H,1);
      Real _.Tz := 0
    },{
    Set Y1_ = For(2,_.X.maxNeighbour,VMatrix(Real k)
    {
      Mat2VMat(SubCol(_.ngbh::_.neighbour,[[1]]))
    });
    Set Y2_ = For(2,_.X.maxNeighbour,VMatrix(Real k)
    {
      Mat2VMat(SubCol(_.ngbh::_.neighbour,[[k]]))
    });
    Set distance_ = For(2,_.X.maxNeighbour,VMatrix(Real k)
    {
      Mat2VMat(Sqrt(SubCol(_.ngbh::_.distance2,[[k]])))
    });
    Set match_ = For(1,_.X.maxNeighbour-1,VMatrix(Real k)
    {
      And(
        LE(distance_[k], Constant(_.H,1,stress.maxDistance)),
        LT(Y1_[k],Y2_[k]))
    });
    VMatrix distance.all = Group("ConcatRows",distance_);
    VMatrix Y1.all = Group("ConcatRows",Y1_);
    VMatrix Y2.all = Group("ConcatRows",Y2_);
    VMatrix match = Group("ConcatRows",match_);
    Set sel = MatQuery::SelectMatch(match);
    VMatrix distance = SubRow(distance.all,sel);
    VMatrix Y1 = SubRow(Y1.all,sel);
    VMatrix Y2 = SubRow(Y2.all,sel);
    VMatrix _.Z.h := Y1 | Y2;
    VMatrix _.Z := (SubRow(_.Y,VCol2Set(Y1))+SubRow(_.Y,VCol2Set(Y2)))/2;
    Real _.Tz := VRows(_.Z);
    VMatrix Z.Y.neighbour = 
    {
      Matrix Z.t = DifEq(1/(1-B),Rand(_.Tz,1,1,1));
      Matrix Z.th = (Z.t << Z.t) | 
       VMat2Mat((SubCol(_.Z.h,[[1]])<<SubCol(_.Z.h,[[2]])));
      Matrix Z.Y.idx = PivotByRows(Z.th,Sort(Z.th,[[2]]));
      Mat2VMat(Z.Y.idx)
    };
    VMatrix aux = MatQuery::SortAndCount(SubCol(Z.Y.neighbour,[[2]]));
    VMatrix _.Yt := Triplet(VMat2Mat(SubCol(aux,[[1]])) |  
                            Rand(VRows(aux),1,1,1) | 
                            VMat2Mat(SubCol(aux,[[2]])),_.H,1);
/*
    VMatrix _.Yt := 
    {
      VMatrix aux= Group("ConcatColumns",match_);
      aux*Constant(_.X.maxNeighbour-1,1,1)
    };
*/
    Real _.Mz := Case(
      prior.Z.order< 0, 0,
      prior.Z.order==0, _.Tz,
      prior.Z.order==1, _.Tz*(1+_.n),
      prior.Z.order==2, _.Tz*(1+_.n*3/2+(1/2)*_.n^2));
    _.Tz
  })};


  //////////////////////////////////////////////////////////////////////////////
  Real build.border.points(Real void)
  //////////////////////////////////////////////////////////////////////////////
  {
    VMatrix _.Yb := Zeros(_.H,1);
    Real _.Tb := 0
  }

};
