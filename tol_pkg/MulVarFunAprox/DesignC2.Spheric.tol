/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : DesignC2.tol
// PURPOSE: Defines Class @DesignC2
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.DesignC2.Spheric = 
"";
Class @DesignC2.Spheric : @DesignC2
//////////////////////////////////////////////////////////////////////////////
{

//////////////////////////////////////////////////////////////////////////////
//Configuration parameters
//////////////////////////////////////////////////////////////////////////////
  Real _.radius.margin;

//////////////////////////////////////////////////////////////////////////////
//Auxiliar members
//////////////////////////////////////////////////////////////////////////////
  VMatrix _.R =Rand(0,0,0,0);
  MatQuery::@ANN.KDTree _.ann = 
    MatQuery::@ANN.KDTree::Default(0);
  MatQuery::@KNN.Neighbourhood _.ngbh = 
    MatQuery::@KNN.Neighbourhood::Default(0);

  //////////////////////////////////////////////////////////////////////////////
  //Methods
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  Real set.reference.points(VMatrix Y)
  //////////////////////////////////////////////////////////////////////////////
  {
    VMatrix _.Y := Y;
    Real _.H := VRows(_.Y);
    Real _.ann::set.data(VMat2Mat(_.Y));
    Real _.ann::update.search(_.ann::_.X,_.X.maxNeighbour,_.ngbh);
    VMatrix _.R := 
      Mat2VMat(Sqrt(SubCol(_.ngbh::_.distance2,[[_.X.maxNeighbour]])))*
      (1+Min(0,_.radius.margin));
    True
  };

  ////////////////////////////////////////////////////////////////////////////
    VMatrix match.evaluable(VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
    MatQuery::@KNN.Neighbourhood ngbh = 
      _.ann::search(VMat2Mat(X),1);    
    VMatrix dist = Mat2VMat(Sqrt(ngbh::_.distance2));
    VMatrix X.h = Mat2VMat(ngbh::_.neighbour);
    LE(dist,get.radius(X.h))$*
    LE(dist,Constant(VRows(dist),1,stress.maxDistance))
  };

  //////////////////////////////////////////////////////////////////////////////
  VMatrix closest.reference.index(VMatrix X)
  //////////////////////////////////////////////////////////////////////////////
  {
    MatQuery::@KNN.Neighbourhood ngbh = 
      _.ann::search(VMat2Mat(X),_.X.maxNeighbour);
    Mat2VMat(ngbh::_.neighbour)
  };

  //////////////////////////////////////////////////////////////////////////////
  VMatrix get.radius(VMatrix Y.idx)
  //////////////////////////////////////////////////////////////////////////////
  {
    SubRow(_.R,VCol2Set(Y.idx))
  };

  //////////////////////////////////////////////////////////////////////////////
    VMatrix build.obs(VMatrix X)
  //////////////////////////////////////////////////////////////////////////////
  {
    FunRn2R::@BaseC2.Eval.Function eval = 
       FunRn2R::@BaseC2.Eval.Function::New(get.base(0));
    MatQuery::@KNN.Neighbourhood ngbh = 
      _.ann::search(VMat2Mat(X),_.X.maxNeighbour);
    Real m = VRows(X);
    VMatrix dist = Mat2VMat(Sqrt(ngbh::_.distance2));
    VMatrix X.h = Mat2VMat(ngbh::_.neighbour);
    VMatrix X.idx = DifEq(1/(1-B),Constant(m,1,1));
    VMatrix triplet.all = Group("ConcatRows", For(1,_.X.maxNeighbour,VMatrix(Real k)
    {
      VMatrix X.h.k = SubCol(X.h,[[k]]);
      VMatrix dist.k = SubCol(dist,[[k]]);
      VMatrix R = get.radius(X.h.k);
      VMatrix tao = dist.k $/ R;
      VMatrix lambda = (-tao^2+1)^4;
      VMatrix match = LT(dist.k,R);
      SubRow(X.idx | X.h.k | dist.k | tao| lambda, MatQuery::SelectMatch(match))
    }));
    VMatrix x.idx = SubCol(triplet.all,[[1]]);
    VMatrix y.idx = SubCol(triplet.all,[[2]]);
    VMatrix xy.idx = x.idx | y.idx;
    VMatrix lambda.col = SubCol(triplet.all,[[5]]);
    VMatrix triplet.lambda = xy.idx | lambda.col;
    VMatrix lambda = Triplet(VMat2Mat(triplet.lambda),m,_.H);
    VMatrix sum.lambda = lambda*Constant(_.H,1,1);
    VMatrix sum.lambda.inv = Convert(sum.lambda,"Blas.R.Dense")^-1;
    VMatrix weight = Eye(m,m,0,sum.lambda.inv)*lambda;
    VMatrix dif = 
      SubRow(  X,VCol2Set(SubCol(triplet.all,[[1]]))) -
      SubRow(_.Y,VCol2Set(SubCol(triplet.all,[[2]]))) ;
    VMatrix P.row = Group("ConcatRows", For(1,_.K,VMatrix(Real k)
    {
      x.idx
    }));
    VMatrix P.y = Group("ConcatRows", For(1,_.K,VMatrix(Real k)
    {
      y.idx
    }));
    VMatrix YnCum = DifEq(1/(1-B),_.Yn);
    VMatrix YnCumB = Sub(SetCol([[0]])<<YnCum,1,1,_.H,1);
    VMatrix P.YnCum  = SubRow(YnCum, VCol2Set(P.y));
    VMatrix P.YnCumB = SubRow(YnCumB,VCol2Set(P.y));
    VMatrix P.k = Group("ConcatRows", For(1,_.K,VMatrix(Real k)
    {
      y.idx*0+k
    }));
    VMatrix P.col = P.YnCumB + P.k;
    VMatrix P.match = LE(P.col,P.YnCum);
    Real eval::upgrade.cache(dif);
    VMatrix P.ev = Group("ConcatRows", For(1,_.K,VMatrix(Real k)
    {
      lambda.col $* eval::evaluate.v(k,dif)
    }));
    Matrix P.triplet = VMat2Mat(
      SubRow(P.row | P.col | P.ev, MatQuery::SelectMatch(P.match)));
    VMatrix Px = Pack(Convert(Triplet(P.triplet, m, _.N),"Cholmod.R.Sparse"));
    VMatrix Qx = Eye(m,m,0,sum.lambda.inv)*Px
  };


  ///////////////////////////////////////////////////////////////////////////
    VMatrix generate.internal.points(Real m)
  ///////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[@DesignC2.Monomial.Spheric.MeshFree::generate.internal.points] ";
    WriteLn("TRACE "+_MID+"1 m="<<m);
    VMatrix h = Round(Rand(m,1,0.5,_.H+0.499999999));
    WriteLn("TRACE "+_MID+"2 h:\n"<<h);
    VMatrix y = SubRow(_.Y,VCol2Set(h));
    WriteLn("TRACE "+_MID+"3 y:\n"<<y);
    VMatrix v = Gaussian(m,_.n,0,1);
    WriteLn("TRACE "+_MID+"4 v:\n"<<v);
    VMatrix u = v*(VMatDat(MtMSqr(v),1,1)^-0.5);
    WriteLn("TRACE "+_MID+"5 u:\n"<<u);
    VMatrix rnd = get.radius(h)$*Rand(m,1,0,1);
    WriteLn("TRACE "+_MID+"5 rnd:\n"<<rnd);
    VMatrix r = Eye(m,m,0,rnd);
    WriteLn("TRACE "+_MID+"6 r:\n"<<r);
    y + r * u
  };

  ///////////////////////////////////////////////////////////////////////////
  Set get.X.weight(Set X.dif, Set X.h)
  ///////////////////////////////////////////////////////////////////////////
  {
    Real m = VRows(X.dif[1]);
    Real numNeighbour = Card(X.h);
    Set X.tao = For(1,numNeighbour,VMatrix(Real i)
    {
      VMatrix X.norm2 = RPow(X.dif[i],2)*Rand(_.n,1,1,1);
      RPow(X.norm2,0.5)$/get.radius(X.h[i])
    });
    Set X.tao2 = For(1,numNeighbour,VMatrix(Real i)
    {
      RPow(X.tao[i],2)
    });
    Set X.match = For(1,numNeighbour,VMatrix(Real i)
    {
      LE(X.tao[i],Rand(m,1,1,1))
    });
    Set X.lambda = For(1,numNeighbour,VMatrix(Real i)
    {
      RPow(X.match[i] $* (Rand(m,1,1,1)-X.tao2[i]),4)
    });
    VMatrix X.lambda.sum = SetSum(X.lambda);
    
    For(1,numNeighbour,VMatrix(Real i)
    {
      X.lambda[i] $/ X.lambda.sum
    })
  };
  ///////////////////////////////////////////////////////////////////////////
  Set get.X.weight.partial.derivative.1(Set X.dif, Set X.h, Real s)
  ///////////////////////////////////////////////////////////////////////////
  {
    Real m = VRows(X.dif[1]);
    Real numNeighbour = Card(X.h);
    Set X.tao = For(1,numNeighbour,VMatrix(Real i)
    {
      VMatrix X.norm2 = RPow(X.dif[i],2)*Rand(_.n,1,1,1);
      RPow(X.norm2,0.5)$/get.radius(X.h[i])
    });
    Set X.tao2 = For(1,numNeighbour,VMatrix(Real i)
    {
      RPow(X.tao[i],2)
    });
    Set X.match = For(1,numNeighbour,VMatrix(Real i)
    {
      LE(X.tao[i],Rand(m,1,1,1))
    });
    Set X.lambda = For(1,numNeighbour,VMatrix(Real i)
    {
      RPow(X.match[i] $* (Rand(m,1,1,1)-X.tao2[i]),4)
    });
    Set X.lambda.der = For(1,numNeighbour,VMatrix(Real i)
    {
      RPow(X.match[i] $* 
           (Rand(m,1,1,1)-X.tao2[i]),3) $*
           (SubCol(X.dif[i],[[s]])*8) $/ get.radius(X.h[i])
    });
    VMatrix X.lambda.sum = SetSum(X.lambda);
    VMatrix X.lambda.sum.2 = RPow(X.lambda.sum,2);
    VMatrix X.lambda.der.sum = SetSum(X.lambda.der);
    For(1,numNeighbour,VMatrix(Real i)
    {
      (X.lambda.der[i]$*X.lambda.sum-X.lambda[i]$*X.lambda.der.sum) 
      $/ X.lambda.sum.2
    })
  }

};
