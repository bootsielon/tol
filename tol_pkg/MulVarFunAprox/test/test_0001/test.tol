/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : test.tol
// PURPOSE: Package MulVarFunAprox test
//////////////////////////////////////////////////////////////////////////////

Text email_ = "vdebuen@tol-project.org"; 
Text link_ = ""; 
Text summary_ = "Test for mutivariant function aproximation";

//Write here the initial test TOL code if needed
Real numErr0 = Copy(NError);
Real numWar0 = Copy(NWarning);

//Random seed setting
Real PutRandomSeed(1096004697);
Real rndSeed = GetRandomSeed(0);
WriteLn("Current Random Seed = "<<rndSeed);

//#Require MulVarFunAprox;
#Embed "../../MulVarFunAprox.tol";


//////////////////////////////////////////////////////////////////////////////
VMatrix generate.nodal.points(Real J, Real n)
//////////////////////////////////////////////////////////////////////////////
{
  Group("ConcatColumns",For(1,n,VMatrix(Real i)
  {
    Real min = Rand(2,4);
    Real len = Rand(5,10)*(i^(1/n));
    Rand(J,1,min,min+len)
  }))
};
VMatrix X = generate.nodal.points(15000,2);
/* * /
MulVarFunAprox::@DesignC2 design = {
  MulVarFunAprox::@DesignC2.Monomial.Spheric.Grid::New(
    X, radius.margin=0.05) };
/* */
MulVarFunAprox::@DesignC2 design = {
  MulVarFunAprox::@DesignC2.Monomial.Spheric.Disconnected::New(
    VMatrix X, 
    Real radius.margin = Sqrt(2)-1,
    Real radius = .5,
    Real do.build.border = False)};
/* */
//Real design::force.reference.near.nodal := True;
Real design::_.radius.margin := 0.05;
Real design::max.deg := 6;

Real t0 = Copy(Time);
WriteLn("Building model design for "<<design::_.J+" points "<<
  "of dimension "<<design::_.n+" ...");
Real deg = design::build.model.design(0);
Real t.building = Copy(Time)-t0;
WriteLn("Built model design in "<<t.building+" seconds");

Real t0 := Copy(Time);
WriteLn("Building design decomposition for design matrix ("<<
  design::_.M+"x"<<design::_.N+") ...");
Real design::build.decomposition(0);
Real t.decomposition = Copy(Time)-t0;
WriteLn("Input decomposed in "<<t.decomposition+" seconds");

FunRn2R::@BaseC2 b = design::get.base(0);

FunRn2R::@FunC2 base.random.fun=FunRn2R::@FunC2.InBaseC2::Random(b, 1);

//////////////////////////////////////////////////////////////////////////////
VMatrix fun.eval.extra.base(VMatrix X) 
//////////////////////////////////////////////////////////////////////////////
{
   BinGroup("$*",For(1,design::_.n,VMatrix(Real i) 
   { 
     VMatrix Xi = SubCol(X,[[i]]);
     If(i%2==1,Sin(Xi),Cos(Xi))
   })) 
   $* RPow(SubCol(X,[[1]]),2)
};

//Code fun.eval = fun.eval.extra.base;
Code fun.eval = base.random.fun::eval.function.v;
Real b::upgrade.cache(design::_.X,0);


Real t0 := Copy(Time);
WriteLn("Running regression model for design matrix "<<design::_.Q);
MulVarFunAprox::@ModelC2 model = MulVarFunAprox::@ModelC2::New(
   design,
   fun.eval(design::_.X));
Real t.estimating = Copy(Time)-t0;
WriteLn("Estimated model in "<<t.estimating+" seconds");

VMatrix X2 = { design::generate.internal.points(
  Real m = design::_.J/2,
  True)};

Real b::upgrade.cache(X2,0);
VMatrix Fx2 = fun.eval(X2);
Real t0 := Copy(Time);
WriteLn("Evaluating forecast for "<<VRows(X2)+" points...");
VMatrix F2.frc = model::evaluate(X2);
Real t.forecasting = Copy(Time)-t0;
WriteLn("Evaluated forecast in "<<t.forecasting+" seconds");
WriteLn("Forecast time by point "<<(t.forecasting/VRows(X2))+" seconds");
VMatrix F2.cmp = Fx2 | F2.frc;
VMatrix E2 = Fx2 - F2.frc;
Real E2.avr = VMatAvr(E2);
Real E2.ste = VMatStDs(E2);

Real q.1 = 1-model::_.E.ste;
Real q.2 = 1-E2.ste;
Set View([[
  Real design::_.n, design::_.K, design::_.J, design::_.H, 
  design::_.X.maxNeighbour, design::_.Z.maxNeighbour,
  design::_.T, design::_.N, design::_.Mz, design::_.M, 
  model::_.E.avr, model::_.E.ste,
  "\n"]],"");

Set View([[
  E2.avr, E2.ste, 
  "\n"]],"");

VMatrix show.X.Y = 
  ((design::_.X*0) <<  design::_.Y   ) |
  ( design::_.X    << (design::_.Y*0)); 

VMatrix show.X.Y.Z = 
  ( design::_.X    << (design::_.Y*0) << (design::_.Z*0)) |
  ((design::_.X*0) <<  design::_.Y    << (design::_.Z*0)) | 
  ((design::_.X*0) << (design::_.Y*0) <<  design::_.Z   ); 

VMatrix show.Y.Z = 
  ( design::_.Y    << (design::_.Z*0)) | 
  ((design::_.Y*0) <<  design::_.Z   ); 



Real numErr1 = Copy(NError);
Real numWar1 = Copy(NWarning);

Set partialResults_ = [[numErr0, numErr1, 
                        q.1, q.2]];

//This is a messure of the success of the test 
Real quality_ = And(numErr1 == numErr0, 
                    numWar1 == numWar0)*Min(q.1,q.2);

//Return the results 
Set resultStr_ = @strTestStatus(summary_, link_, quality_,
                  "Partial results = "<<partialResults_,
                  "NO DBServerType", "NO DBServerHost", "NO DBAlias",
                  email_);
WriteLn(""<<resultStr_);
resultStr_;

/* */

