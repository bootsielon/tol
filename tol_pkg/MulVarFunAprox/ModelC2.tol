/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : ModelC2.tol
// PURPOSE: Defines Class @ModelC2
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
Text _.autodoc.member.ModelC2 = 
"";
Class @ModelC2
//////////////////////////////////////////////////////////////////////////////
{
  @DesignC2 _.design;
  VMatrix _.Fx;

//////////////////////////////////////////////////////////////////////////////
//Auxiliar members
//////////////////////////////////////////////////////////////////////////////
  VMatrix _.F = Rand(0,1,0,0);
  VMatrix _.Fz = Rand(0,1,0,0);
  VMatrix _.Fb = Rand(0,1,0,0);
  VMatrix _.alpha = Rand(0,1,0,0);
  VMatrix _.F.frc = Rand(0,1,0,0);
  VMatrix _.F.cmp = Rand(0,2,0,0);
  VMatrix _.E = Rand(0,1,0,0);
  Real _.E.avr = ?;
  Real _.E.ste = ?;

  //////////////////////////////////////////////////////////////////////////////
    Static @ModelC2 New(@DesignC2 design, VMatrix Fx)
  //////////////////////////////////////////////////////////////////////////////
  {
    @ModelC2 new =
    [[
      @DesignC2 _.design = design;
      VMatrix _.Fx = Fx
    ]];
    Real new::estimate(0);
    new
  };

  //////////////////////////////////////////////////////////////////////////////
    Static @ModelC2 New.Monomial.Spheric.Disconnected(
     VMatrix Fx,
     VMatrix X, 
     Real max.deg,
     Real min.contrast.surface,
     Real radius.margin,
     Real radius,
     Real do.build.border)
  //////////////////////////////////////////////////////////////////////////////
  {
    Text _MID = "[@ModelC2::New.Monomial.Spheric.Disconnected] ";
    MulVarFunAprox::@DesignC2 design = {
      MulVarFunAprox::@DesignC2.Monomial.Spheric.Disconnected::New(
        VMatrix X, 
        Real radius.margin,
        Real radius,
        Real do.build.border)};
    Real design::max.deg := max.deg;
    Real design::min.contrast.surface := min.contrast.surface;
    Real t0 = Copy(Time);
    WriteLn("TRACE"+_MID+"Building model design for "<<design::_.J+" points "<<
      "of dimension "<<design::_.n+" ...");
    Real deg = design::build.model.design(0);
    Real t.building = Copy(Time)-t0;
    WriteLn("TRACE"+_MID+"Built model design in "<<t.building+" seconds");
    Real t0 := Copy(Time);
    WriteLn("TRACE"+_MID+"Building decomposition for design matrix ("<<
      design::_.M+"x"<<design::_.N+") ...");
    Real design::build.decomposition(0);
    Real t.decomposition = Copy(Time)-t0;
    WriteLn("TRACE"+_MID+"Input decomposed in "<<t.decomposition+" seconds");
    Real t0 := Copy(Time);
    WriteLn("TRACE"+_MID+"Running regression model for design matrix "<<design::_.Q);
    MulVarFunAprox::@ModelC2 model = MulVarFunAprox::@ModelC2::New(
       design,
       Fx);
    Real t.estimating = Copy(Time)-t0;
    WriteLn("TRACE"+_MID+"Estimated model in "<<t.estimating+" seconds");
    model
  };

  //////////////////////////////////////////////////////////////////////////////
    Real estimate(Real void)
  //////////////////////////////////////////////////////////////////////////////
  {
    VMatrix _.Fz := Rand(_.design::_.Mz,1,0,0);
    VMatrix _.Fb := Rand(_.design::_.Mb,1,0,0);
    VMatrix _.F := _.Fx << _.Fb << _.Fz;
    VMatrix _.alpha := CholeskiSolve(_.design::_.LQ,Tra(Tra(_.F)*_.design::_.Q),"PtLLtP");
    VMatrix _.F.frc := SubRow(_.design::_.Q*_.alpha,Range(1,_.design::_.J,1));
    VMatrix _.F.cmp := _.Fx | _.F.frc;
    VMatrix _.E := _.Fx - _.F.frc;
    Real _.E.avr := VMatAvr(_.E);
    Real _.E.ste := VMatStDs(_.E);
    _.E.ste
  };


  //////////////////////////////////////////////////////////////////////////////
    VMatrix evaluate(VMatrix X)
  //////////////////////////////////////////////////////////////////////////////
  {
    Real m = VRows(X);
    VMatrix X.match = _.design::match.evaluable(X);
    Set X.select = MatQuery::SelectMatch(X.match);
    VMatrix X.1 = SubRow(X,X.select);
    Real m.1 = VRows(X.1);
    VMatrix X.1.h = _.design::closest.reference.index(X.1);
    VMatrix QX.1 = _.design::build.obs(X.1, X.1.h);
    VMatrix F.1 = QX.1*_.alpha;
    Matrix triplet.1 = SetCol(X.select)|Rand(m.1,1,1,1)|VMat2Mat(F.1);
    Pack(Convert(Triplet(triplet.1,m,1),"Cholmod.R.Sparse"))
  };

  //////////////////////////////////////////////////////////////////////////////
    VMatrix evaluate.partial.derivative.1(VMatrix X, Real s)
  //////////////////////////////////////////////////////////////////////////////
  {
    Real m = VRows(X);
    VMatrix X.match = _.design::match.evaluable(X);
    Set X.select = MatQuery::SelectMatch(X.match);
    VMatrix X.1 = SubRow(X,X.select);
    Real m.1 = VRows(X.1);
    VMatrix X.1.h = _.design::closest.reference.index(X.1);
    VMatrix QX.1 = _.design::build.obs.partial.derivative.1(X.1, X.1.h, s);
    VMatrix F.1 = QX.1*_.alpha;
    Matrix triplet.1 = SetCol(X.select)|Rand(m.1,1,1,1)|VMat2Mat(F.1);
    Pack(Convert(Triplet(triplet.1,m,1),"Cholmod.R.Sparse"))
  }

};

