/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : MulVarFunAprox.tol
// PURPOSE: Defines package MulVarFunAprox
//////////////////////////////////////////////////////////////////////////////

NameBlock MulVarFunAprox = [[

#Require MatQuery;

Text _.autodoc.description = "Aproximation of multivariate real functions "
"by means of linear regression.";
Text _.autodoc.url = "";
Set _.autodoc.keys = [["aproximation","interpolation"]];
Set _.autodoc.authors = [[
   "vdebuen@tol-project.org"   ]];

//////////////////////////////////////////////////////////////////////////////
//Base of K mutivariate arbitrary linearly independent functions R^n -> R of 
//class C2, ie, continuous and having first and second partial continuous
//derivatives
//////////////////////////////////////////////////////////////////////////////
Class @BaseC2FunRn2R
{
  //Dimension of domain vectorial space
  Real _.n;
  //Dimension of the base
  Real _.K;

  //Evaluates the k-th basic function for a 
  //point x given as a row matrix
  Real function.r(Real k, VMatrix x);
  //Evaluates the first partial derivative of k-th basic function for a  
  //point x given as a row matrix
  Real partial.derivative.1.r(Real k, VMatrix x, Real i);
  //Evaluates the second partial derivative of k-th basic function for a  
  //point x given as a row matrix
  Real partial.derivative.2.r(Real k, VMatrix x, Real i, Real j);

  //For efficience reasonsthe base has specific method for evaluation over 
  //massive data stored in a matrix

  //Evaluates the k-th basic function for an 
  //array of points given as the rows of a matrix 
  VMatrix function.v(Real k, VMatrix X);
  //Evaluates the first partial derivative of k-th basic function for an  
  //array of points given as the rows of a matrix 
  VMatrix partial.derivative.1.v(Real k, VMatrix X, Real i);
  //Evaluates the second partial derivative of k-th basic function for an  
  //array of points given as the rows of a matrix 
  VMatrix partial.derivative.2.v(Real k, VMatrix X, Real i, Real j)
};

//////////////////////////////////////////////////////////////////////////////
Class @BaseC2FunRn2R.Map : @BaseC2FunRn2R
//////////////////////////////////////////////////////////////////////////////
{
  @BaseC2FunRn2R _.base; 
  Set _.map; 

  Static Text _.autodoc.description = "Extracts a sub-base of a given base "
  "whose k-th basic function are given by _.map[k] basic function of "
  "_.base. Of course _.map cannot have repated indexes to ensure linear "
  "independence.";

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.New = "Creates an instance of "
  "@BaseC2FunRn2R.Map on R^n with specified maximum degree.";
  Static @BaseC2FunRn2R.Map New(@BaseC2FunRn2R base, Set map)
  ////////////////////////////////////////////////////////////////////////////
  {
    @BaseC2FunRn2R.Map aux = [[
      Real _.n = base::_.n;
      Real _.K = Card(map);
      @BaseC2FunRn2R _.base = base; 
      Set _.map = map    
  ]]};
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.function.r = 
  "Evaluates the k-th basic function for a point x given as a row matrix";
  Real function.r(Real k, VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    _.base::function.r(_.map[k], x)
  }; 
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.partial.derivative.1.r = 
  "Evaluates the first partial derivative of k-th basic function for a "  
  "point x given as a row matrix";
  Real partial.derivative.1.r(Real k, VMatrix x, Real i)
  ////////////////////////////////////////////////////////////////////////////
  {
    partial.derivative.1.r(_.map[k], x, i)
  };
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.partial.derivative.2.r = 
  "Evaluates the second partial derivative of k-th basic function for a "
  "point x given as a row matrix";
  Real partial.derivative.2.r(Real k, VMatrix x, Real i, Real j)
  ////////////////////////////////////////////////////////////////////////////
  {
    _.base::partial.derivative.2.r(_.map[k], x, i, j)
  };

  //For efficience reasonsthe base has specific method for evaluation over 
  //massive data stored in a matrix

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.function.v = 
  "Evaluates the k-th basic function for an "
  "array of points given as the rows of a matrix ";
  VMatrix function.v(Real k, VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
    _.base::function.v(_.map[k], X)
  }; 
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.partial.derivative.1.v = 
  "Evaluates the first partial derivative of k-th basic function for an "
  "array of points given as the rows of a matrix";
  VMatrix partial.derivative.1.v(Real k, VMatrix X, Real i)
  ////////////////////////////////////////////////////////////////////////////
  {
    _.base::partial.derivative.1.v(_.map[k], X, i)
  };
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.partial.derivative.2.v = 
  "Evaluates the second partial derivative of k-th basic function for an "
  "array of points given as the rows of a matrix";
  VMatrix partial.derivative.2.v(Real k, VMatrix X, Real i, Real j)
  ////////////////////////////////////////////////////////////////////////////
  {
    _.base::partial.derivative.2.v(_.map[k], X, i, j)
  }
};

//////////////////////////////////////////////////////////////////////////////
Class @BaseC2FunRn2R.Concat : @BaseC2FunRn2R
//////////////////////////////////////////////////////////////////////////////
{
  Static Text _.autodoc.description = "Concats a set of linearly independent "
  "bases over the same domain vectorial space.";

  Set _.base;   //Set of @BaseC2FunRn2R

  //Auxiliar member to map concatenated bases
  Set _.map;

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.New = "Creates an instance of "
  "@BaseC2FunRn2R.Concat on R^n with specified maximum degree.";
  Static @BaseC2FunRn2R.Concat New(Set base)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real n = (base[1])::_.n;
    Set map = BinGroup("<<", For(1,Card(base),Set(Real h)
    {
      If((base[h])::_.n!=n,WriteLn("[@BaseC2FunRn2R.Concat::New] "
      "Cannot concat bases with different domain vectorial space dimension "
      <<n+"!="<<(base[h])::_.n),"E");
      For(1,(base[h])::_.K,Set(Real k)
      {
        [[h,k]]
      })
    }));
    @BaseC2FunRn2R.Concat aux = [[
      Real _.n = base::_.n;
      Real _.K = Card(map);
      Set _.base = base; 
      Set _.map = map
  ]]};
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.function.r = 
  "Evaluates the k-th basic function for a point x given as a row matrix";
  Real function.r(Real k, VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set aux = _.map[k];
    (_.base[aux::h])::function.r(aux::k, x)
  }; 
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.partial.derivative.1.r = 
  "Evaluates the first partial derivative of k-th basic function for a "  
  "point x given as a row matrix";
  Real partial.derivative.1.r(Real k, VMatrix x, Real i)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set aux = _.map[k];
    (_.base[aux::h])::partial.derivative.1.r(aux::k, x, i)
  };
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.partial.derivative.2.r = 
  "Evaluates the second partial derivative of k-th basic function for a "
  "point x given as a row matrix";
  Real partial.derivative.2.r(Real k, VMatrix x, Real i, Real j)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set aux = _.map[k];
    (_.base[aux::h])::_.base::partial.derivative.2.r(aux::k, x, i, j)
  };

  //For efficience reasonsthe base has specific method for evaluation over 
  //massive data stored in a matrix

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.function.v = 
  "Evaluates the k-th basic function for an "
  "array of points given as the rows of a matrix ";
  VMatrix function.v(Real k, VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set aux = _.map[k];
    (_.base[aux::h])::_.base::function.v(aux::k, X)
  }; 
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.partial.derivative.1.v = 
  "Evaluates the first partial derivative of k-th basic function for an "
  "array of points given as the rows of a matrix";
  VMatrix partial.derivative.1.v(Real k, VMatrix X, Real i)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set aux = _.map[k];
    (_.base[aux::h])::_.base::partial.derivative.1.v(aux::k, X, i)
  };
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.partial.derivative.2.v = 
  "Evaluates the second partial derivative of k-th basic function for an "
  "array of points given as the rows of a matrix";
  VMatrix partial.derivative.2.v(Real k, VMatrix X, Real i, Real j)
  ////////////////////////////////////////////////////////////////////////////
  {
    Set aux = _.map[k];
    (_.base[aux::h])::_.base::partial.derivative.2.v(aux::k, X, i, j)
  }
};

//////////////////////////////////////////////////////////////////////////////
Class @BaseC2FunRn2R.Monomial : @BaseC2FunRn2R
//////////////////////////////////////////////////////////////////////////////
{
  Static Text _.autodoc.description = "Base of K mutivariate monomial "
  "functions R^n -> R . Linear independence is ensured since distinct "
  "monomials are allways independent\n";

  //Maximum degree of the monomial: sum of degrees of all variables
  Real _.maxDeg;

  ////////////////////////////////////////////////////////////////////////////
  // Auxiliar memebers
  ////////////////////////////////////////////////////////////////////////////

  //Combination of degrees for each basic function
  Set  _.degComb;
  //Indexes for derivatives {1,...,n} - {i}
  Set  _.range.der.1;
  //Indexes for second derivatives {1,...,n} - {i,j}
  Set  _.range.der.2;

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.New = "Creates an instance of "
  "@BaseC2FunRn2R.Monomial on R^n with specified maximum degree.";
  Static @BaseC2FunRn2R.Monomial New(Real n, Real maxDeg)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatrix degCombAll = Mat2VMat(SetMat(Range(0,maxDeg,1)^n));
    VMatrix degSum = degCombAll*Rand(n,1,1,1); 
    VMatrix match = LE(degSum,Rand(VRows(degCombAll),1,maxDeg,maxDeg));
    Set select = MatQuery::SelectMatch(match);
    Set degComb = VMat2Set(SubRow(degCombAll, select));
    Real K = Card(degComb);
    Set range.der.1 = For(1,n,Set(Real i)
    { 
      Range(1,n,1)-[[i]]
    });
    Set range.der.2 = For(1,n,Set(Real i)
    { 
      For(1,n,Set(Real j)
      { 
        Range(1,n,1)-[[i,j]]
      })
    });
    @BaseC2FunRn2R.Monomial aux = [[
      Real _.n = n;
      Real _.K = K;
      Real _.maxDeg = maxDeg;
      Set _.degComb = degComb;
      Set _.range.der.1 = range.der.1;
      Set _.range.der.2 = range.der.2
  ]]};

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.function.r = 
  "Evaluates the k-th basic function for a point x given as a row matrix";
  Real function.r(Real k, VMatrix x)
  ////////////////////////////////////////////////////////////////////////////
  {
    SetProd(For(1,_.n, Real(Real i)
    {
      MatDat(x,1,i)^_.degComb[k][i]
    }))
  }; 
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.partial.derivative.1.r = 
  "Evaluates the first partial derivative of k-th basic function for a "  
  "point x given as a row matrix";
  Real partial.derivative.1.r(Real k, VMatrix x, Real i)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real d = _.degComb[k][i];
    If(d==0, 0,
    {
      (MatDat(x,1,i)^(d-1))*d*
      SetProd(EvalSet(_.range.der.1[i], Real(Real h)
      {
        MatDat(x,1,h)^_.degComb[k][h]
      }))
    })
  };
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.partial.derivative.2.r = 
  "Evaluates the second partial derivative of k-th basic function for a "
  "point x given as a row matrix";
  Real partial.derivative.2.r(Real k, VMatrix x, Real i, Real j)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(i==j,
    {
      Real d = _.degComb[k][i];
      If(d<=1, 0,
      {
        (MatDat(x,1,i)^(d-2))*(d-1)*d*
        SetProd(EvalSet(_.range.der.1[i], Real(Real h)
        {
          MatDat(x,1,h)^_.degComb[k][h]
        }))
      })
    },
    {
      Real d.i = _.degComb[k][i];
      Real d.j = _.degComb[k][j];
      If(Or(d.i==0, d.j==0), 0,
      {
        (MatDat(x,1,i)^(d.i-1))*d.i*
        (MatDat(x,1,j)^(d.j-1))*d.j*
        SetProd(EvalSet(_.range.der.2[i][j], Real(Real h)
        {
          MatDat(x,1,h)^_.degComb[k][h]
        }))
      })
    })
  };

  //For efficience reasonsthe base has specific method for evaluation over 
  //massive data stored in a matrix

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.function.v = 
  "Evaluates the k-th basic function for an "
  "array of points given as the rows of a matrix ";
  VMatrix function.v(Real k, VMatrix X)
  ////////////////////////////////////////////////////////////////////////////
  {
    BinGroup("$*", For(1,_.n, VMatrix(Real i)
    {
      RPow(SubCol(X,[[i]]),_.degComb[k][i])
    }))
  }; 
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.partial.derivative.1.v = 
  "Evaluates the first partial derivative of k-th basic function for an "
  "array of points given as the rows of a matrix";
  VMatrix partial.derivative.1.v(Real k, VMatrix X, Real i)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real d = _.degComb[k][i];
    If(d==0, Rand(VRows(X),1,0,0),
    {
      VMatrix aux = (RPow(SubCol(X,[[i]]),d-1)*d);
      If(!Card(_.range.der.1[i]),aux,aux $*
      BinGroup("$*", EvalSet(_.range.der.1[i], VMatrix rd1(Real h)
      {
        RPow(SubCol(X,[[h]]),_.degComb[k][h])
      })))
    })
  };
  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.partial.derivative.2.v = 
  "Evaluates the second partial derivative of k-th basic function for an "
  "array of points given as the rows of a matrix";
  VMatrix partial.derivative.2.v(Real k, VMatrix X, Real i, Real j)
  ////////////////////////////////////////////////////////////////////////////
  {
    If(i==j,
    {
      Real d = _.degComb[k][i];
      If(d<=1, Rand(VRows(X),1,0,0),
      {
        VMatrix aux = (RPow(SubCol(X,[[i]]),d-2)*((d-1)*d));
        If(!Card(_.range.der.1[i]),aux,aux $*
        BinGroup("$*", EvalSet(_.range.der.1[i], VMatrix rd21(Real h)
        {
          RPow(SubCol(X,[[h]]),_.degComb[k][h])
        })))
      })
    },
    {
      Real d.i = _.degComb[k][i];
      Real d.j = _.degComb[k][j];
      If(Or(d.i==0, d.j==0), Rand(VRows(X),1,0,0),
      {
        VMatrix aux = (RPow(SubCol(X,[[i]]),d.i-1)*d.i) $*
                      (RPow(SubCol(X,[[j]]),d.j-1)*d.j);
        If(!Card(_.range.der.2[i][j]),aux,aux $*
        BinGroup("$*", EvalSet(_.range.der.2[i][j], VMatrix rd22(Real h)
        {
          RPow(SubCol(X,[[h]]),_.degComb[k][h])
        })))
      })
    })
  }
}


]];
