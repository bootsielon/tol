/* -*- mode: C++ -*- */
//////////////////////////////////////////////////////////////////////////////
// FILE   : MatEncode.tol
// PURPOSE: Defines Package MatEncode
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
NameBlock MatEncode =
//////////////////////////////////////////////////////////////////////////////
[[

  #Require HashMap;
  #Require MatQuery;

Text _.autodoc.description = "Handling and storing generic features, "
"numerical or not, in an efficient way by means of encoded matrices.";
Text _.autodoc.url = "";
Set _.autodoc.keys = [["encode","decode","category","feature"]];
Set _.autodoc.authors = [[
   "vdebuen@tol-project.org" ]];

//////////////////////////////////////////////////////////////////////////////
Class @Feature
//////////////////////////////////////////////////////////////////////////////
{
  Static Text _.autodoc.description = "Class for handling with abstract "
  "features of arbitrary entities, numerical or not, that will be stored in "
  "an external matrix with a row for each entity.";
  //The name of the feature
  Text _.name;
  //The number of the feature in the full set of features
  Real _.position;

  Real is.numeric(Real void);

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.get = "Returns the stored value corresponding "
  "to this feature related to an individual entity.";
  Anything get(VMatrix store, Real entity)
  ////////////////////////////////////////////////////////////////////////////
};

//////////////////////////////////////////////////////////////////////////////
Class @Feature.Numeric : @Feature
//////////////////////////////////////////////////////////////////////////////
{
  Static Text _.autodoc.description = "Class for handling with numerical "
  "numerical features of arbitrary entities that will be stored in an "
  "external matrix with a row for each entity.";

  Real is.numeric(Real void) { True };

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.New = "Creates a new instance of "
  "Class @Feature.Numeric";
  Static @Feature.Numeric New(Text name, Real position)
  ////////////////////////////////////////////////////////////////////////////
  {
    @Feature.Numeric aux =
    [[
      Text _.name = name;
      Real _.position  = position
    ]]
  };
  
  ////////////////////////////////////////////////////////////////////////////
  Anything get(VMatrix store, Real entity)
  ////////////////////////////////////////////////////////////////////////////
  {
    VMatDat(store, entity, _.position)
  }
};

//////////////////////////////////////////////////////////////////////////////
Class @Feature.NonNumeric : @Feature
//////////////////////////////////////////////////////////////////////////////
{
  Static Text _.autodoc.description = "Class for handling with numerical "
  "numerical features of arbitrary entities that will be stored in an "
  "external matrix with a row for each entity. Here the stored value is the "
  "index of the feature stored in an arbitrary domain.";

  //The set of valid values for this feature indexed by name
  Set _.domain;

  Real is.numeric(Real void) { False };

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.New = "Creates a new instance of "
  "Class @Feature.NonNumeric";
  Static @Feature.NonNumeric New(Text name, Real position, Set domain)
  ////////////////////////////////////////////////////////////////////////////
  {
    @Feature.NonNumeric aux =
    [[
      Text _.name = name;
      Real _.position  = position;
      Set _.domain = domain    
    ]];
    Real SetIndexByName(aux::_.domain);
    aux
  }; 

  ////////////////////////////////////////////////////////////////////////////
  Anything get(VMatrix store, Real entity)
  ////////////////////////////////////////////////////////////////////////////
  {
    Real idx = VMatDat(store, entity, _.position);
    _.domain[idx]
  };

  ////////////////////////////////////////////////////////////////////////////
  Real domain.index(Text name)
  ////////////////////////////////////////////////////////////////////////////
  {
    FindIndexByName(_.domain, name)
  }
};

//////////////////////////////////////////////////////////////////////////////
Class @FeatureSet
//////////////////////////////////////////////////////////////////////////////
{
  //Stores and index by name a set of instances od @Feature
  Set _.feature = Copy(Empty);
  //In each row of this matrix are stored the values or indexes of features
  //related to an individual entity
  VMatrix _.data = Rand(0,0,0,0);

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.New = "Creates a new instance of "
  "Class @FeatureSet";
  Static @FeatureSet New(Real void)
  ////////////////////////////////////////////////////////////////////////////
  {
    @FeatureSet aux
  };

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.add.feature.numeric = 
  "Adds a new numerical feature";
  Real add.feature.numeric(Text name)
  ////////////////////////////////////////////////////////////////////////////
  {
    HashMap::Append.Indexed(
      _.feature,
      @Feature.Numeric::New(name, Card(_.feature)+1),
      name)
  };

  ////////////////////////////////////////////////////////////////////////////
  Static Text _.autodoc.member.add.feature.nonnumeric=
  "Adds a new non numerical feature";
  Real add.feature.nonnumeric(Text name, Set domain)
  ////////////////////////////////////////////////////////////////////////////
  {
    HashMap::Append.Indexed(
      _.feature,
      @Feature.NonNumeric::New(name, Card(_.feature)+1, domain),
      name)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.get.feature.index = "Returns the index of a feature "
  "or 0 if it not exists";
  Real get.feature.index(Text name)
  ////////////////////////////////////////////////////////////////////////////
  {
    FindIndexByName(_.feature, name )
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.get = "Returns the value of a feature for an entity";
  Anything get(Real entity, 
               Anything feature) //Real position or Text name
  ////////////////////////////////////////////////////////////////////////////
  {
    @Feature f = _.feature[feature];
    f::get(_.data, entity)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.get.all = "Returns a set with the values of all "
  "features for an entity";
  Set get.all(Real entity) 
  ////////////////////////////////////////////////////////////////////////////
  { 
    EvalSet(_.feature, Anything get.all.cycle(@FeatureSet f) 
    { 
      f::get(_.data, entity)
    })
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.match.feature.with.value = 
  "Returns a column matrix with True in rows where given feature has "
  "specified value, numerical or not. If the value is not numeric argument "
  "'value.id' must be its name to search it in feature domain";
  VMatrix match.feature.with.value(
    Text feature.name, 
    Anything value.id) //Text value identifier in domain or  Real value
  ////////////////////////////////////////////////////////////////////////////
  {
    Real num = get.feature.index(feature.name);
    @Feature f = _.feature[num];
    Real value = If(f::is.numeric(0),
      value.id,
      f::_.domain.index(value.id));
    MatQuery::MatchRowsWithValue(SubCol(_.data,[[num]]),value)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.match.feature.in.interval = 
  "Returns a column matrix with True in rows where given numerical feature "
  "whose cell is inside the interval defined as: \n"
  "  [min,max]: if minIncluded=True  and minIncluded=True\n"
  "  (min,max]: if minIncluded=False and minIncluded=True\n"
  "  [min,max): if minIncluded=True  and minIncluded=False\n"
  "  (min,max): if minIncluded=False and minIncluded=False\n";
  VMatrix match.feature.in.interval(
    Text feature.name, 
    Real minIncluded,
    Real min, 
    Real max,
    Real maxIncluded) 
  ////////////////////////////////////////////////////////////////////////////
  {
    Real num = get.feature.index(feature.name);
    @Feature f = _.feature[num];
    MatQuery::MatchRowsInInterval(
      SubCol(_.data,[[num]]),
      minIncluded,
      min, 
      max,
      maxIncluded)
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.extract.feature = 
  "Returns a column matrix with all rows with numerical code of a given "
  "feature";
  VMatrix extract.feature(
    Text feature.name, 
    Set row.indexes) //Text value identifier in domain or  Real value
  ////////////////////////////////////////////////////////////////////////////
  {
    Real col = get.feature.index(feature.name);
    SubCol(_.data,[[col]])
  };

  ////////////////////////////////////////////////////////////////////////////
  Text _.autodoc.member.extract.feature.rows = 
  "Returns a column matrix with selected rows with numerical code of a "
  "given feature";
  VMatrix extract.feature.rows(
    Text feature.name, 
    Set row.indexes) //Text value identifier in domain or  Real value
  ////////////////////////////////////////////////////////////////////////////
  {
    Real col = get.feature.index(feature.name);
    SubRow(SubCol(_.data,[[col]]),row.indexes)
  }


}

]];
